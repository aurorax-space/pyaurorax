<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>pyaurorax.tools API documentation</title>
<meta name="description" content="Data analysis toolkit for working with all-sky imager data available within the
AuroraX platform …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
<style>
@media screen and (max-width: 699px) {
#content {
padding-left: 2em;
padding-right: 2em;
padding-top: 0;
}
}
@media screen and (min-width: 700px) {
#content {
max-width: 125ch;
padding-left: 3em;
padding-right: 3em;
padding-top: 1em;
border-left: 1px solid #ddd;
}
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyaurorax.tools</code></h1>
</header>
<section id="section-intro">
<p>Data analysis toolkit for working with all-sky imager data available within the
AuroraX platform.</p>
<p>This portion of the PyAuroraX library allows you to easily generate basic plots
for ASI data, and common manipulations. These include things like displaying single
images, making keograms, projecting ASI data onto maps, and extracting metrics for
a given lat/lon bounding box.</p>
<h2 id="example">Example</h2>
<p>For shorter function calls, you can initialize the tools submodule using like so:</p>
<pre><code>import pyaurorax
aurorax = pyaurorax.PyAuroraX()
at = aurorax.tools
</code></pre>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pyaurorax.tools.bounding_box" href="bounding_box/index.html">pyaurorax.tools.bounding_box</a></code></dt>
<dd>
<div class="desc"><p>Methods for working with data in a specific bounding box.</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.tools.calibration" href="calibration/index.html">pyaurorax.tools.calibration</a></code></dt>
<dd>
<div class="desc"><p>Perform various calibration procedures on image data.</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.tools.ccd_contour" href="ccd_contour/index.html">pyaurorax.tools.ccd_contour</a></code></dt>
<dd>
<div class="desc"><p>Obtain contours in pixel coordinates from a skymap for plotting over CCD images.</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.tools.classes" href="classes/index.html">pyaurorax.tools.classes</a></code></dt>
<dd>
<div class="desc"><p>Class definitions for data analysis objects.</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.tools.grid_files" href="grid_files/index.html">pyaurorax.tools.grid_files</a></code></dt>
<dd>
<div class="desc"><p>Prepare grid data for plotting.</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.tools.keogram" href="keogram/index.html">pyaurorax.tools.keogram</a></code></dt>
<dd>
<div class="desc"><p>Generate keograms.</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.tools.montage" href="montage/index.html">pyaurorax.tools.montage</a></code></dt>
<dd>
<div class="desc"><p>Create montages.</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.tools.mosaic" href="mosaic/index.html">pyaurorax.tools.mosaic</a></code></dt>
<dd>
<div class="desc"><p>Prepare data and create mosaics.</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.tools.spectra" href="spectra/index.html">pyaurorax.tools.spectra</a></code></dt>
<dd>
<div class="desc"><p>Work with spectrograph data.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyaurorax.tools.Keogram"><code class="flex name class">
<span>class <span class="ident">Keogram</span></span>
<span>(</span><span>data: numpy.ndarray,<br>timestamp: List[datetime.datetime],<br>instrument_type: str,<br>slice_idx: int | None = None,<br>ccd_y: numpy.ndarray | None = None,<br>mag_y: numpy.ndarray | None = None,<br>geo_y: numpy.ndarray | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Keogram:
    &#34;&#34;&#34;
    Class representation for a keogram

    Attributes:
        data (numpy.ndarray): 
            The derived keogram data.

        timestamp (List[datetime.datetime]): 
            Timestamps corresponding to each keogram slice.

        instrument_type (str): 
            String giving instrument type, either &#39;asi&#39; or &#39;spectrograph&#39;.

        ccd_y (numpy.ndarray): 
            The y-axis representing CCD Y coordinates for the keogram.

        mag_y (numpy.ndarray): 
            The y-axis representing magnetic latitude for the keogram.

        geo_y (numpy.ndarray): 
            The y-axis representing geographic latitude for the keogram.
    &#34;&#34;&#34;

    def __init__(self,
                 data: np.ndarray,
                 timestamp: List[datetime.datetime],
                 instrument_type: str,
                 slice_idx: Optional[int] = None,
                 ccd_y: Optional[np.ndarray] = None,
                 mag_y: Optional[np.ndarray] = None,
                 geo_y: Optional[np.ndarray] = None):
        # public vars
        self.data = data
        self.timestamp = timestamp
        self.instrument_type = instrument_type
        self.ccd_y = ccd_y
        self.mag_y = mag_y
        self.geo_y = geo_y

        # private vars
        self.__slice_idx = slice_idx

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        data_str = &#34;array(dims=%s, dtype=%s)&#34; % (self.data.shape, self.data.dtype)
        timestamp_str = &#34;[%d datetime objects]&#34; % (len(self.timestamp))
        ccd_y_str = &#34;None&#34; if self.ccd_y is None else &#34;array(%d values)&#34; % (self.ccd_y.shape[0])
        mag_y_str = &#34;None&#34; if self.mag_y is None else &#34;array(%d values)&#34; % (self.mag_y.shape[0])
        geo_y_str = &#34;None&#34; if self.geo_y is None else &#34;array(%d values)&#34; % (self.geo_y.shape[0])

        return &#34;Keogram(data=%s, timestamp=%s, ccd_y=%s, mag_y=%s, geo_y=%s)&#34; % (data_str, timestamp_str, ccd_y_str, mag_y_str, geo_y_str)

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;
        # set special strings
        data_str = &#34;array(dims=%s, dtype=%s)&#34; % (self.data.shape, self.data.dtype)
        timestamp_str = &#34;[%d datetime objects]&#34; % (len(self.timestamp))
        ccd_y_str = &#34;None&#34; if self.ccd_y is None else &#34;array(%d values)&#34; % (self.ccd_y.shape[0])
        mag_y_str = &#34;None&#34; if self.mag_y is None else &#34;array(%d values)&#34; % (self.mag_y.shape[0])
        geo_y_str = &#34;None&#34; if self.geo_y is None else &#34;array(%d values)&#34; % (self.geo_y.shape[0])

        # print
        print(&#34;Keogram:&#34;)
        print(&#34;  %-17s: %s&#34; % (&#34;data&#34;, data_str))
        print(&#34;  %-17s: %s&#34; % (&#34;timestamp&#34;, timestamp_str))
        print(&#34;  %-17s: %s&#34; % (&#34;instrument_type&#34;, self.instrument_type))
        print(&#34;  %-17s: %s&#34; % (&#34;ccd_y&#34;, ccd_y_str))
        print(&#34;  %-17s: %s&#34; % (&#34;geo_y&#34;, geo_y_str))
        print(&#34;  %-17s: %s&#34; % (&#34;mag_y&#34;, mag_y_str))

    def set_geographic_latitudes(self, skymap: Skymap, altitude_km: Optional[Union[int, float]] = None) -&gt; None:
        &#34;&#34;&#34;
        Set the geographic latitude values for this keogram, using the specified skymap 
        data. The data will be set to the geo_y attribute of this Keogram object, which
        can then be used for plotting and/or further analysis.

        Args:
            skymap (pyaurorax.data.ucalgary.Skymap): 
                The skymap object to use. This parameter is required.

            altitude_km (int): 
                The altitude to use, in kilometers. If not specified, it will use the default in the 
                skymap object. If the specified altitude is not valid, a ValueError will be raised.
        
        Returns:
            None. The Keogram object&#39;s `geo_y` attribute will be updated.

        Raises:
            ValueError: Issues with specified altitude.
        &#34;&#34;&#34;
        # check for slice idx
        if (self.__slice_idx is None):
            raise ValueError(&#34;Unable to set the geographic latitudes since the slice_idx is None. If this keogram &#34; +
                             &#34;object was created as part of the custom_keogram routines or is a spectrogaph keogram, &#34; +
                             &#34;this is expected and performing this action is not supported at this time.&#34;)

        # determine altitude index to use
        if (altitude_km is not None):
            # Obtain lat/lon arrays from skymap
            if (altitude_km * 1000.0 in skymap.full_map_altitude):
                altitude_idx = np.where(altitude_km * 1000.0 == skymap.full_map_altitude)

                self.geo_y = np.squeeze(skymap.full_map_latitude[altitude_idx, :, self.__slice_idx]).copy()
            else:
                # Make sure altitude is in range that can be interpolated
                if (altitude_km * 1000.0 &lt; skymap.full_map_altitude[0]) or (altitude_km * 1000.0 &gt; skymap.full_map_altitude[2]):
                    raise ValueError(&#34;Altitude &#34; + str(altitude_km) + &#34; outside valid range of &#34; +
                                     str((skymap.full_map_altitude[0] / 1000.0, skymap.full_map_altitude[2] / 1000.0)))

                # Initialze empty lat/lon arrays
                lats = np.full(np.squeeze(skymap.full_map_latitude[0, :, :]).shape, np.nan, dtype=skymap.full_map_latitude[0, :, :].dtype)

                # Interpolate lats and lons at desired altitude
                for i in range(skymap.full_map_latitude.shape[1]):
                    for j in range(skymap.full_map_latitude.shape[2]):
                        lats[i, j] = np.interp(altitude_km * 1000.0, skymap.full_map_altitude, skymap.full_map_latitude[:, i, j])

                self.geo_y = lats[:, self.__slice_idx].copy()
        else:
            # use default middle altitude
            self.geo_y = np.squeeze(skymap.full_map_latitude[1, :, self.__slice_idx]).copy()

    def set_magnetic_latitudes(self, skymap: Skymap, timestamp: datetime.datetime, altitude_km: Optional[Union[int, float]] = None) -&gt; None:
        &#34;&#34;&#34;
        Set the magnetic latitude values for this keogram, using the specified skymap 
        data. AACGMv2 will be utilized to perform the calculations. The resulting data
        will be set to the mag_y attribute of this Keogram object, which can then be
        used for plotting and/or further analysis.

        Args:
            skymap (pyaurorax.data.ucalgary.Skymap): 
                The skymap object to use. This parameter is required.

            timestamp (datetime.datetime): 
                The timestamp to use when converting skymap data to magnetic coordinates. Utilizes
                AACGMv2 to do the conversion.

            altitude_km (int): 
                The altitude to use. If not specified, it will use the default in the skymap
                object. If the specified altitude is not valid, a ValueError will be raised.
        
        Returns:
            None. The Keogram object&#39;s `mag_y` attribute will be updated.

        Raises:
            ValueError: Issues with specified altitude.
        &#34;&#34;&#34;
        # check for slice idx
        if (self.__slice_idx is None):
            raise ValueError(&#34;Unable to set the geographic latitudes since the slice_idx is None. If this keogram &#34; +
                             &#34;object was created as part of the custom_keogram routines or is a spectrogaph keogram, &#34; +
                             &#34;this is expected and performing this action is not supported at this time.&#34;)

        # determine altitude index to use
        if (altitude_km is not None):
            # Obtain lat/lon arrays from skymap
            if (altitude_km * 1000.0 in skymap.full_map_altitude):
                altitude_idx = np.where(altitude_km * 1000.0 == skymap.full_map_altitude)

                lats = np.squeeze(skymap.full_map_latitude[altitude_idx, :, :])
                lons = np.squeeze(skymap.full_map_longitude[altitude_idx, :, :])
                lons[np.where(lons &gt; 180)] -= 360.0

            else:
                # Make sure altitude is in range that can be interpolated
                if (altitude_km * 1000.0 &lt; skymap.full_map_altitude[0]) or (altitude_km * 1000.0 &gt; skymap.full_map_altitude[2]):
                    raise ValueError(&#34;Altitude &#34; + str(altitude_km) + &#34; outside valid range of &#34; +
                                     str((skymap.full_map_altitude[0] / 1000.0, skymap.full_map_altitude[2] / 1000.0)))

                # Initialze empty lat/lon arrays
                lats = np.full(np.squeeze(skymap.full_map_latitude[0, :, :]).shape, np.nan, dtype=skymap.full_map_latitude[0, :, :].dtype)
                lons = lats.copy()

                # Interpolate lats and lons at desired altitude
                for i in range(skymap.full_map_latitude.shape[1]):
                    for j in range(skymap.full_map_latitude.shape[2]):
                        lats[i, j] = np.interp(altitude_km * 1000.0, skymap.full_map_altitude, skymap.full_map_latitude[:, i, j])
                        lons[i, j] = np.interp(altitude_km * 1000.0, skymap.full_map_altitude, skymap.full_map_longitude[:, i, j])

                lons[np.where(lons &gt; 180)] -= 360.0

            # Convert lats and lons to geomagnetic coordinates
            mag_lats, mag_lons, mag_alts = aacgmv2.convert_latlon_arr(lats.flatten(),
                                                                      lons.flatten(), (lons * 0.0).flatten(),
                                                                      timestamp,
                                                                      method_code=&#39;G2A&#39;)
            mag_lats = np.reshape(mag_lats, lats.shape)
            mag_lons = np.reshape(mag_lons, lons.shape)

            # Set the y axis to the desired slice index of the magnetic latitudes
            self.mag_y = mag_lats[:, self.__slice_idx].copy()
        else:
            # Convert middle altitude lats and lons to geomagnetic coordinates
            mag_lats, mag_lons, mag_alts = aacgmv2.convert_latlon_arr(np.squeeze(skymap.full_map_latitude[1, :, :]).flatten(),
                                                                      np.squeeze(skymap.full_map_longitude[1, :, :]).flatten(),
                                                                      (skymap.full_map_longitude[1, :, :] * 0.0).flatten(),
                                                                      timestamp,
                                                                      method_code=&#39;G2A&#39;)
            mag_lats = np.reshape(mag_lats, np.squeeze(skymap.full_map_latitude[1, :, :]).shape)
            mag_lons = np.reshape(mag_lons, np.squeeze(skymap.full_map_longitude[1, :, :]).shape)

            # Set the y axis to the desired slice index of the magnetic latitudes
            self.mag_y = mag_lats[:, self.__slice_idx].copy()

    def plot(self,
             y_type: Literal[&#34;ccd&#34;, &#34;mag&#34;, &#34;geo&#34;] = &#34;ccd&#34;,
             title: Optional[str] = None,
             figsize: Optional[Tuple[int, int]] = None,
             cmap: Optional[str] = None,
             aspect: Optional[Union[Literal[&#34;equal&#34;, &#34;auto&#34;], float]] = None,
             axes_visible: bool = True,
             xlabel: str = &#34;Time (UTC)&#34;,
             ylabel: Optional[str] = None,
             xtick_increment: Optional[int] = None,
             ytick_increment: Optional[int] = None,
             returnfig: bool = False,
             savefig: bool = False,
             savefig_filename: Optional[str] = None,
             savefig_quality: Optional[int] = None) -&gt; Any:
        &#34;&#34;&#34;
        Generate a plot of the keogram data. 
        
        Either display it (default behaviour), save it to disk (using the `savefig` parameter), or 
        return the matplotlib plot object for further usage (using the `returnfig` parameter).

        Args:
            y_type (str): 
                Type of y-axis to use when plotting. Options are `ccd`, `mag`, or `geo`. The
                default is `ccd`. This parameter is required.

            title (str): 
                The title to display above the plotted keogram. Default is no title.

            figsize (tuple): 
                The matplotlib figure size to use when plotting. For example `figsize=(14,4)`.

            cmap (str): 
                The matplotlib colormap to use.

                Commonly used colormaps are:

                - REGO: `gist_heat`
                - THEMIS ASI: `gray`
                - TREx Blue: `Blues_r`
                - TREx NIR: `gray`
                - TREx RGB: `None`

                A list of all available colormaps can be found on the 
                [matplotlib documentation](https://matplotlib.org/stable/gallery/color/colormap_reference.html).
            
            aspect (str or float): 
                The matplotlib imshow aspect ration to use. A common value for this is `auto`. All valid values 
                can be found on the [matplotlib documentation](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html).

            axes_visible (bool): 
                Display the axes. Default is `True`.

            xlabel (str): 
                The x-axis label to use. Default is `Time (UTC)`.

            ylabel (str): 
                The y-axis label to use. Default is based on y_type.

            xtick_increment (int): 
                The x-axis tick increment to use. Default is 100.

            ytick_increment (int): 
                The y-axis tick increment to use. Default is 50.

            returnfig (bool): 
                Instead of displaying the image, return the matplotlib figure object. This allows for further plot 
                manipulation, for example, adding labels or a title in a different location than the default. 
                
                Remember - if this parameter is supplied, be sure that you close your plot after finishing work 
                with it. This can be achieved by doing `plt.close(fig)`. 
                
                Note that this method cannot be used in combination with `savefig`.

            savefig (bool): 
                Save the displayed image to disk instead of displaying it. The parameter savefig_filename is required if 
                this parameter is set to True. Defaults to `False`.

            savefig_filename (str): 
                Filename to save the image to. Must be specified if the savefig parameter is set to True.

            savefig_quality (int): 
                Quality level of the saved image. This can be specified if the savefig_filename is a JPG image. If it
                is a PNG, quality is ignored. Default quality level for JPGs is matplotlib/Pillow&#39;s default of 75%.

        Returns:
            The displayed keogram, by default. If `savefig` is set to True, nothing will be returned. If `returnfig` is 
            set to True, the plotting variables `(fig, ax)` will be returned.

        Raises:
            ValueError: issues encountered with the y-axis choice
        &#34;&#34;&#34;
        # check return mode
        if (returnfig is True and savefig is True):
            raise ValueError(&#34;Only one of returnfig or savefig can be set to True&#34;)
        if returnfig is True and (savefig_filename is not None or savefig_quality is not None):
            show_warning(&#34;The figure will be returned, but a savefig option parameter was supplied. Consider &#34; +
                         &#34;removing the savefig option parameter(s) as they will be ignored.&#34;,
                         stacklevel=1)
        elif savefig is False and (savefig_filename is not None or savefig_quality is not None):
            show_warning(&#34;A savefig option parameter was supplied, but the savefig parameter is False. The &#34; +
                         &#34;savefig option parameters will be ignored.&#34;,
                         stacklevel=1)

        # init figure and plot data
        fig = plt.figure(figsize=figsize)
        ax = fig.add_axes((0, 0, 1, 1))
        ax.imshow(self.data, origin=&#34;lower&#34;, cmap=cmap, aspect=aspect)

        # set title
        if (title is not None):
            ax.set_title(title)

        # set axes
        if (axes_visible is True):
            # do checks for y-axis that was chosen
            if (y_type == &#34;geo&#34; and self.geo_y is None):
                raise ValueError(&#34;Unable to plot using geo_y data. The geo_y attribute is currently None, so either populate &#34;
                                 &#34;it with data using the set_geographic_latitudes() function, or choose a different y_type&#34;)
            elif (y_type == &#34;mag&#34; and self.mag_y is None):
                raise ValueError(&#34;Unable to plot using mag_y data. The mag_y attribute is currently None, so either populate &#34;
                                 &#34;it with data using the set_magnetic_latitudes() function, or choose a different y_type&#34;)

            # set y axis data, and y label
            y_axis_data = self.ccd_y
            if (y_type == &#34;mag&#34;):
                y_axis_data = self.mag_y
                if (ylabel is None):
                    ylabel = &#34;Magnetic latitude&#34;
            elif (y_type == &#34;geo&#34;):
                y_axis_data = self.geo_y
                if (ylabel is None):
                    ylabel = &#34;Geographic latitude&#34;
            else:
                if (ylabel is None):
                    ylabel = &#34;CCD Y&#34;

            # print labels
            ax.set_xlabel(xlabel, fontsize=14)
            ax.set_ylabel(ylabel, fontsize=14)

            # generate x ticks and labels
            #
            # TODO: make this more dynamic
            if (xtick_increment is None):
                xtick_increment = 100  # assume data is 3 second cadence; good enough for now
            x_ticks = np.arange(0, self.data.shape[1], xtick_increment)
            x_labels = self.timestamp[::xtick_increment]
            for i in range(0, len(x_labels)):
                x_labels[i] = x_labels[i].strftime(&#34;%H:%M&#34;)  # type: ignore
            ax.set_xticks(x_ticks, x_labels)  # type: ignore

            # do check for ccd_y
            if (self.ccd_y is None):
                show_warning(
                    &#34;Unable to plot y-axis. If this keogram object was create as part of the custom_keogram &#34; +
                    &#34;routines, this is expected and plotting a custom keogram with axes is not supported at this time.&#34;,
                    stacklevel=1,
                )
            else:
                # generate y ticks and labels
                if (y_type == &#34;ccd&#34;):
                    # TODO: make this more dynamic
                    if (ytick_increment is None):
                        ytick_increment = 50

                    # generate y ticks and labels
                    y_ticks = y_axis_data[::ytick_increment]  # type: ignore
                    y_labels = y_axis_data[::ytick_increment]  # type: ignore

                    # apply yticks
                    ax.set_yticks(y_ticks, y_labels)  # type: ignore
                elif (y_type == &#34;geo&#34; and self.geo_y is not None) or (y_type == &#34;mag&#34; and self.mag_y is not None):
                    # set tick increments
                    if (ytick_increment is None):
                        ytick_increment = 50

                    # generate y ticks and labels
                    y_ticks = self.ccd_y[25::ytick_increment]
                    y_labels = np.round(
                        y_axis_data,  # type: ignore
                        1).astype(str)[25::ytick_increment]
                    y_labels[np.where(y_labels == &#39;nan&#39;)] = &#39;&#39;

                    # apply yticks
                    ax.set_yticks(y_ticks, y_labels)
        else:
            # disable axes
            ax.set_axis_off()

        # save figure or show it
        if (savefig is True):
            # check that filename has been set
            if (savefig_filename is None):
                raise ValueError(&#34;The savefig_filename parameter is missing, but required since savefig was set to True.&#34;)

            # save the figure
            f_extension = os.path.splitext(savefig_filename)[-1].lower()
            if (&#34;.jpg&#34; == f_extension or &#34;.jpeg&#34; == f_extension):
                # check quality setting
                if (savefig_quality is not None):
                    plt.savefig(savefig_filename, quality=savefig_quality, bbox_inches=&#34;tight&#34;)
                else:
                    plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)
            else:
                if (savefig_quality is not None):
                    # quality specified, but output filename is not a JPG, so show a warning
                    show_warning(&#34;The savefig_quality parameter was specified, but is only used for saving JPG files. The &#34; +
                                 &#34;savefig_filename parameter was determined to not be a JPG file, so the quality will be ignored&#34;,
                                 stacklevel=1)
                plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)

            # clean up by closing the figure
            plt.close(fig)
        elif (returnfig is True):
            # return the figure and axis objects
            return (fig, ax)
        else:
            # show the figure
            plt.show(fig)

            # cleanup by closing the figure
            plt.close(fig)

        # return
        return None</code></pre>
</details>
<div class="desc"><p>Class representation for a keogram</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>The derived keogram data.</dd>
<dt><strong><code>timestamp</code></strong> :&ensp;<code>List[datetime.datetime]</code></dt>
<dd>Timestamps corresponding to each keogram slice.</dd>
<dt><strong><code>instrument_type</code></strong> :&ensp;<code>str</code></dt>
<dd>String giving instrument type, either 'asi' or 'spectrograph'.</dd>
<dt><strong><code>ccd_y</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>The y-axis representing CCD Y coordinates for the keogram.</dd>
<dt><strong><code>mag_y</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>The y-axis representing magnetic latitude for the keogram.</dd>
<dt><strong><code>geo_y</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>The y-axis representing geographic latitude for the keogram.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.tools.Keogram.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self,<br>y_type: Literal['ccd', 'mag', 'geo'] = 'ccd',<br>title: str | None = None,<br>figsize: Tuple[int, int] | None = None,<br>cmap: str | None = None,<br>aspect: Literal['equal', 'auto'] | float | None = None,<br>axes_visible: bool = True,<br>xlabel: str = 'Time (UTC)',<br>ylabel: str | None = None,<br>xtick_increment: int | None = None,<br>ytick_increment: int | None = None,<br>returnfig: bool = False,<br>savefig: bool = False,<br>savefig_filename: str | None = None,<br>savefig_quality: int | None = None) ‑> Any</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         y_type: Literal[&#34;ccd&#34;, &#34;mag&#34;, &#34;geo&#34;] = &#34;ccd&#34;,
         title: Optional[str] = None,
         figsize: Optional[Tuple[int, int]] = None,
         cmap: Optional[str] = None,
         aspect: Optional[Union[Literal[&#34;equal&#34;, &#34;auto&#34;], float]] = None,
         axes_visible: bool = True,
         xlabel: str = &#34;Time (UTC)&#34;,
         ylabel: Optional[str] = None,
         xtick_increment: Optional[int] = None,
         ytick_increment: Optional[int] = None,
         returnfig: bool = False,
         savefig: bool = False,
         savefig_filename: Optional[str] = None,
         savefig_quality: Optional[int] = None) -&gt; Any:
    &#34;&#34;&#34;
    Generate a plot of the keogram data. 
    
    Either display it (default behaviour), save it to disk (using the `savefig` parameter), or 
    return the matplotlib plot object for further usage (using the `returnfig` parameter).

    Args:
        y_type (str): 
            Type of y-axis to use when plotting. Options are `ccd`, `mag`, or `geo`. The
            default is `ccd`. This parameter is required.

        title (str): 
            The title to display above the plotted keogram. Default is no title.

        figsize (tuple): 
            The matplotlib figure size to use when plotting. For example `figsize=(14,4)`.

        cmap (str): 
            The matplotlib colormap to use.

            Commonly used colormaps are:

            - REGO: `gist_heat`
            - THEMIS ASI: `gray`
            - TREx Blue: `Blues_r`
            - TREx NIR: `gray`
            - TREx RGB: `None`

            A list of all available colormaps can be found on the 
            [matplotlib documentation](https://matplotlib.org/stable/gallery/color/colormap_reference.html).
        
        aspect (str or float): 
            The matplotlib imshow aspect ration to use. A common value for this is `auto`. All valid values 
            can be found on the [matplotlib documentation](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html).

        axes_visible (bool): 
            Display the axes. Default is `True`.

        xlabel (str): 
            The x-axis label to use. Default is `Time (UTC)`.

        ylabel (str): 
            The y-axis label to use. Default is based on y_type.

        xtick_increment (int): 
            The x-axis tick increment to use. Default is 100.

        ytick_increment (int): 
            The y-axis tick increment to use. Default is 50.

        returnfig (bool): 
            Instead of displaying the image, return the matplotlib figure object. This allows for further plot 
            manipulation, for example, adding labels or a title in a different location than the default. 
            
            Remember - if this parameter is supplied, be sure that you close your plot after finishing work 
            with it. This can be achieved by doing `plt.close(fig)`. 
            
            Note that this method cannot be used in combination with `savefig`.

        savefig (bool): 
            Save the displayed image to disk instead of displaying it. The parameter savefig_filename is required if 
            this parameter is set to True. Defaults to `False`.

        savefig_filename (str): 
            Filename to save the image to. Must be specified if the savefig parameter is set to True.

        savefig_quality (int): 
            Quality level of the saved image. This can be specified if the savefig_filename is a JPG image. If it
            is a PNG, quality is ignored. Default quality level for JPGs is matplotlib/Pillow&#39;s default of 75%.

    Returns:
        The displayed keogram, by default. If `savefig` is set to True, nothing will be returned. If `returnfig` is 
        set to True, the plotting variables `(fig, ax)` will be returned.

    Raises:
        ValueError: issues encountered with the y-axis choice
    &#34;&#34;&#34;
    # check return mode
    if (returnfig is True and savefig is True):
        raise ValueError(&#34;Only one of returnfig or savefig can be set to True&#34;)
    if returnfig is True and (savefig_filename is not None or savefig_quality is not None):
        show_warning(&#34;The figure will be returned, but a savefig option parameter was supplied. Consider &#34; +
                     &#34;removing the savefig option parameter(s) as they will be ignored.&#34;,
                     stacklevel=1)
    elif savefig is False and (savefig_filename is not None or savefig_quality is not None):
        show_warning(&#34;A savefig option parameter was supplied, but the savefig parameter is False. The &#34; +
                     &#34;savefig option parameters will be ignored.&#34;,
                     stacklevel=1)

    # init figure and plot data
    fig = plt.figure(figsize=figsize)
    ax = fig.add_axes((0, 0, 1, 1))
    ax.imshow(self.data, origin=&#34;lower&#34;, cmap=cmap, aspect=aspect)

    # set title
    if (title is not None):
        ax.set_title(title)

    # set axes
    if (axes_visible is True):
        # do checks for y-axis that was chosen
        if (y_type == &#34;geo&#34; and self.geo_y is None):
            raise ValueError(&#34;Unable to plot using geo_y data. The geo_y attribute is currently None, so either populate &#34;
                             &#34;it with data using the set_geographic_latitudes() function, or choose a different y_type&#34;)
        elif (y_type == &#34;mag&#34; and self.mag_y is None):
            raise ValueError(&#34;Unable to plot using mag_y data. The mag_y attribute is currently None, so either populate &#34;
                             &#34;it with data using the set_magnetic_latitudes() function, or choose a different y_type&#34;)

        # set y axis data, and y label
        y_axis_data = self.ccd_y
        if (y_type == &#34;mag&#34;):
            y_axis_data = self.mag_y
            if (ylabel is None):
                ylabel = &#34;Magnetic latitude&#34;
        elif (y_type == &#34;geo&#34;):
            y_axis_data = self.geo_y
            if (ylabel is None):
                ylabel = &#34;Geographic latitude&#34;
        else:
            if (ylabel is None):
                ylabel = &#34;CCD Y&#34;

        # print labels
        ax.set_xlabel(xlabel, fontsize=14)
        ax.set_ylabel(ylabel, fontsize=14)

        # generate x ticks and labels
        #
        # TODO: make this more dynamic
        if (xtick_increment is None):
            xtick_increment = 100  # assume data is 3 second cadence; good enough for now
        x_ticks = np.arange(0, self.data.shape[1], xtick_increment)
        x_labels = self.timestamp[::xtick_increment]
        for i in range(0, len(x_labels)):
            x_labels[i] = x_labels[i].strftime(&#34;%H:%M&#34;)  # type: ignore
        ax.set_xticks(x_ticks, x_labels)  # type: ignore

        # do check for ccd_y
        if (self.ccd_y is None):
            show_warning(
                &#34;Unable to plot y-axis. If this keogram object was create as part of the custom_keogram &#34; +
                &#34;routines, this is expected and plotting a custom keogram with axes is not supported at this time.&#34;,
                stacklevel=1,
            )
        else:
            # generate y ticks and labels
            if (y_type == &#34;ccd&#34;):
                # TODO: make this more dynamic
                if (ytick_increment is None):
                    ytick_increment = 50

                # generate y ticks and labels
                y_ticks = y_axis_data[::ytick_increment]  # type: ignore
                y_labels = y_axis_data[::ytick_increment]  # type: ignore

                # apply yticks
                ax.set_yticks(y_ticks, y_labels)  # type: ignore
            elif (y_type == &#34;geo&#34; and self.geo_y is not None) or (y_type == &#34;mag&#34; and self.mag_y is not None):
                # set tick increments
                if (ytick_increment is None):
                    ytick_increment = 50

                # generate y ticks and labels
                y_ticks = self.ccd_y[25::ytick_increment]
                y_labels = np.round(
                    y_axis_data,  # type: ignore
                    1).astype(str)[25::ytick_increment]
                y_labels[np.where(y_labels == &#39;nan&#39;)] = &#39;&#39;

                # apply yticks
                ax.set_yticks(y_ticks, y_labels)
    else:
        # disable axes
        ax.set_axis_off()

    # save figure or show it
    if (savefig is True):
        # check that filename has been set
        if (savefig_filename is None):
            raise ValueError(&#34;The savefig_filename parameter is missing, but required since savefig was set to True.&#34;)

        # save the figure
        f_extension = os.path.splitext(savefig_filename)[-1].lower()
        if (&#34;.jpg&#34; == f_extension or &#34;.jpeg&#34; == f_extension):
            # check quality setting
            if (savefig_quality is not None):
                plt.savefig(savefig_filename, quality=savefig_quality, bbox_inches=&#34;tight&#34;)
            else:
                plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)
        else:
            if (savefig_quality is not None):
                # quality specified, but output filename is not a JPG, so show a warning
                show_warning(&#34;The savefig_quality parameter was specified, but is only used for saving JPG files. The &#34; +
                             &#34;savefig_filename parameter was determined to not be a JPG file, so the quality will be ignored&#34;,
                             stacklevel=1)
            plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)

        # clean up by closing the figure
        plt.close(fig)
    elif (returnfig is True):
        # return the figure and axis objects
        return (fig, ax)
    else:
        # show the figure
        plt.show(fig)

        # cleanup by closing the figure
        plt.close(fig)

    # return
    return None</code></pre>
</details>
<div class="desc"><p>Generate a plot of the keogram data. </p>
<p>Either display it (default behaviour), save it to disk (using the <code>savefig</code> parameter), or
return the matplotlib plot object for further usage (using the <code>returnfig</code> parameter).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>y_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of y-axis to use when plotting. Options are <code>ccd</code>, <code>mag</code>, or <code>geo</code>. The
default is <code>ccd</code>. This parameter is required.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>The title to display above the plotted keogram. Default is no title.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The matplotlib figure size to use when plotting. For example <code>figsize=(14,4)</code>.</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>The matplotlib colormap to use.</p>
<p>Commonly used colormaps are:</p>
<ul>
<li>REGO: <code>gist_heat</code></li>
<li>THEMIS ASI: <code>gray</code></li>
<li>TREx Blue: <code>Blues_r</code></li>
<li>TREx NIR: <code>gray</code></li>
<li>TREx RGB: <code>None</code></li>
</ul>
<p>A list of all available colormaps can be found on the
<a href="https://matplotlib.org/stable/gallery/color/colormap_reference.html">matplotlib documentation</a>.</p>
</dd>
<dt><strong><code>aspect</code></strong> :&ensp;<code>str</code> or <code>float</code></dt>
<dd>The matplotlib imshow aspect ration to use. A common value for this is <code>auto</code>. All valid values
can be found on the <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html">matplotlib documentation</a>.</dd>
<dt><strong><code>axes_visible</code></strong> :&ensp;<code>bool</code></dt>
<dd>Display the axes. Default is <code>True</code>.</dd>
<dt><strong><code>xlabel</code></strong> :&ensp;<code>str</code></dt>
<dd>The x-axis label to use. Default is <code>Time (UTC)</code>.</dd>
<dt><strong><code>ylabel</code></strong> :&ensp;<code>str</code></dt>
<dd>The y-axis label to use. Default is based on y_type.</dd>
<dt><strong><code>xtick_increment</code></strong> :&ensp;<code>int</code></dt>
<dd>The x-axis tick increment to use. Default is 100.</dd>
<dt><strong><code>ytick_increment</code></strong> :&ensp;<code>int</code></dt>
<dd>The y-axis tick increment to use. Default is 50.</dd>
<dt><strong><code>returnfig</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Instead of displaying the image, return the matplotlib figure object. This allows for further plot
manipulation, for example, adding labels or a title in a different location than the default. </p>
<p>Remember - if this parameter is supplied, be sure that you close your plot after finishing work
with it. This can be achieved by doing <code>plt.close(fig)</code>. </p>
<p>Note that this method cannot be used in combination with <code>savefig</code>.</p>
</dd>
<dt><strong><code>savefig</code></strong> :&ensp;<code>bool</code></dt>
<dd>Save the displayed image to disk instead of displaying it. The parameter savefig_filename is required if
this parameter is set to True. Defaults to <code>False</code>.</dd>
<dt><strong><code>savefig_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename to save the image to. Must be specified if the savefig parameter is set to True.</dd>
<dt><strong><code>savefig_quality</code></strong> :&ensp;<code>int</code></dt>
<dd>Quality level of the saved image. This can be specified if the savefig_filename is a JPG image. If it
is a PNG, quality is ignored. Default quality level for JPGs is matplotlib/Pillow's default of 75%.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The displayed keogram, by default. If <code>savefig</code> is set to True, nothing will be returned. If <code>returnfig</code> is
set to True, the plotting variables <code>(fig, ax)</code> will be returned.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>issues encountered with the y-axis choice</dd>
</dl></div>
</dd>
<dt id="pyaurorax.tools.Keogram.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print(self):
    &#34;&#34;&#34;
    A special print output for this class.
    &#34;&#34;&#34;
    # set special strings
    data_str = &#34;array(dims=%s, dtype=%s)&#34; % (self.data.shape, self.data.dtype)
    timestamp_str = &#34;[%d datetime objects]&#34; % (len(self.timestamp))
    ccd_y_str = &#34;None&#34; if self.ccd_y is None else &#34;array(%d values)&#34; % (self.ccd_y.shape[0])
    mag_y_str = &#34;None&#34; if self.mag_y is None else &#34;array(%d values)&#34; % (self.mag_y.shape[0])
    geo_y_str = &#34;None&#34; if self.geo_y is None else &#34;array(%d values)&#34; % (self.geo_y.shape[0])

    # print
    print(&#34;Keogram:&#34;)
    print(&#34;  %-17s: %s&#34; % (&#34;data&#34;, data_str))
    print(&#34;  %-17s: %s&#34; % (&#34;timestamp&#34;, timestamp_str))
    print(&#34;  %-17s: %s&#34; % (&#34;instrument_type&#34;, self.instrument_type))
    print(&#34;  %-17s: %s&#34; % (&#34;ccd_y&#34;, ccd_y_str))
    print(&#34;  %-17s: %s&#34; % (&#34;geo_y&#34;, geo_y_str))
    print(&#34;  %-17s: %s&#34; % (&#34;mag_y&#34;, mag_y_str))</code></pre>
</details>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
<dt id="pyaurorax.tools.Keogram.set_geographic_latitudes"><code class="name flex">
<span>def <span class="ident">set_geographic_latitudes</span></span>(<span>self,<br>skymap: pyucalgarysrs.data.classes.Skymap,<br>altitude_km: int | float | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_geographic_latitudes(self, skymap: Skymap, altitude_km: Optional[Union[int, float]] = None) -&gt; None:
    &#34;&#34;&#34;
    Set the geographic latitude values for this keogram, using the specified skymap 
    data. The data will be set to the geo_y attribute of this Keogram object, which
    can then be used for plotting and/or further analysis.

    Args:
        skymap (pyaurorax.data.ucalgary.Skymap): 
            The skymap object to use. This parameter is required.

        altitude_km (int): 
            The altitude to use, in kilometers. If not specified, it will use the default in the 
            skymap object. If the specified altitude is not valid, a ValueError will be raised.
    
    Returns:
        None. The Keogram object&#39;s `geo_y` attribute will be updated.

    Raises:
        ValueError: Issues with specified altitude.
    &#34;&#34;&#34;
    # check for slice idx
    if (self.__slice_idx is None):
        raise ValueError(&#34;Unable to set the geographic latitudes since the slice_idx is None. If this keogram &#34; +
                         &#34;object was created as part of the custom_keogram routines or is a spectrogaph keogram, &#34; +
                         &#34;this is expected and performing this action is not supported at this time.&#34;)

    # determine altitude index to use
    if (altitude_km is not None):
        # Obtain lat/lon arrays from skymap
        if (altitude_km * 1000.0 in skymap.full_map_altitude):
            altitude_idx = np.where(altitude_km * 1000.0 == skymap.full_map_altitude)

            self.geo_y = np.squeeze(skymap.full_map_latitude[altitude_idx, :, self.__slice_idx]).copy()
        else:
            # Make sure altitude is in range that can be interpolated
            if (altitude_km * 1000.0 &lt; skymap.full_map_altitude[0]) or (altitude_km * 1000.0 &gt; skymap.full_map_altitude[2]):
                raise ValueError(&#34;Altitude &#34; + str(altitude_km) + &#34; outside valid range of &#34; +
                                 str((skymap.full_map_altitude[0] / 1000.0, skymap.full_map_altitude[2] / 1000.0)))

            # Initialze empty lat/lon arrays
            lats = np.full(np.squeeze(skymap.full_map_latitude[0, :, :]).shape, np.nan, dtype=skymap.full_map_latitude[0, :, :].dtype)

            # Interpolate lats and lons at desired altitude
            for i in range(skymap.full_map_latitude.shape[1]):
                for j in range(skymap.full_map_latitude.shape[2]):
                    lats[i, j] = np.interp(altitude_km * 1000.0, skymap.full_map_altitude, skymap.full_map_latitude[:, i, j])

            self.geo_y = lats[:, self.__slice_idx].copy()
    else:
        # use default middle altitude
        self.geo_y = np.squeeze(skymap.full_map_latitude[1, :, self.__slice_idx]).copy()</code></pre>
</details>
<div class="desc"><p>Set the geographic latitude values for this keogram, using the specified skymap
data. The data will be set to the geo_y attribute of this Keogram object, which
can then be used for plotting and/or further analysis.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>skymap</code></strong> :&ensp;<code><a title="pyaurorax.data.ucalgary.Skymap" href="../data/ucalgary/index.html#pyaurorax.data.ucalgary.Skymap">Skymap</a></code></dt>
<dd>The skymap object to use. This parameter is required.</dd>
<dt><strong><code>altitude_km</code></strong> :&ensp;<code>int</code></dt>
<dd>The altitude to use, in kilometers. If not specified, it will use the default in the
skymap object. If the specified altitude is not valid, a ValueError will be raised.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None. The Keogram object's <code>geo_y</code> attribute will be updated.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Issues with specified altitude.</dd>
</dl></div>
</dd>
<dt id="pyaurorax.tools.Keogram.set_magnetic_latitudes"><code class="name flex">
<span>def <span class="ident">set_magnetic_latitudes</span></span>(<span>self,<br>skymap: pyucalgarysrs.data.classes.Skymap,<br>timestamp: datetime.datetime,<br>altitude_km: int | float | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_magnetic_latitudes(self, skymap: Skymap, timestamp: datetime.datetime, altitude_km: Optional[Union[int, float]] = None) -&gt; None:
    &#34;&#34;&#34;
    Set the magnetic latitude values for this keogram, using the specified skymap 
    data. AACGMv2 will be utilized to perform the calculations. The resulting data
    will be set to the mag_y attribute of this Keogram object, which can then be
    used for plotting and/or further analysis.

    Args:
        skymap (pyaurorax.data.ucalgary.Skymap): 
            The skymap object to use. This parameter is required.

        timestamp (datetime.datetime): 
            The timestamp to use when converting skymap data to magnetic coordinates. Utilizes
            AACGMv2 to do the conversion.

        altitude_km (int): 
            The altitude to use. If not specified, it will use the default in the skymap
            object. If the specified altitude is not valid, a ValueError will be raised.
    
    Returns:
        None. The Keogram object&#39;s `mag_y` attribute will be updated.

    Raises:
        ValueError: Issues with specified altitude.
    &#34;&#34;&#34;
    # check for slice idx
    if (self.__slice_idx is None):
        raise ValueError(&#34;Unable to set the geographic latitudes since the slice_idx is None. If this keogram &#34; +
                         &#34;object was created as part of the custom_keogram routines or is a spectrogaph keogram, &#34; +
                         &#34;this is expected and performing this action is not supported at this time.&#34;)

    # determine altitude index to use
    if (altitude_km is not None):
        # Obtain lat/lon arrays from skymap
        if (altitude_km * 1000.0 in skymap.full_map_altitude):
            altitude_idx = np.where(altitude_km * 1000.0 == skymap.full_map_altitude)

            lats = np.squeeze(skymap.full_map_latitude[altitude_idx, :, :])
            lons = np.squeeze(skymap.full_map_longitude[altitude_idx, :, :])
            lons[np.where(lons &gt; 180)] -= 360.0

        else:
            # Make sure altitude is in range that can be interpolated
            if (altitude_km * 1000.0 &lt; skymap.full_map_altitude[0]) or (altitude_km * 1000.0 &gt; skymap.full_map_altitude[2]):
                raise ValueError(&#34;Altitude &#34; + str(altitude_km) + &#34; outside valid range of &#34; +
                                 str((skymap.full_map_altitude[0] / 1000.0, skymap.full_map_altitude[2] / 1000.0)))

            # Initialze empty lat/lon arrays
            lats = np.full(np.squeeze(skymap.full_map_latitude[0, :, :]).shape, np.nan, dtype=skymap.full_map_latitude[0, :, :].dtype)
            lons = lats.copy()

            # Interpolate lats and lons at desired altitude
            for i in range(skymap.full_map_latitude.shape[1]):
                for j in range(skymap.full_map_latitude.shape[2]):
                    lats[i, j] = np.interp(altitude_km * 1000.0, skymap.full_map_altitude, skymap.full_map_latitude[:, i, j])
                    lons[i, j] = np.interp(altitude_km * 1000.0, skymap.full_map_altitude, skymap.full_map_longitude[:, i, j])

            lons[np.where(lons &gt; 180)] -= 360.0

        # Convert lats and lons to geomagnetic coordinates
        mag_lats, mag_lons, mag_alts = aacgmv2.convert_latlon_arr(lats.flatten(),
                                                                  lons.flatten(), (lons * 0.0).flatten(),
                                                                  timestamp,
                                                                  method_code=&#39;G2A&#39;)
        mag_lats = np.reshape(mag_lats, lats.shape)
        mag_lons = np.reshape(mag_lons, lons.shape)

        # Set the y axis to the desired slice index of the magnetic latitudes
        self.mag_y = mag_lats[:, self.__slice_idx].copy()
    else:
        # Convert middle altitude lats and lons to geomagnetic coordinates
        mag_lats, mag_lons, mag_alts = aacgmv2.convert_latlon_arr(np.squeeze(skymap.full_map_latitude[1, :, :]).flatten(),
                                                                  np.squeeze(skymap.full_map_longitude[1, :, :]).flatten(),
                                                                  (skymap.full_map_longitude[1, :, :] * 0.0).flatten(),
                                                                  timestamp,
                                                                  method_code=&#39;G2A&#39;)
        mag_lats = np.reshape(mag_lats, np.squeeze(skymap.full_map_latitude[1, :, :]).shape)
        mag_lons = np.reshape(mag_lons, np.squeeze(skymap.full_map_longitude[1, :, :]).shape)

        # Set the y axis to the desired slice index of the magnetic latitudes
        self.mag_y = mag_lats[:, self.__slice_idx].copy()</code></pre>
</details>
<div class="desc"><p>Set the magnetic latitude values for this keogram, using the specified skymap
data. AACGMv2 will be utilized to perform the calculations. The resulting data
will be set to the mag_y attribute of this Keogram object, which can then be
used for plotting and/or further analysis.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>skymap</code></strong> :&ensp;<code><a title="pyaurorax.data.ucalgary.Skymap" href="../data/ucalgary/index.html#pyaurorax.data.ucalgary.Skymap">Skymap</a></code></dt>
<dd>The skymap object to use. This parameter is required.</dd>
<dt><strong><code>timestamp</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>The timestamp to use when converting skymap data to magnetic coordinates. Utilizes
AACGMv2 to do the conversion.</dd>
<dt><strong><code>altitude_km</code></strong> :&ensp;<code>int</code></dt>
<dd>The altitude to use. If not specified, it will use the default in the skymap
object. If the specified altitude is not valid, a ValueError will be raised.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None. The Keogram object's <code>mag_y</code> attribute will be updated.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Issues with specified altitude.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.tools.Montage"><code class="flex name class">
<span>class <span class="ident">Montage</span></span>
<span>(</span><span>data: numpy.ndarray, timestamp: List[datetime.datetime], n_channels: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Montage:
    &#34;&#34;&#34;
    Class representation for a montage

    Attributes:
        data (numpy.ndarray): 
            The derived montage data.

        timestamp (List[datetime.datetime]): 
            Timestamps corresponding to each montage image.
    &#34;&#34;&#34;

    def __init__(self, data: np.ndarray, timestamp: List[datetime.datetime], n_channels: int):
        # public vars
        self.data = data
        self.timestamp = timestamp

        # private vars
        self.__n_channels = n_channels

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        data_str = &#34;array(dims=%s, dtype=%s)&#34; % (self.data.shape, self.data.dtype)
        timestamp_str = &#34;[%d datetime objects]&#34; % (len(self.timestamp))

        return &#34;Montage(data=%s, timestamp=%s)&#34; % (data_str, timestamp_str)

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;
        # set special strings
        data_str = &#34;array(dims=%s, dtype=%s)&#34; % (self.data.shape, self.data.dtype)
        timestamp_str = &#34;[%d datetime objects]&#34; % (len(self.timestamp))

        # print
        print(&#34;Montage:&#34;)
        print(&#34;  %-11s: %s&#34; % (&#34;data&#34;, data_str))
        print(&#34;  %-11s: %s&#34; % (&#34;timestamp&#34;, timestamp_str))

    def plot(self,
             rows: int,
             cols: int,
             timestamps_display: bool = True,
             timestamps_format: str = &#34;%Y-%m-%d %H:%M:%S&#34;,
             timestamps_fontsize: int = 11,
             figsize: Optional[Tuple[int, int]] = None,
             title: Optional[str] = None,
             cmap: Optional[str] = None,
             returnfig: bool = False,
             savefig: bool = False,
             savefig_filename: Optional[str] = None,
             savefig_quality: Optional[int] = None) -&gt; Any:
        &#34;&#34;&#34;
        Generate a plot of the montage data. 
        
        Either display it (default behaviour), save it to disk (using the `savefig` parameter), or 
        return the matplotlib plot object for further usage (using the `returnfig` parameter).

        Args:
            rows (int): 
                The number of rows to use when displaying the images as a montage. The product of 
                the `rows` and `cols` parameters must match the number of images supplied when creating 
                the `Montage` object. If not, a ValueError will be raised. This parameter is required.

            cols (int): 
                The number of columns to use when displaying the images as a montage. The product of 
                the `rows` and `cols` parameters must match the number of images supplied when creating 
                the `Montage` object. If not, a ValueError will be raised. This parameter is required.

            timestamps_display (bool): 
                Display the timestamps on each montage image. Defaults to True. This parameter is
                optional.

            timestamps_format (str): 
                The format of the timestamps when being displayed. This is the same format string
                as when using the `strftime()` function for a `datetime` object. Default format 
                string is `%Y-%m-%d %H:%M:%S`. Refer to the 
                [Python documentation](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes)
                for further information. This parameter is optional.
            
            timestamps_fontsize (int): 
                The font size for the displayed timestamps. Default is size 11. This parameter is 
                optional.

            figsize (tuple): 
                The matplotlib figure size to use when plotting. For example `figsize=(14,4)`.

            title (str): 
                The title to display above the plotted montage. Default is no title.

            cmap (str): 
                The matplotlib colormap to use.

                Commonly used colormaps are:

                - REGO: `gist_heat`
                - THEMIS ASI: `gray`
                - TREx Blue: `Blues_r`
                - TREx NIR: `gray`
                - TREx RGB: `None`

                A list of all available colormaps can be found on the 
                [matplotlib documentation](https://matplotlib.org/stable/gallery/color/colormap_reference.html).
            
            returnfig (bool): 
                Instead of displaying the image, return the matplotlib figure object. This allows for further plot 
                manipulation, for example, adding labels or a title in a different location than the default. 
                
                Remember - if this parameter is supplied, be sure that you close your plot after finishing work 
                with it. This can be achieved by doing `plt.close(fig)`. 
                
                Note that this method cannot be used in combination with `savefig`.

            savefig (bool): 
                Save the displayed image to disk instead of displaying it. The parameter savefig_filename is required if 
                this parameter is set to True. Defaults to `False`.

            savefig_filename (str): 
                Filename to save the image to. Must be specified if the savefig parameter is set to True.

            savefig_quality (int): 
                Quality level of the saved image. This can be specified if the savefig_filename is a JPG image. If it
                is a PNG, quality is ignored. Default quality level for JPGs is matplotlib/Pillow&#39;s default of 75%.

        Returns:
            The displayed montage, by default. If `savefig` is set to True, nothing will be returned. If `returnfig` is 
            set to True, the plotting variables `(fig, ax)` will be returned.

        Raises:
            ValueError: issues with the y-axis choice, or rows/cols choice.
        &#34;&#34;&#34;
        # check rows and cols
        if (rows * cols != self.data.shape[-1]):
            raise ValueError((&#34;Invalid choice of rows and columns. The %d images in this Montage object &#34; +
                              &#34;cannot be organized into a %dx%d grid (%d * %d != %d)&#34;) % (
                                  self.data.shape[-1],
                                  rows,
                                  cols,
                                  rows,
                                  cols,
                                  self.data.shape[-1],
                              ))

        # check return mode
        if (returnfig is True and savefig is True):
            raise ValueError(&#34;Only one of returnfig or savefig can be set to True&#34;)
        if (returnfig is True and (savefig_filename is not None or savefig_quality is not None)):
            show_warning(&#34;The figure will be returned, but a savefig option parameter was supplied. Consider &#34; +
                         &#34;removing the savefig option parameter(s) as they will be ignored.&#34;,
                         stacklevel=1)
        elif (savefig is False and (savefig_filename is not None or savefig_quality is not None)):
            show_warning(&#34;A savefig option parameter was supplied, but the savefig parameter is False. The &#34; +
                         &#34;savefig option parameters will be ignored.&#34;,
                         stacklevel=1)

        # init figure
        fig, axs = plt.subplots(nrows=rows, ncols=cols, figsize=figsize)

        # set title
        if (title is not None):
            fig.suptitle(title)

        # for each image
        for ax, i in zip(axs.flat, range(0, len(self.timestamp))):  # type: ignore
            if (self.__n_channels == 1):
                # single channel
                ax.imshow(self.data[:, :, i], cmap=cmap, origin=&#34;lower&#34;, interpolation=&#34;nearest&#34;)
            elif (self.__n_channels == 3):
                # single channel
                ax.imshow(self.data[:, :, :, i], cmap=cmap, origin=&#34;lower&#34;, interpolation=&#34;nearest&#34;)
            else:
                raise ValueError(&#34;Can only plot 3 or 4 dimensional data (series of single-channel or RGB mages), but found data of shape %s&#34; %
                                 (self.data.shape))

            ax.set_axis_off()

            # show timestamp
            if (timestamps_display is True):
                ax.text(
                    int(np.floor(self.data.shape[1] / 2.)),
                    5,
                    self.timestamp[i].strftime(timestamps_format),
                    ha=&#34;center&#34;,
                    fontsize=timestamps_fontsize,
                )
        plt.tight_layout(h_pad=0, w_pad=0)

        # save figure or show it
        if (savefig is True):
            # check that filename has been set
            if (savefig_filename is None):
                raise ValueError(&#34;The savefig_filename parameter is missing, but required since savefig was set to True.&#34;)

            # save the figure
            f_extension = os.path.splitext(savefig_filename)[-1].lower()
            if (&#34;.jpg&#34; == f_extension or &#34;.jpeg&#34; == f_extension):
                # check quality setting
                if (savefig_quality is not None):
                    plt.savefig(savefig_filename, quality=savefig_quality, bbox_inches=&#34;tight&#34;)
                else:
                    plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)
            else:
                if (savefig_quality is not None):
                    # quality specified, but output filename is not a JPG, so show a warning
                    show_warning(&#34;The savefig_quality parameter was specified, but is only used for saving JPG files. The &#34; +
                                 &#34;savefig_filename parameter was determined to not be a JPG file, so the quality will be ignored&#34;,
                                 stacklevel=1)
                plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)

            # clean up by closing the figure
            plt.close(fig)
        elif (returnfig is True):
            # return the figure and axis objects
            return (fig, axs)
        else:
            # show the figure
            plt.show(fig)

            # cleanup by closing the figure
            plt.close(fig)

        # return
        return None</code></pre>
</details>
<div class="desc"><p>Class representation for a montage</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>The derived montage data.</dd>
<dt><strong><code>timestamp</code></strong> :&ensp;<code>List[datetime.datetime]</code></dt>
<dd>Timestamps corresponding to each montage image.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.tools.Montage.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self,<br>rows: int,<br>cols: int,<br>timestamps_display: bool = True,<br>timestamps_format: str = '%Y-%m-%d %H:%M:%S',<br>timestamps_fontsize: int = 11,<br>figsize: Tuple[int, int] | None = None,<br>title: str | None = None,<br>cmap: str | None = None,<br>returnfig: bool = False,<br>savefig: bool = False,<br>savefig_filename: str | None = None,<br>savefig_quality: int | None = None) ‑> Any</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         rows: int,
         cols: int,
         timestamps_display: bool = True,
         timestamps_format: str = &#34;%Y-%m-%d %H:%M:%S&#34;,
         timestamps_fontsize: int = 11,
         figsize: Optional[Tuple[int, int]] = None,
         title: Optional[str] = None,
         cmap: Optional[str] = None,
         returnfig: bool = False,
         savefig: bool = False,
         savefig_filename: Optional[str] = None,
         savefig_quality: Optional[int] = None) -&gt; Any:
    &#34;&#34;&#34;
    Generate a plot of the montage data. 
    
    Either display it (default behaviour), save it to disk (using the `savefig` parameter), or 
    return the matplotlib plot object for further usage (using the `returnfig` parameter).

    Args:
        rows (int): 
            The number of rows to use when displaying the images as a montage. The product of 
            the `rows` and `cols` parameters must match the number of images supplied when creating 
            the `Montage` object. If not, a ValueError will be raised. This parameter is required.

        cols (int): 
            The number of columns to use when displaying the images as a montage. The product of 
            the `rows` and `cols` parameters must match the number of images supplied when creating 
            the `Montage` object. If not, a ValueError will be raised. This parameter is required.

        timestamps_display (bool): 
            Display the timestamps on each montage image. Defaults to True. This parameter is
            optional.

        timestamps_format (str): 
            The format of the timestamps when being displayed. This is the same format string
            as when using the `strftime()` function for a `datetime` object. Default format 
            string is `%Y-%m-%d %H:%M:%S`. Refer to the 
            [Python documentation](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes)
            for further information. This parameter is optional.
        
        timestamps_fontsize (int): 
            The font size for the displayed timestamps. Default is size 11. This parameter is 
            optional.

        figsize (tuple): 
            The matplotlib figure size to use when plotting. For example `figsize=(14,4)`.

        title (str): 
            The title to display above the plotted montage. Default is no title.

        cmap (str): 
            The matplotlib colormap to use.

            Commonly used colormaps are:

            - REGO: `gist_heat`
            - THEMIS ASI: `gray`
            - TREx Blue: `Blues_r`
            - TREx NIR: `gray`
            - TREx RGB: `None`

            A list of all available colormaps can be found on the 
            [matplotlib documentation](https://matplotlib.org/stable/gallery/color/colormap_reference.html).
        
        returnfig (bool): 
            Instead of displaying the image, return the matplotlib figure object. This allows for further plot 
            manipulation, for example, adding labels or a title in a different location than the default. 
            
            Remember - if this parameter is supplied, be sure that you close your plot after finishing work 
            with it. This can be achieved by doing `plt.close(fig)`. 
            
            Note that this method cannot be used in combination with `savefig`.

        savefig (bool): 
            Save the displayed image to disk instead of displaying it. The parameter savefig_filename is required if 
            this parameter is set to True. Defaults to `False`.

        savefig_filename (str): 
            Filename to save the image to. Must be specified if the savefig parameter is set to True.

        savefig_quality (int): 
            Quality level of the saved image. This can be specified if the savefig_filename is a JPG image. If it
            is a PNG, quality is ignored. Default quality level for JPGs is matplotlib/Pillow&#39;s default of 75%.

    Returns:
        The displayed montage, by default. If `savefig` is set to True, nothing will be returned. If `returnfig` is 
        set to True, the plotting variables `(fig, ax)` will be returned.

    Raises:
        ValueError: issues with the y-axis choice, or rows/cols choice.
    &#34;&#34;&#34;
    # check rows and cols
    if (rows * cols != self.data.shape[-1]):
        raise ValueError((&#34;Invalid choice of rows and columns. The %d images in this Montage object &#34; +
                          &#34;cannot be organized into a %dx%d grid (%d * %d != %d)&#34;) % (
                              self.data.shape[-1],
                              rows,
                              cols,
                              rows,
                              cols,
                              self.data.shape[-1],
                          ))

    # check return mode
    if (returnfig is True and savefig is True):
        raise ValueError(&#34;Only one of returnfig or savefig can be set to True&#34;)
    if (returnfig is True and (savefig_filename is not None or savefig_quality is not None)):
        show_warning(&#34;The figure will be returned, but a savefig option parameter was supplied. Consider &#34; +
                     &#34;removing the savefig option parameter(s) as they will be ignored.&#34;,
                     stacklevel=1)
    elif (savefig is False and (savefig_filename is not None or savefig_quality is not None)):
        show_warning(&#34;A savefig option parameter was supplied, but the savefig parameter is False. The &#34; +
                     &#34;savefig option parameters will be ignored.&#34;,
                     stacklevel=1)

    # init figure
    fig, axs = plt.subplots(nrows=rows, ncols=cols, figsize=figsize)

    # set title
    if (title is not None):
        fig.suptitle(title)

    # for each image
    for ax, i in zip(axs.flat, range(0, len(self.timestamp))):  # type: ignore
        if (self.__n_channels == 1):
            # single channel
            ax.imshow(self.data[:, :, i], cmap=cmap, origin=&#34;lower&#34;, interpolation=&#34;nearest&#34;)
        elif (self.__n_channels == 3):
            # single channel
            ax.imshow(self.data[:, :, :, i], cmap=cmap, origin=&#34;lower&#34;, interpolation=&#34;nearest&#34;)
        else:
            raise ValueError(&#34;Can only plot 3 or 4 dimensional data (series of single-channel or RGB mages), but found data of shape %s&#34; %
                             (self.data.shape))

        ax.set_axis_off()

        # show timestamp
        if (timestamps_display is True):
            ax.text(
                int(np.floor(self.data.shape[1] / 2.)),
                5,
                self.timestamp[i].strftime(timestamps_format),
                ha=&#34;center&#34;,
                fontsize=timestamps_fontsize,
            )
    plt.tight_layout(h_pad=0, w_pad=0)

    # save figure or show it
    if (savefig is True):
        # check that filename has been set
        if (savefig_filename is None):
            raise ValueError(&#34;The savefig_filename parameter is missing, but required since savefig was set to True.&#34;)

        # save the figure
        f_extension = os.path.splitext(savefig_filename)[-1].lower()
        if (&#34;.jpg&#34; == f_extension or &#34;.jpeg&#34; == f_extension):
            # check quality setting
            if (savefig_quality is not None):
                plt.savefig(savefig_filename, quality=savefig_quality, bbox_inches=&#34;tight&#34;)
            else:
                plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)
        else:
            if (savefig_quality is not None):
                # quality specified, but output filename is not a JPG, so show a warning
                show_warning(&#34;The savefig_quality parameter was specified, but is only used for saving JPG files. The &#34; +
                             &#34;savefig_filename parameter was determined to not be a JPG file, so the quality will be ignored&#34;,
                             stacklevel=1)
            plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)

        # clean up by closing the figure
        plt.close(fig)
    elif (returnfig is True):
        # return the figure and axis objects
        return (fig, axs)
    else:
        # show the figure
        plt.show(fig)

        # cleanup by closing the figure
        plt.close(fig)

    # return
    return None</code></pre>
</details>
<div class="desc"><p>Generate a plot of the montage data. </p>
<p>Either display it (default behaviour), save it to disk (using the <code>savefig</code> parameter), or
return the matplotlib plot object for further usage (using the <code>returnfig</code> parameter).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rows</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of rows to use when displaying the images as a montage. The product of
the <code>rows</code> and <code>cols</code> parameters must match the number of images supplied when creating
the <code><a title="pyaurorax.tools.Montage" href="#pyaurorax.tools.Montage">Montage</a></code> object. If not, a ValueError will be raised. This parameter is required.</dd>
<dt><strong><code>cols</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of columns to use when displaying the images as a montage. The product of
the <code>rows</code> and <code>cols</code> parameters must match the number of images supplied when creating
the <code><a title="pyaurorax.tools.Montage" href="#pyaurorax.tools.Montage">Montage</a></code> object. If not, a ValueError will be raised. This parameter is required.</dd>
<dt><strong><code>timestamps_display</code></strong> :&ensp;<code>bool</code></dt>
<dd>Display the timestamps on each montage image. Defaults to True. This parameter is
optional.</dd>
<dt><strong><code>timestamps_format</code></strong> :&ensp;<code>str</code></dt>
<dd>The format of the timestamps when being displayed. This is the same format string
as when using the <code>strftime()</code> function for a <code>datetime</code> object. Default format
string is <code>%Y-%m-%d %H:%M:%S</code>. Refer to the
<a href="https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes">Python documentation</a>
for further information. This parameter is optional.</dd>
<dt><strong><code>timestamps_fontsize</code></strong> :&ensp;<code>int</code></dt>
<dd>The font size for the displayed timestamps. Default is size 11. This parameter is
optional.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The matplotlib figure size to use when plotting. For example <code>figsize=(14,4)</code>.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>The title to display above the plotted montage. Default is no title.</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>The matplotlib colormap to use.</p>
<p>Commonly used colormaps are:</p>
<ul>
<li>REGO: <code>gist_heat</code></li>
<li>THEMIS ASI: <code>gray</code></li>
<li>TREx Blue: <code>Blues_r</code></li>
<li>TREx NIR: <code>gray</code></li>
<li>TREx RGB: <code>None</code></li>
</ul>
<p>A list of all available colormaps can be found on the
<a href="https://matplotlib.org/stable/gallery/color/colormap_reference.html">matplotlib documentation</a>.</p>
</dd>
<dt><strong><code>returnfig</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Instead of displaying the image, return the matplotlib figure object. This allows for further plot
manipulation, for example, adding labels or a title in a different location than the default. </p>
<p>Remember - if this parameter is supplied, be sure that you close your plot after finishing work
with it. This can be achieved by doing <code>plt.close(fig)</code>. </p>
<p>Note that this method cannot be used in combination with <code>savefig</code>.</p>
</dd>
<dt><strong><code>savefig</code></strong> :&ensp;<code>bool</code></dt>
<dd>Save the displayed image to disk instead of displaying it. The parameter savefig_filename is required if
this parameter is set to True. Defaults to <code>False</code>.</dd>
<dt><strong><code>savefig_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename to save the image to. Must be specified if the savefig parameter is set to True.</dd>
<dt><strong><code>savefig_quality</code></strong> :&ensp;<code>int</code></dt>
<dd>Quality level of the saved image. This can be specified if the savefig_filename is a JPG image. If it
is a PNG, quality is ignored. Default quality level for JPGs is matplotlib/Pillow's default of 75%.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The displayed montage, by default. If <code>savefig</code> is set to True, nothing will be returned. If <code>returnfig</code> is
set to True, the plotting variables <code>(fig, ax)</code> will be returned.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>issues with the y-axis choice, or rows/cols choice.</dd>
</dl></div>
</dd>
<dt id="pyaurorax.tools.Montage.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print(self):
    &#34;&#34;&#34;
    A special print output for this class.
    &#34;&#34;&#34;
    # set special strings
    data_str = &#34;array(dims=%s, dtype=%s)&#34; % (self.data.shape, self.data.dtype)
    timestamp_str = &#34;[%d datetime objects]&#34; % (len(self.timestamp))

    # print
    print(&#34;Montage:&#34;)
    print(&#34;  %-11s: %s&#34; % (&#34;data&#34;, data_str))
    print(&#34;  %-11s: %s&#34; % (&#34;timestamp&#34;, timestamp_str))</code></pre>
</details>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.tools.Mosaic"><code class="flex name class">
<span>class <span class="ident">Mosaic</span></span>
<span>(</span><span>polygon_data: matplotlib.collections.PolyCollection | List[matplotlib.collections.PolyCollection],<br>cartopy_projection: cartopy.crs.Projection,<br>contour_data: Dict[str, List[Any]] | None = None,<br>spect_cmap: str | None = None,<br>spect_intensity_scale: Tuple[int, int] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Mosaic:
    &#34;&#34;&#34;
    Class representation for a generated mosaic.

    Attributes:
        polygon_data (matplotlib.collections.PolyCollection): 
            Generated polygons containing rendered data.

        cartopy_projection (cartopy.crs.Projection): 
            Cartopy projection to utilize.

        contour_data (Dict[str, List[Any]]): 
            Generated contour data.

        spect_cmap (str): 
            String giving the cmap to use for spect legend.
            
        spect_intensity_scale (Tuple[int]): 
            The min and max values that spectrograph data
            is scaled to in the mosaic, if any is present.
    &#34;&#34;&#34;
    polygon_data: Union[PolyCollection, List[PolyCollection]]
    cartopy_projection: Projection
    contour_data: Optional[Dict[str, List[Any]]] = None
    spect_cmap: Optional[str] = None
    spect_intensity_scale: Optional[Tuple[int, int]] = None

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        if isinstance(self.polygon_data, list):
            polycollection_str = &#34;[PolyCollection(...), ...]&#34;
        else:
            polycollection_str = &#34;PolyCollection(...)&#34;

        if self.contour_data is not None:
            return &#34;Mosaic(polygon_data=PolyCollection(...), cartopy_projection=Projection(%s), %d Contours)&#34; % (
                self.cartopy_projection.to_string(),
                len(self.contour_data.get(&#34;x&#34;, [])),
            )
        else:
            return &#34;Mosaic(polygon_data=&#34; + polycollection_str + &#34;, cartopy_projection=Projection(%s))&#34; % (self.cartopy_projection.to_string())

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;
        # set special strings
        if isinstance(self.polygon_data, list):
            polycollection_str = &#34;[PolyCollection(...), ...]&#34;
        else:
            polycollection_str = &#34;PolyCollection(...)&#34;
        cartopy_projection_str = &#34;Projection(%s)&#34; % (self.cartopy_projection.to_string())
        if self.contour_data is not None:
            contour_data_str = &#34;%d Contours&#34; % (len(self.contour_data.get(&#34;x&#34;, [])), )
        else:
            contour_data_str = &#34;None&#34;

        # print
        print(&#34;Mosaic:&#34;)
        print(&#34;  %-23s: %s&#34; % (&#34;polygon_data&#34;, polycollection_str))
        print(&#34;  %-23s: %s&#34; % (&#34;cartopy_projection&#34;, cartopy_projection_str))
        print(&#34;  %-23s: %s&#34; % (&#34;contour_data&#34;, contour_data_str))
        print(&#34;  %-23s: %s&#34; % (&#34;spect_cmap&#34;, self.spect_cmap))
        print(&#34;  %-23s: %s&#34; % (&#34;spect_intensity_scale&#34;, self.spect_intensity_scale))

    def plot(
            self,
            map_extent: Sequence[Union[float, int]],
            figsize: Optional[Tuple[int, int]] = None,
            rayleighs: bool = False,
            max_rayleighs: int = 20000,
            title: Optional[str] = None,
            ocean_color: Optional[str] = None,
            land_color: str = &#34;gray&#34;,
            land_edgecolor: str = &#34;#8A8A8A&#34;,
            borders_color: str = &#34;#AEAEAE&#34;,
            borders_disable: bool = False,
            colorbar_title: Optional[str] = None,  # deprecated in v1.11.0, use cbar_title instead
            cbar_title: Optional[str] = None,
            cbar_colormap: str = &#34;&#34;,
            returnfig: bool = False,
            savefig: bool = False,
            savefig_filename: Optional[str] = None,
            savefig_quality: Optional[int] = None) -&gt; Any:
        &#34;&#34;&#34;
        Generate a plot of the mosaic data. 
        
        Either display it (default behaviour), save it to disk (using the `savefig` parameter), or 
        return the matplotlib plot object for further usage (using the `returnfig` parameter).

        Args:
            map_extent (List[int]): 
                Latitude/longitude range to be visible on the rendered map. This is a list of 4 integers 
                and/or floats, in the order of [min_lon, max_lon, min_lat, max_lat].

            figsize (tuple): 
                The matplotlib figure size to use when plotting. For example `figsize=(14,4)`.

            rayleighs (bool): 
                Set to `True` if the data being plotted is in Rayleighs. Defaults to `False`.

            max_rayleighs (int): 
                Max intensity scale for Rayleighs. Defaults to `20000`.

            title (str): 
                The title to display above the plotted mosaic. Default is no title.

            ocean_color (str): 
                Colour of the ocean. Default is cartopy&#39;s default shade of blue. Colours can be supplied
                as a word, or hexcode prefixed with a &#39;#&#39; character (ie. `#55AADD`).
            
            land_color (str): 
                Colour of the land. Default is `gray`. Colours can be supplied as a word, or hexcode 
                prefixed with a &#39;#&#39; character (ie. `#41BB87`).

            land_edgecolor (str): 
                Color of the land edges. Default is `#8A8A8A`. Colours can be supplied as a word, or
                hexcode prefixed with a &#39;#&#39; character.

            borders_color (str): 
                Color of the country borders. Default is `AEAEAE`. Colours can be supplied as a word, or
                hexcode prefixed with a &#39;#&#39; character.
            
            borders_disable (bool): 
                Disbale rendering of the borders. Default is `False`.

            cbar_title (str): 
                Title for the colorbar. Default is no title.

            colorbar_title (str): 
                Deprecated as of v1.10.0. Use &#39;cbar_title&#39; instead in the exact same way.

            cbar_colormap (str): 
                The matplotlib colormap to use for the plotted color bar. Default is `gray`, unless
                mosaic was created with spectrograph data, in which case defaults to the colormap
                used for spectrograph data..

                Commonly used colormaps are:

                - REGO: `gist_heat`
                - THEMIS ASI: `gray`
                - TREx Blue: `Blues_r`
                - TREx NIR: `gray`
                - TREx RGB: `None`

                A list of all available colormaps can be found on the 
                [matplotlib documentation](https://matplotlib.org/stable/gallery/color/colormap_reference.html).

            returnfig (bool): 
                Instead of displaying the image, return the matplotlib figure object. This allows for further plot 
                manipulation, for example, adding labels or a title in a different location than the default. 
                
                Remember - if this parameter is supplied, be sure that you close your plot after finishing work 
                with it. This can be achieved by doing `plt.close(fig)`. 
                
                Note that this method cannot be used in combination with `savefig`.

            savefig (bool): 
                Save the displayed image to disk instead of displaying it. The parameter savefig_filename is required if 
                this parameter is set to True. Defaults to `False`.

            savefig_filename (str): 
                Filename to save the image to. Must be specified if the savefig parameter is set to True.

            savefig_quality (int): 
                Quality level of the saved image. This can be specified if the savefig_filename is a JPG image. If it
                is a PNG, quality is ignored. Default quality level for JPGs is matplotlib/Pillow&#39;s default of 75%.

        Returns:
            The displayed montage, by default. If `savefig` is set to True, nothing will be returned. If `returnfig` is 
            set to True, the plotting variables `(fig, ax)` will be returned.

        Raises:
        &#34;&#34;&#34;
        # handle deprecation warnings
        if (colorbar_title is not None):
            show_warning(&#34;The parameter &#39;colorbar_title&#39; was deprecated in v1.11.0. Please use &#39;cbar_title&#39; instead (usage is identical).&#34;,
                         stacklevel=1)
            cbar_title = colorbar_title

        # check return mode
        if (returnfig is True and savefig is True):
            raise ValueError(&#34;Only one of returnfig or savefig can be set to True&#34;)
        if returnfig is True and (savefig_filename is not None or savefig_quality is not None):
            show_warning(&#34;The figure will be returned, but a savefig option parameter was supplied. Consider &#34; +
                         &#34;removing the savefig option parameter(s) as they will be ignored.&#34;,
                         stacklevel=1)
        elif (savefig is False and (savefig_filename is not None or savefig_quality is not None)):
            show_warning(&#34;A savefig option parameter was supplied, but the savefig parameter is False. The &#34; +
                         &#34;savefig option parameters will be ignored.&#34;,
                         stacklevel=1)

        # get colormap if there is spectrograph data
        if self.spect_cmap is not None:
            cbar_colormap = self.spect_cmap

        # initialize figure
        fig = plt.figure(figsize=figsize)
        ax = fig.add_axes((0, 0, 1, 1), projection=self.cartopy_projection)
        ax.set_extent(map_extent, crs=cartopy.crs.Geodetic())  # type: ignore

        # add ocean
        #
        # NOTE: we use the default ocean color
        if (ocean_color is not None):
            ax.add_feature(  # type: ignore
                cartopy.feature.OCEAN, facecolor=ocean_color, zorder=0)
        else:
            ax.add_feature(cartopy.feature.OCEAN, zorder=0)  # type: ignore

        # add land
        ax.add_feature(  # type: ignore
            cartopy.feature.LAND, facecolor=land_color, edgecolor=land_edgecolor, zorder=0)

        # add borders
        if (borders_disable is False):
            ax.add_feature(  # type: ignore
                cartopy.feature.BORDERS, edgecolor=borders_color, zorder=0)

        # add polygon data
        #
        # NOTE: it seems that when running this function a second time, the polygon
        # data is not too happy. So to handle this, we plot a copy of the polygon data
        if isinstance(self.polygon_data, list):
            for polygon_data in self.polygon_data:
                ax.add_collection(copy(polygon_data))
        else:
            ax.add_collection(copy(self.polygon_data))

        if self.contour_data is not None:
            for i in range(len(self.contour_data[&#34;x&#34;])):
                ax.plot(self.contour_data[&#34;x&#34;][i],
                        self.contour_data[&#34;y&#34;][i],
                        color=self.contour_data[&#34;color&#34;][i],
                        linewidth=self.contour_data[&#34;linewidth&#34;][i],
                        linestyle=self.contour_data[&#34;linestyle&#34;][i],
                        marker=self.contour_data[&#34;marker&#34;][i],
                        zorder=self.contour_data[&#34;zorder&#34;][i])

        # set title
        if (title is not None):
            ax.set_title(title)

        # add text
        if (rayleighs is True):
            if isinstance(self.polygon_data, list):
                raise ValueError(&#34;Rayleighs Keyword is currently not available for mosaics with multiple sets of data.&#34;)

            # Create a colorbar, in Rayleighs, that accounts for the scaling limit we applied
            cbar_ticks = [float(j) / 5. for j in range(0, 6)]
            cbar_ticknames = [str(int(max_rayleighs / 5) * j) for j in range(0, 6)]

            # Any pixels with the max Rayleigh value could be greater than it, so we include the plus sign
            cbar_ticknames[-1] += &#34;+&#34;
            self.polygon_data.set_cmap(cbar_colormap)
            cbar = plt.colorbar(self.polygon_data, shrink=0.5, ticks=cbar_ticks, ax=ax)
            cbar.ax.set_yticklabels(cbar_ticknames)
            plt.text(1.025,
                     0.5,
                     &#34;Intensity (Rayleighs)&#34;,
                     fontsize=14,
                     transform=ax.transAxes,
                     va=&#34;center&#34;,
                     rotation=&#34;vertical&#34;,
                     weight=&#34;bold&#34;,
                     style=&#34;oblique&#34;)

        if (self.spect_cmap) is not None:

            if (self.spect_intensity_scale) is None:
                intensity_max = np.nan
                intensity_min = np.nan
            else:
                intensity_max = self.spect_intensity_scale[1]
                intensity_min = self.spect_intensity_scale[0]

            # Create a colorbar, in Rayleighs, that accounts for the scaling limit we applied
            cbar_ticks = [float(j) / 5. for j in range(0, 6)]
            cbar_ticknames = [str(int((intensity_max / 5) + intensity_min) * j) for j in range(0, 6)]

            # Any specrograph bins with the max intensity value could be greater than it, so we include the plus sign
            cbar_ticknames[-1] += &#34;+&#34;
            if isinstance(self.polygon_data, list):
                self.polygon_data[0].set_cmap(cbar_colormap)
            else:
                self.polygon_data.set_cmap(cbar_colormap)
            if isinstance(self.polygon_data, list):
                cbar = plt.colorbar(self.polygon_data[0], shrink=0.5, ticks=cbar_ticks, ax=ax)
            else:
                cbar = plt.colorbar(self.polygon_data, shrink=0.5, ticks=cbar_ticks, ax=ax)
            cbar.ax.set_yticklabels(cbar_ticknames)
            if (cbar_title is None):
                plt.text(1.025,
                         0.5,
                         &#34;Spectrograph Intensity (Rayleighs)&#34;,
                         fontsize=10,
                         transform=ax.transAxes,
                         va=&#34;center&#34;,
                         rotation=&#34;vertical&#34;,
                         weight=&#34;bold&#34;,
                         style=&#34;oblique&#34;)
            else:
                plt.text(1.025,
                         0.5,
                         cbar_title,
                         fontsize=10,
                         transform=ax.transAxes,
                         va=&#34;center&#34;,
                         rotation=&#34;vertical&#34;,
                         weight=&#34;bold&#34;,
                         style=&#34;oblique&#34;)

        # save figure or show it
        if (savefig is True):
            # check that filename has been set
            if (savefig_filename is None):
                raise ValueError(&#34;The savefig_filename parameter is missing, but required since savefig was set to True.&#34;)

            # save the figure
            f_extension = os.path.splitext(savefig_filename)[-1].lower()
            if (&#34;.jpg&#34; == f_extension or &#34;.jpeg&#34; == f_extension):
                # check quality setting
                if (savefig_quality is not None):
                    plt.savefig(savefig_filename, quality=savefig_quality, bbox_inches=&#34;tight&#34;)
                else:
                    plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)
            else:
                if (savefig_quality is not None):
                    # quality specified, but output filename is not a JPG, so show a warning
                    show_warning(&#34;The savefig_quality parameter was specified, but is only used for saving JPG files. The &#34; +
                                 &#34;savefig_filename parameter was determined to not be a JPG file, so the quality will be ignored&#34;,
                                 stacklevel=1)
                plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)

            # clean up by closing the figure
            plt.close(fig)
        elif (returnfig is True):
            # return the figure and axis objects
            return (fig, ax)
        else:
            # show the figure
            plt.show(fig)

            # cleanup by closing the figure
            plt.close(fig)

        # return
        return None

    def add_geo_contours(self,
                         lats: Optional[Union[ndarray, list]] = None,
                         lons: Optional[Union[ndarray, list]] = None,
                         constant_lats: Optional[Union[float, int, Sequence[Union[float, int]], ndarray]] = None,
                         constant_lons: Optional[Union[float, int, Sequence[Union[float, int]], ndarray]] = None,
                         color: str = &#34;black&#34;,
                         linewidth: Union[float, int] = 1,
                         linestyle: str = &#34;solid&#34;,
                         marker: str = &#34;&#34;,
                         bring_to_front: bool = False):
        &#34;&#34;&#34;
        Add geographic contours to a mosaic.

        Args:
            lats (ndarray or list): 
                Sequence of geographic latitudes defining a contour.
            
            lons (ndarray or list): 
                Sequence of geographic longitudes defining a contour.

            constant_lats (float, int, or Sequence): 
                Geographic Latitude(s) at which to add line(s) of constant latitude.
            
            constant_lons (float, int, or Sequence): 
                Geographic Longitude(s) at which to add line(s) of constant longitude.

            color (str): 
                The matplotlib color used for the contour(s).

            linewidth (float or int): 
                The contour thickness.
            
            linestyle (str): 
                The matplotlib linestyle used for the contour(s).

            marker (str): 
                The matplotlib marker used for the contour(s).

            bring_to_front (bool): 
                Plots the contour on top of all other currently plotted objects.

        Returns:
            The object&#39;s contour_data parameter is populated appropriately.

        Raises:
            ValueError: issues encountered with supplied parameters.
        &#34;&#34;&#34;
        # Make sure some form of lat/lon is provided
        if (constant_lats is None) and (constant_lons is None) and (lats is None) and (lons is None):
            raise ValueError(&#34;No latitudes or longitudes provided.&#34;)

        # If manually passing in lats &amp; lons, make sure both are provided
        if (lats is not None or lons is not None) and (lats is None or lons is None):
            raise (ValueError(&#34;Manually supplying contour requires both lats and lons.&#34;))

        # Check that color exists in matplotlib
        if color not in matplotlib.colors.CSS4_COLORS:
            raise ValueError(f&#34;Color &#39;{color}&#39; not recognized by matplotlib.&#34;)

        # Check that linestyle is valid
        if linestyle not in [&#34;-&#34;, &#34;--&#34;, &#34;-.&#34;, &#34;:&#34;, &#34;solid&#34;, &#34;dashed&#34;, &#34;dashdot&#34;, &#34;dotted&#34;]:
            raise ValueError(f&#34;Linestyle &#39;{linestyle}&#39; not recognized by matplotlib.&#34;)

        # Check that linewidth is valid
        if linewidth &lt;= 0:
            raise ValueError(&#34;Linewidth must be greater than zero.&#34;)

        # Check that marker is valid
        if marker not in [&#34;&#34;, &#34;o&#34;, &#34;.&#34;, &#34;p&#34;, &#34;*&#34;, &#34;x&#34;, &#34;+&#34;, &#34;X&#34;]:
            raise ValueError(f&#34;Marker &#39;{marker}&#39; is not currently supported.&#34;)

        # Convert numerics to lists if necessary
        if constant_lats is not None:
            if isinstance(constant_lats, (float, int)):
                constant_lats = [constant_lats]
        if constant_lons is not None:
            if isinstance(constant_lons, (float, int)):
                constant_lons = [constant_lons]

        # Initialize contour data dict if it doesn&#39;t exist yet
        if self.contour_data is None:
            self.contour_data = {&#34;x&#34;: [], &#34;y&#34;: [], &#34;color&#34;: [], &#34;linewidth&#34;: [], &#34;linestyle&#34;: [], &#34;marker&#34;: [], &#34;zorder&#34;: []}

        # Obtain the mosaic&#39;s projection
        source_proj = pyproj.CRS.from_user_input(cartopy.crs.Geodetic())
        mosaic_proj = pyproj.CRS.from_user_input(self.cartopy_projection)
        transformer = pyproj.Transformer.from_crs(source_proj, mosaic_proj, always_xy=True)

        # First handling manually supplied lat/lon arrays
        if (lats is not None) and (lons is not None):
            # Convert lists to ndarrays if necessary
            if isinstance(lats, list):
                lats = np.array(lats)
            if isinstance(lons, list):
                lons = np.array(lons)

            if len(lats) != len(lons):
                raise ValueError(&#34;Lat/Lon data must be of the same size.&#34;)

            # Create specified contour from geographic coords
            x, y = transformer.transform(lons, lats)
            # Add contour to dict, along with color and linewidth
            self.contour_data[&#34;x&#34;].append(x)
            self.contour_data[&#34;y&#34;].append(y)
            self.contour_data[&#34;color&#34;].append(color)
            self.contour_data[&#34;linewidth&#34;].append(linewidth)
            self.contour_data[&#34;linestyle&#34;].append(linestyle)
            self.contour_data[&#34;marker&#34;].append(marker)
            self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

        # Next handling lines of constant latitude
        if constant_lats is not None:
            # Generate longitudinal domain of the lat line (full globe)
            lon_domain = np.arange(-180, 180 + 0.2, 0.2)

            # Iterate through all lines of constant lat requested
            for lat in constant_lats:
                # Create line of constant lat
                const_lat_x, const_lat_y = (lon_domain, lon_domain * 0 + lat)
                sort_idx = np.argsort(const_lat_x)
                const_lat_y = const_lat_y[sort_idx]
                const_lat_x = const_lat_x[sort_idx]
                const_lat_x, const_lat_y = transformer.transform(const_lat_x, const_lat_y)

                # Add contour to dict, along with color and linewidth
                self.contour_data[&#34;x&#34;].append(const_lat_x)
                self.contour_data[&#34;y&#34;].append(const_lat_y)
                self.contour_data[&#34;color&#34;].append(color)
                self.contour_data[&#34;linewidth&#34;].append(linewidth)
                self.contour_data[&#34;linestyle&#34;].append(linestyle)
                self.contour_data[&#34;marker&#34;].append(marker)
                self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

        # Now handling lines of constant longitude
        if constant_lons is not None:
            # Generate latitudinal domain of the lon line (full globe)
            lat_domain = np.arange(-90, 90 + 0.1, 0.1)

            # Iterate through all lines of constant lon requested
            for lon in constant_lons:
                # Create line of constant lon and add to dict
                const_lon_x, const_lon_y = (lat_domain * 0 + lon, lat_domain)
                sort_idx = np.argsort(const_lon_y)
                const_lon_x = const_lon_x[sort_idx]
                const_lon_y = const_lon_y[sort_idx]
                const_lon_x, const_lon_y = transformer.transform(const_lon_x, const_lon_y)

                # Add contour to dict, along with color and linewidth
                self.contour_data[&#34;x&#34;].append(const_lon_x)
                self.contour_data[&#34;y&#34;].append(const_lon_y)
                self.contour_data[&#34;color&#34;].append(color)
                self.contour_data[&#34;linewidth&#34;].append(linewidth)
                self.contour_data[&#34;linestyle&#34;].append(linestyle)
                self.contour_data[&#34;marker&#34;].append(marker)
                self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

    def add_mag_contours(self,
                         timestamp: datetime.datetime,
                         constant_lats: Optional[Union[float, int, Sequence[Union[float, int]], ndarray]] = None,
                         constant_lons: Optional[Union[float, int, Sequence[Union[float, int]], ndarray]] = None,
                         lats: Optional[Union[ndarray, list]] = None,
                         lons: Optional[Union[ndarray, list]] = None,
                         color: str = &#34;black&#34;,
                         linewidth: Union[float, int] = 1,
                         linestyle: str = &#34;solid&#34;,
                         marker: str = &#34;&#34;,
                         bring_to_front: bool = False):
        &#34;&#34;&#34;
        Add geomagnetic contours to a mosaic.

        Args:
            timestamp (datetime.datetime): 
                The timestamp used in computing AACGM coordinates.

            lats (ndarray or list): 
                Sequence of geomagnetic latitudes defining a contour.
            
            lons (ndarray or list): 
                Sequence of geomagnetic longitudes defining a contour.

            constant_lats (float, int, Sequence): 
                Geomagnetic latitude(s) at which to add contour(s) of constant latitude.
            
            constant_lons (float, int, Sequence): 
                Geomagnetic longitude(s) at which to add contours(s) of constant longitude.

            color (str): 
                The matplotlib color used for the contour(s).

            linewidth (float or int): 
                The contour thickness.

            linestyle (str): 
                The matplotlib linestyle used for the contour(s).

            marker (str): 
                The matplotlib marker used for the contour(s).

            bring_to_front (bool): 
                Plots the contour on top of all other currently plotted objects.

        Returns:
            The object&#39;s contour_data parameter is populated appropriately.

        Raises:
            ValueError: issues encountered with supplied parameters
        &#34;&#34;&#34;
        # Make sure some form of lat/lon is provided
        if (constant_lats is None) and (constant_lons is None) and (lats is None) and (lons is None):
            raise ValueError(&#34;No latitudes or longitudes provided.&#34;)

        # If manually passing in lats &amp; lons, make sure both are provided
        if (lats is not None or lons is not None) and (lats is None or lons is None):
            raise ValueError(&#34;Manually supplying contour requires both lats and lons.&#34;)

        # Check that color exists in matplotlib
        if color not in matplotlib.colors.CSS4_COLORS:
            raise ValueError(f&#34;Color &#39;{color}&#39; not recognized by matplotlib.&#34;)

        # Check that linestyle is valid
        if linestyle not in [&#34;-&#34;, &#34;--&#34;, &#34;-.&#34;, &#34;:&#34;, &#34;solid&#34;, &#34;dashed&#34;, &#34;dashdot&#34;, &#34;dotted&#34;]:
            raise ValueError(f&#34;Linestyle &#39;{linestyle}&#39; not recognized by matplotlib.&#34;)

        # Check that linewidth is valid
        if linewidth &lt;= 0:
            raise ValueError(&#34;linewidth must be greater than zero.&#34;)

        # Convert numerics to lists if necessary
        if constant_lats is not None:
            if isinstance(constant_lats, (float, int)):
                constant_lats = [constant_lats]
        if constant_lons is not None:
            if isinstance(constant_lons, (float, int)):
                constant_lons = [constant_lons]

        # Initialize contour data dict if it doesn&#39;t exist yet
        if self.contour_data is None:
            self.contour_data = {&#34;x&#34;: [], &#34;y&#34;: [], &#34;color&#34;: [], &#34;linewidth&#34;: [], &#34;linestyle&#34;: [], &#34;marker&#34;: [], &#34;zorder&#34;: []}

        # Obtain the mosaic&#39;s projection
        source_proj = pyproj.CRS.from_user_input(cartopy.crs.Geodetic())
        mosaic_proj = pyproj.CRS.from_user_input(self.cartopy_projection)
        transformer = pyproj.Transformer.from_crs(source_proj, mosaic_proj, always_xy=True)

        # First handling manually supplied lat/lon arrays
        if (lats is not None) and (lons is not None):
            # Convert lists to ndarrays if necessary
            if isinstance(lats, list):
                lats = np.array(lats)
            if isinstance(lons, list):
                lons = np.array(lons)

            if len(lats) != len(lons):
                raise ValueError(&#34;Lat/Lon data must be of the same size.&#34;)

            # Create specified contour from magnetic coords
            y, x, alt = aacgmv2.convert_latlon_arr(lats, lons, lats * 0.0, timestamp, method_code=&#34;A2G&#34;)
            x, y = transformer.transform(x, y)

            # Add contour to dict, along with color and linewidth
            self.contour_data[&#34;x&#34;].append(x)
            self.contour_data[&#34;y&#34;].append(y)
            self.contour_data[&#34;color&#34;].append(color)
            self.contour_data[&#34;linewidth&#34;].append(linewidth)
            self.contour_data[&#34;linestyle&#34;].append(linestyle)
            self.contour_data[&#34;marker&#34;].append(marker)
            self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

        # Next handling lines of constant latitude
        if constant_lats is not None:
            # Generate longitudinal domain of the lat line (full globe)
            lon_domain = np.arange(-180, 180 + 0.2, 0.2)

            # iterate through all lines of constant lat requested
            for lat in constant_lats:
                # Create line of constant lat from magnetic coords
                const_lat_x, const_lat_y = (lon_domain, lon_domain * 0 + lat)
                const_lat_y, const_lat_x, alt = aacgmv2.convert_latlon_arr(const_lat_y, const_lat_x, const_lat_x * 0.0, timestamp, method_code=&#34;A2G&#34;)
                sort_idx = np.argsort(const_lat_x)
                const_lat_y = const_lat_y[sort_idx]
                const_lat_x = const_lat_x[sort_idx]
                const_lat_x, const_lat_y = transformer.transform(const_lat_x, const_lat_y)

                # Add contour to dict, along with color and linewidth
                self.contour_data[&#34;x&#34;].append(const_lat_x)
                self.contour_data[&#34;y&#34;].append(const_lat_y)
                self.contour_data[&#34;color&#34;].append(color)
                self.contour_data[&#34;linewidth&#34;].append(linewidth)
                self.contour_data[&#34;linestyle&#34;].append(linestyle)
                self.contour_data[&#34;marker&#34;].append(marker)
                self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

        # Now handling lines of constant longitude
        if constant_lons is not None:
            # Generate latitudinal domain of the lon line (full globe)
            lat_domain = np.arange(-90, 90 + 0.1, 0.1)

            # iterate through all lines of constant lon requested
            for lon in constant_lons:
                # Create line of constant lon from magnetic coords
                const_lon_x, const_lon_y = (lat_domain * 0 + lon, lat_domain)
                const_lon_y, const_lon_x, alt = aacgmv2.convert_latlon_arr(const_lon_y, const_lon_x, const_lon_x * 0.0, timestamp, method_code=&#34;A2G&#34;)
                sort_idx = np.argsort(const_lon_y)
                const_lon_x = const_lon_x[sort_idx]
                const_lon_y = const_lon_y[sort_idx]
                const_lon_x, const_lon_y = transformer.transform(const_lon_x, const_lon_y)

                # Add contour to dict, along with color and linewidth
                self.contour_data[&#34;x&#34;].append(const_lon_x)
                self.contour_data[&#34;y&#34;].append(const_lon_y)
                self.contour_data[&#34;color&#34;].append(color)
                self.contour_data[&#34;linewidth&#34;].append(linewidth)
                self.contour_data[&#34;linestyle&#34;].append(linestyle)
                self.contour_data[&#34;marker&#34;].append(marker)
                self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))</code></pre>
</details>
<div class="desc"><p>Class representation for a generated mosaic.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>polygon_data</code></strong> :&ensp;<code>matplotlib.collections.PolyCollection</code></dt>
<dd>Generated polygons containing rendered data.</dd>
<dt><strong><code>cartopy_projection</code></strong> :&ensp;<code>cartopy.crs.Projection</code></dt>
<dd>Cartopy projection to utilize.</dd>
<dt><strong><code>contour_data</code></strong> :&ensp;<code>Dict[str, List[Any]]</code></dt>
<dd>Generated contour data.</dd>
<dt><strong><code>spect_cmap</code></strong> :&ensp;<code>str</code></dt>
<dd>String giving the cmap to use for spect legend.</dd>
<dt><strong><code>spect_intensity_scale</code></strong> :&ensp;<code>Tuple[int]</code></dt>
<dd>The min and max values that spectrograph data
is scaled to in the mosaic, if any is present.</dd>
</dl></div>
<h3>Class variables</h3>
<dl>
<dt id="pyaurorax.tools.Mosaic.cartopy_projection"><code class="name">var <span class="ident">cartopy_projection</span> : cartopy.crs.Projection</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.tools.Mosaic.contour_data"><code class="name">var <span class="ident">contour_data</span> : Dict[str, List[Any]] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.tools.Mosaic.polygon_data"><code class="name">var <span class="ident">polygon_data</span> : matplotlib.collections.PolyCollection | List[matplotlib.collections.PolyCollection]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.tools.Mosaic.spect_cmap"><code class="name">var <span class="ident">spect_cmap</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.tools.Mosaic.spect_intensity_scale"><code class="name">var <span class="ident">spect_intensity_scale</span> : Tuple[int, int] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.tools.Mosaic.add_geo_contours"><code class="name flex">
<span>def <span class="ident">add_geo_contours</span></span>(<span>self,<br>lats: numpy.ndarray | list | None = None,<br>lons: numpy.ndarray | list | None = None,<br>constant_lats: float | int | Sequence[float | int] | numpy.ndarray | None = None,<br>constant_lons: float | int | Sequence[float | int] | numpy.ndarray | None = None,<br>color: str = 'black',<br>linewidth: float | int = 1,<br>linestyle: str = 'solid',<br>marker: str = '',<br>bring_to_front: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_geo_contours(self,
                     lats: Optional[Union[ndarray, list]] = None,
                     lons: Optional[Union[ndarray, list]] = None,
                     constant_lats: Optional[Union[float, int, Sequence[Union[float, int]], ndarray]] = None,
                     constant_lons: Optional[Union[float, int, Sequence[Union[float, int]], ndarray]] = None,
                     color: str = &#34;black&#34;,
                     linewidth: Union[float, int] = 1,
                     linestyle: str = &#34;solid&#34;,
                     marker: str = &#34;&#34;,
                     bring_to_front: bool = False):
    &#34;&#34;&#34;
    Add geographic contours to a mosaic.

    Args:
        lats (ndarray or list): 
            Sequence of geographic latitudes defining a contour.
        
        lons (ndarray or list): 
            Sequence of geographic longitudes defining a contour.

        constant_lats (float, int, or Sequence): 
            Geographic Latitude(s) at which to add line(s) of constant latitude.
        
        constant_lons (float, int, or Sequence): 
            Geographic Longitude(s) at which to add line(s) of constant longitude.

        color (str): 
            The matplotlib color used for the contour(s).

        linewidth (float or int): 
            The contour thickness.
        
        linestyle (str): 
            The matplotlib linestyle used for the contour(s).

        marker (str): 
            The matplotlib marker used for the contour(s).

        bring_to_front (bool): 
            Plots the contour on top of all other currently plotted objects.

    Returns:
        The object&#39;s contour_data parameter is populated appropriately.

    Raises:
        ValueError: issues encountered with supplied parameters.
    &#34;&#34;&#34;
    # Make sure some form of lat/lon is provided
    if (constant_lats is None) and (constant_lons is None) and (lats is None) and (lons is None):
        raise ValueError(&#34;No latitudes or longitudes provided.&#34;)

    # If manually passing in lats &amp; lons, make sure both are provided
    if (lats is not None or lons is not None) and (lats is None or lons is None):
        raise (ValueError(&#34;Manually supplying contour requires both lats and lons.&#34;))

    # Check that color exists in matplotlib
    if color not in matplotlib.colors.CSS4_COLORS:
        raise ValueError(f&#34;Color &#39;{color}&#39; not recognized by matplotlib.&#34;)

    # Check that linestyle is valid
    if linestyle not in [&#34;-&#34;, &#34;--&#34;, &#34;-.&#34;, &#34;:&#34;, &#34;solid&#34;, &#34;dashed&#34;, &#34;dashdot&#34;, &#34;dotted&#34;]:
        raise ValueError(f&#34;Linestyle &#39;{linestyle}&#39; not recognized by matplotlib.&#34;)

    # Check that linewidth is valid
    if linewidth &lt;= 0:
        raise ValueError(&#34;Linewidth must be greater than zero.&#34;)

    # Check that marker is valid
    if marker not in [&#34;&#34;, &#34;o&#34;, &#34;.&#34;, &#34;p&#34;, &#34;*&#34;, &#34;x&#34;, &#34;+&#34;, &#34;X&#34;]:
        raise ValueError(f&#34;Marker &#39;{marker}&#39; is not currently supported.&#34;)

    # Convert numerics to lists if necessary
    if constant_lats is not None:
        if isinstance(constant_lats, (float, int)):
            constant_lats = [constant_lats]
    if constant_lons is not None:
        if isinstance(constant_lons, (float, int)):
            constant_lons = [constant_lons]

    # Initialize contour data dict if it doesn&#39;t exist yet
    if self.contour_data is None:
        self.contour_data = {&#34;x&#34;: [], &#34;y&#34;: [], &#34;color&#34;: [], &#34;linewidth&#34;: [], &#34;linestyle&#34;: [], &#34;marker&#34;: [], &#34;zorder&#34;: []}

    # Obtain the mosaic&#39;s projection
    source_proj = pyproj.CRS.from_user_input(cartopy.crs.Geodetic())
    mosaic_proj = pyproj.CRS.from_user_input(self.cartopy_projection)
    transformer = pyproj.Transformer.from_crs(source_proj, mosaic_proj, always_xy=True)

    # First handling manually supplied lat/lon arrays
    if (lats is not None) and (lons is not None):
        # Convert lists to ndarrays if necessary
        if isinstance(lats, list):
            lats = np.array(lats)
        if isinstance(lons, list):
            lons = np.array(lons)

        if len(lats) != len(lons):
            raise ValueError(&#34;Lat/Lon data must be of the same size.&#34;)

        # Create specified contour from geographic coords
        x, y = transformer.transform(lons, lats)
        # Add contour to dict, along with color and linewidth
        self.contour_data[&#34;x&#34;].append(x)
        self.contour_data[&#34;y&#34;].append(y)
        self.contour_data[&#34;color&#34;].append(color)
        self.contour_data[&#34;linewidth&#34;].append(linewidth)
        self.contour_data[&#34;linestyle&#34;].append(linestyle)
        self.contour_data[&#34;marker&#34;].append(marker)
        self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

    # Next handling lines of constant latitude
    if constant_lats is not None:
        # Generate longitudinal domain of the lat line (full globe)
        lon_domain = np.arange(-180, 180 + 0.2, 0.2)

        # Iterate through all lines of constant lat requested
        for lat in constant_lats:
            # Create line of constant lat
            const_lat_x, const_lat_y = (lon_domain, lon_domain * 0 + lat)
            sort_idx = np.argsort(const_lat_x)
            const_lat_y = const_lat_y[sort_idx]
            const_lat_x = const_lat_x[sort_idx]
            const_lat_x, const_lat_y = transformer.transform(const_lat_x, const_lat_y)

            # Add contour to dict, along with color and linewidth
            self.contour_data[&#34;x&#34;].append(const_lat_x)
            self.contour_data[&#34;y&#34;].append(const_lat_y)
            self.contour_data[&#34;color&#34;].append(color)
            self.contour_data[&#34;linewidth&#34;].append(linewidth)
            self.contour_data[&#34;linestyle&#34;].append(linestyle)
            self.contour_data[&#34;marker&#34;].append(marker)
            self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

    # Now handling lines of constant longitude
    if constant_lons is not None:
        # Generate latitudinal domain of the lon line (full globe)
        lat_domain = np.arange(-90, 90 + 0.1, 0.1)

        # Iterate through all lines of constant lon requested
        for lon in constant_lons:
            # Create line of constant lon and add to dict
            const_lon_x, const_lon_y = (lat_domain * 0 + lon, lat_domain)
            sort_idx = np.argsort(const_lon_y)
            const_lon_x = const_lon_x[sort_idx]
            const_lon_y = const_lon_y[sort_idx]
            const_lon_x, const_lon_y = transformer.transform(const_lon_x, const_lon_y)

            # Add contour to dict, along with color and linewidth
            self.contour_data[&#34;x&#34;].append(const_lon_x)
            self.contour_data[&#34;y&#34;].append(const_lon_y)
            self.contour_data[&#34;color&#34;].append(color)
            self.contour_data[&#34;linewidth&#34;].append(linewidth)
            self.contour_data[&#34;linestyle&#34;].append(linestyle)
            self.contour_data[&#34;marker&#34;].append(marker)
            self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))</code></pre>
</details>
<div class="desc"><p>Add geographic contours to a mosaic.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lats</code></strong> :&ensp;<code>ndarray</code> or <code>list</code></dt>
<dd>Sequence of geographic latitudes defining a contour.</dd>
<dt><strong><code>lons</code></strong> :&ensp;<code>ndarray</code> or <code>list</code></dt>
<dd>Sequence of geographic longitudes defining a contour.</dd>
<dt><strong><code>constant_lats</code></strong> :&ensp;<code>float, int,</code> or <code>Sequence</code></dt>
<dd>Geographic Latitude(s) at which to add line(s) of constant latitude.</dd>
<dt><strong><code>constant_lons</code></strong> :&ensp;<code>float, int,</code> or <code>Sequence</code></dt>
<dd>Geographic Longitude(s) at which to add line(s) of constant longitude.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code></dt>
<dd>The matplotlib color used for the contour(s).</dd>
<dt><strong><code>linewidth</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>The contour thickness.</dd>
<dt><strong><code>linestyle</code></strong> :&ensp;<code>str</code></dt>
<dd>The matplotlib linestyle used for the contour(s).</dd>
<dt><strong><code>marker</code></strong> :&ensp;<code>str</code></dt>
<dd>The matplotlib marker used for the contour(s).</dd>
<dt><strong><code>bring_to_front</code></strong> :&ensp;<code>bool</code></dt>
<dd>Plots the contour on top of all other currently plotted objects.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The object's contour_data parameter is populated appropriately.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>issues encountered with supplied parameters.</dd>
</dl></div>
</dd>
<dt id="pyaurorax.tools.Mosaic.add_mag_contours"><code class="name flex">
<span>def <span class="ident">add_mag_contours</span></span>(<span>self,<br>timestamp: datetime.datetime,<br>constant_lats: float | int | Sequence[float | int] | numpy.ndarray | None = None,<br>constant_lons: float | int | Sequence[float | int] | numpy.ndarray | None = None,<br>lats: numpy.ndarray | list | None = None,<br>lons: numpy.ndarray | list | None = None,<br>color: str = 'black',<br>linewidth: float | int = 1,<br>linestyle: str = 'solid',<br>marker: str = '',<br>bring_to_front: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_mag_contours(self,
                     timestamp: datetime.datetime,
                     constant_lats: Optional[Union[float, int, Sequence[Union[float, int]], ndarray]] = None,
                     constant_lons: Optional[Union[float, int, Sequence[Union[float, int]], ndarray]] = None,
                     lats: Optional[Union[ndarray, list]] = None,
                     lons: Optional[Union[ndarray, list]] = None,
                     color: str = &#34;black&#34;,
                     linewidth: Union[float, int] = 1,
                     linestyle: str = &#34;solid&#34;,
                     marker: str = &#34;&#34;,
                     bring_to_front: bool = False):
    &#34;&#34;&#34;
    Add geomagnetic contours to a mosaic.

    Args:
        timestamp (datetime.datetime): 
            The timestamp used in computing AACGM coordinates.

        lats (ndarray or list): 
            Sequence of geomagnetic latitudes defining a contour.
        
        lons (ndarray or list): 
            Sequence of geomagnetic longitudes defining a contour.

        constant_lats (float, int, Sequence): 
            Geomagnetic latitude(s) at which to add contour(s) of constant latitude.
        
        constant_lons (float, int, Sequence): 
            Geomagnetic longitude(s) at which to add contours(s) of constant longitude.

        color (str): 
            The matplotlib color used for the contour(s).

        linewidth (float or int): 
            The contour thickness.

        linestyle (str): 
            The matplotlib linestyle used for the contour(s).

        marker (str): 
            The matplotlib marker used for the contour(s).

        bring_to_front (bool): 
            Plots the contour on top of all other currently plotted objects.

    Returns:
        The object&#39;s contour_data parameter is populated appropriately.

    Raises:
        ValueError: issues encountered with supplied parameters
    &#34;&#34;&#34;
    # Make sure some form of lat/lon is provided
    if (constant_lats is None) and (constant_lons is None) and (lats is None) and (lons is None):
        raise ValueError(&#34;No latitudes or longitudes provided.&#34;)

    # If manually passing in lats &amp; lons, make sure both are provided
    if (lats is not None or lons is not None) and (lats is None or lons is None):
        raise ValueError(&#34;Manually supplying contour requires both lats and lons.&#34;)

    # Check that color exists in matplotlib
    if color not in matplotlib.colors.CSS4_COLORS:
        raise ValueError(f&#34;Color &#39;{color}&#39; not recognized by matplotlib.&#34;)

    # Check that linestyle is valid
    if linestyle not in [&#34;-&#34;, &#34;--&#34;, &#34;-.&#34;, &#34;:&#34;, &#34;solid&#34;, &#34;dashed&#34;, &#34;dashdot&#34;, &#34;dotted&#34;]:
        raise ValueError(f&#34;Linestyle &#39;{linestyle}&#39; not recognized by matplotlib.&#34;)

    # Check that linewidth is valid
    if linewidth &lt;= 0:
        raise ValueError(&#34;linewidth must be greater than zero.&#34;)

    # Convert numerics to lists if necessary
    if constant_lats is not None:
        if isinstance(constant_lats, (float, int)):
            constant_lats = [constant_lats]
    if constant_lons is not None:
        if isinstance(constant_lons, (float, int)):
            constant_lons = [constant_lons]

    # Initialize contour data dict if it doesn&#39;t exist yet
    if self.contour_data is None:
        self.contour_data = {&#34;x&#34;: [], &#34;y&#34;: [], &#34;color&#34;: [], &#34;linewidth&#34;: [], &#34;linestyle&#34;: [], &#34;marker&#34;: [], &#34;zorder&#34;: []}

    # Obtain the mosaic&#39;s projection
    source_proj = pyproj.CRS.from_user_input(cartopy.crs.Geodetic())
    mosaic_proj = pyproj.CRS.from_user_input(self.cartopy_projection)
    transformer = pyproj.Transformer.from_crs(source_proj, mosaic_proj, always_xy=True)

    # First handling manually supplied lat/lon arrays
    if (lats is not None) and (lons is not None):
        # Convert lists to ndarrays if necessary
        if isinstance(lats, list):
            lats = np.array(lats)
        if isinstance(lons, list):
            lons = np.array(lons)

        if len(lats) != len(lons):
            raise ValueError(&#34;Lat/Lon data must be of the same size.&#34;)

        # Create specified contour from magnetic coords
        y, x, alt = aacgmv2.convert_latlon_arr(lats, lons, lats * 0.0, timestamp, method_code=&#34;A2G&#34;)
        x, y = transformer.transform(x, y)

        # Add contour to dict, along with color and linewidth
        self.contour_data[&#34;x&#34;].append(x)
        self.contour_data[&#34;y&#34;].append(y)
        self.contour_data[&#34;color&#34;].append(color)
        self.contour_data[&#34;linewidth&#34;].append(linewidth)
        self.contour_data[&#34;linestyle&#34;].append(linestyle)
        self.contour_data[&#34;marker&#34;].append(marker)
        self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

    # Next handling lines of constant latitude
    if constant_lats is not None:
        # Generate longitudinal domain of the lat line (full globe)
        lon_domain = np.arange(-180, 180 + 0.2, 0.2)

        # iterate through all lines of constant lat requested
        for lat in constant_lats:
            # Create line of constant lat from magnetic coords
            const_lat_x, const_lat_y = (lon_domain, lon_domain * 0 + lat)
            const_lat_y, const_lat_x, alt = aacgmv2.convert_latlon_arr(const_lat_y, const_lat_x, const_lat_x * 0.0, timestamp, method_code=&#34;A2G&#34;)
            sort_idx = np.argsort(const_lat_x)
            const_lat_y = const_lat_y[sort_idx]
            const_lat_x = const_lat_x[sort_idx]
            const_lat_x, const_lat_y = transformer.transform(const_lat_x, const_lat_y)

            # Add contour to dict, along with color and linewidth
            self.contour_data[&#34;x&#34;].append(const_lat_x)
            self.contour_data[&#34;y&#34;].append(const_lat_y)
            self.contour_data[&#34;color&#34;].append(color)
            self.contour_data[&#34;linewidth&#34;].append(linewidth)
            self.contour_data[&#34;linestyle&#34;].append(linestyle)
            self.contour_data[&#34;marker&#34;].append(marker)
            self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))

    # Now handling lines of constant longitude
    if constant_lons is not None:
        # Generate latitudinal domain of the lon line (full globe)
        lat_domain = np.arange(-90, 90 + 0.1, 0.1)

        # iterate through all lines of constant lon requested
        for lon in constant_lons:
            # Create line of constant lon from magnetic coords
            const_lon_x, const_lon_y = (lat_domain * 0 + lon, lat_domain)
            const_lon_y, const_lon_x, alt = aacgmv2.convert_latlon_arr(const_lon_y, const_lon_x, const_lon_x * 0.0, timestamp, method_code=&#34;A2G&#34;)
            sort_idx = np.argsort(const_lon_y)
            const_lon_x = const_lon_x[sort_idx]
            const_lon_y = const_lon_y[sort_idx]
            const_lon_x, const_lon_y = transformer.transform(const_lon_x, const_lon_y)

            # Add contour to dict, along with color and linewidth
            self.contour_data[&#34;x&#34;].append(const_lon_x)
            self.contour_data[&#34;y&#34;].append(const_lon_y)
            self.contour_data[&#34;color&#34;].append(color)
            self.contour_data[&#34;linewidth&#34;].append(linewidth)
            self.contour_data[&#34;linestyle&#34;].append(linestyle)
            self.contour_data[&#34;marker&#34;].append(marker)
            self.contour_data[&#34;zorder&#34;].append(int(bring_to_front))</code></pre>
</details>
<div class="desc"><p>Add geomagnetic contours to a mosaic.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timestamp</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>The timestamp used in computing AACGM coordinates.</dd>
<dt><strong><code>lats</code></strong> :&ensp;<code>ndarray</code> or <code>list</code></dt>
<dd>Sequence of geomagnetic latitudes defining a contour.</dd>
<dt><strong><code>lons</code></strong> :&ensp;<code>ndarray</code> or <code>list</code></dt>
<dd>Sequence of geomagnetic longitudes defining a contour.</dd>
<dt><strong><code>constant_lats</code></strong> :&ensp;<code>float, int, Sequence</code></dt>
<dd>Geomagnetic latitude(s) at which to add contour(s) of constant latitude.</dd>
<dt><strong><code>constant_lons</code></strong> :&ensp;<code>float, int, Sequence</code></dt>
<dd>Geomagnetic longitude(s) at which to add contours(s) of constant longitude.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code></dt>
<dd>The matplotlib color used for the contour(s).</dd>
<dt><strong><code>linewidth</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>The contour thickness.</dd>
<dt><strong><code>linestyle</code></strong> :&ensp;<code>str</code></dt>
<dd>The matplotlib linestyle used for the contour(s).</dd>
<dt><strong><code>marker</code></strong> :&ensp;<code>str</code></dt>
<dd>The matplotlib marker used for the contour(s).</dd>
<dt><strong><code>bring_to_front</code></strong> :&ensp;<code>bool</code></dt>
<dd>Plots the contour on top of all other currently plotted objects.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The object's contour_data parameter is populated appropriately.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>issues encountered with supplied parameters</dd>
</dl></div>
</dd>
<dt id="pyaurorax.tools.Mosaic.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self,<br>map_extent: Sequence[float | int],<br>figsize: Tuple[int, int] | None = None,<br>rayleighs: bool = False,<br>max_rayleighs: int = 20000,<br>title: str | None = None,<br>ocean_color: str | None = None,<br>land_color: str = 'gray',<br>land_edgecolor: str = '#8A8A8A',<br>borders_color: str = '#AEAEAE',<br>borders_disable: bool = False,<br>colorbar_title: str | None = None,<br>cbar_title: str | None = None,<br>cbar_colormap: str = '',<br>returnfig: bool = False,<br>savefig: bool = False,<br>savefig_filename: str | None = None,<br>savefig_quality: int | None = None) ‑> Any</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(
        self,
        map_extent: Sequence[Union[float, int]],
        figsize: Optional[Tuple[int, int]] = None,
        rayleighs: bool = False,
        max_rayleighs: int = 20000,
        title: Optional[str] = None,
        ocean_color: Optional[str] = None,
        land_color: str = &#34;gray&#34;,
        land_edgecolor: str = &#34;#8A8A8A&#34;,
        borders_color: str = &#34;#AEAEAE&#34;,
        borders_disable: bool = False,
        colorbar_title: Optional[str] = None,  # deprecated in v1.11.0, use cbar_title instead
        cbar_title: Optional[str] = None,
        cbar_colormap: str = &#34;&#34;,
        returnfig: bool = False,
        savefig: bool = False,
        savefig_filename: Optional[str] = None,
        savefig_quality: Optional[int] = None) -&gt; Any:
    &#34;&#34;&#34;
    Generate a plot of the mosaic data. 
    
    Either display it (default behaviour), save it to disk (using the `savefig` parameter), or 
    return the matplotlib plot object for further usage (using the `returnfig` parameter).

    Args:
        map_extent (List[int]): 
            Latitude/longitude range to be visible on the rendered map. This is a list of 4 integers 
            and/or floats, in the order of [min_lon, max_lon, min_lat, max_lat].

        figsize (tuple): 
            The matplotlib figure size to use when plotting. For example `figsize=(14,4)`.

        rayleighs (bool): 
            Set to `True` if the data being plotted is in Rayleighs. Defaults to `False`.

        max_rayleighs (int): 
            Max intensity scale for Rayleighs. Defaults to `20000`.

        title (str): 
            The title to display above the plotted mosaic. Default is no title.

        ocean_color (str): 
            Colour of the ocean. Default is cartopy&#39;s default shade of blue. Colours can be supplied
            as a word, or hexcode prefixed with a &#39;#&#39; character (ie. `#55AADD`).
        
        land_color (str): 
            Colour of the land. Default is `gray`. Colours can be supplied as a word, or hexcode 
            prefixed with a &#39;#&#39; character (ie. `#41BB87`).

        land_edgecolor (str): 
            Color of the land edges. Default is `#8A8A8A`. Colours can be supplied as a word, or
            hexcode prefixed with a &#39;#&#39; character.

        borders_color (str): 
            Color of the country borders. Default is `AEAEAE`. Colours can be supplied as a word, or
            hexcode prefixed with a &#39;#&#39; character.
        
        borders_disable (bool): 
            Disbale rendering of the borders. Default is `False`.

        cbar_title (str): 
            Title for the colorbar. Default is no title.

        colorbar_title (str): 
            Deprecated as of v1.10.0. Use &#39;cbar_title&#39; instead in the exact same way.

        cbar_colormap (str): 
            The matplotlib colormap to use for the plotted color bar. Default is `gray`, unless
            mosaic was created with spectrograph data, in which case defaults to the colormap
            used for spectrograph data..

            Commonly used colormaps are:

            - REGO: `gist_heat`
            - THEMIS ASI: `gray`
            - TREx Blue: `Blues_r`
            - TREx NIR: `gray`
            - TREx RGB: `None`

            A list of all available colormaps can be found on the 
            [matplotlib documentation](https://matplotlib.org/stable/gallery/color/colormap_reference.html).

        returnfig (bool): 
            Instead of displaying the image, return the matplotlib figure object. This allows for further plot 
            manipulation, for example, adding labels or a title in a different location than the default. 
            
            Remember - if this parameter is supplied, be sure that you close your plot after finishing work 
            with it. This can be achieved by doing `plt.close(fig)`. 
            
            Note that this method cannot be used in combination with `savefig`.

        savefig (bool): 
            Save the displayed image to disk instead of displaying it. The parameter savefig_filename is required if 
            this parameter is set to True. Defaults to `False`.

        savefig_filename (str): 
            Filename to save the image to. Must be specified if the savefig parameter is set to True.

        savefig_quality (int): 
            Quality level of the saved image. This can be specified if the savefig_filename is a JPG image. If it
            is a PNG, quality is ignored. Default quality level for JPGs is matplotlib/Pillow&#39;s default of 75%.

    Returns:
        The displayed montage, by default. If `savefig` is set to True, nothing will be returned. If `returnfig` is 
        set to True, the plotting variables `(fig, ax)` will be returned.

    Raises:
    &#34;&#34;&#34;
    # handle deprecation warnings
    if (colorbar_title is not None):
        show_warning(&#34;The parameter &#39;colorbar_title&#39; was deprecated in v1.11.0. Please use &#39;cbar_title&#39; instead (usage is identical).&#34;,
                     stacklevel=1)
        cbar_title = colorbar_title

    # check return mode
    if (returnfig is True and savefig is True):
        raise ValueError(&#34;Only one of returnfig or savefig can be set to True&#34;)
    if returnfig is True and (savefig_filename is not None or savefig_quality is not None):
        show_warning(&#34;The figure will be returned, but a savefig option parameter was supplied. Consider &#34; +
                     &#34;removing the savefig option parameter(s) as they will be ignored.&#34;,
                     stacklevel=1)
    elif (savefig is False and (savefig_filename is not None or savefig_quality is not None)):
        show_warning(&#34;A savefig option parameter was supplied, but the savefig parameter is False. The &#34; +
                     &#34;savefig option parameters will be ignored.&#34;,
                     stacklevel=1)

    # get colormap if there is spectrograph data
    if self.spect_cmap is not None:
        cbar_colormap = self.spect_cmap

    # initialize figure
    fig = plt.figure(figsize=figsize)
    ax = fig.add_axes((0, 0, 1, 1), projection=self.cartopy_projection)
    ax.set_extent(map_extent, crs=cartopy.crs.Geodetic())  # type: ignore

    # add ocean
    #
    # NOTE: we use the default ocean color
    if (ocean_color is not None):
        ax.add_feature(  # type: ignore
            cartopy.feature.OCEAN, facecolor=ocean_color, zorder=0)
    else:
        ax.add_feature(cartopy.feature.OCEAN, zorder=0)  # type: ignore

    # add land
    ax.add_feature(  # type: ignore
        cartopy.feature.LAND, facecolor=land_color, edgecolor=land_edgecolor, zorder=0)

    # add borders
    if (borders_disable is False):
        ax.add_feature(  # type: ignore
            cartopy.feature.BORDERS, edgecolor=borders_color, zorder=0)

    # add polygon data
    #
    # NOTE: it seems that when running this function a second time, the polygon
    # data is not too happy. So to handle this, we plot a copy of the polygon data
    if isinstance(self.polygon_data, list):
        for polygon_data in self.polygon_data:
            ax.add_collection(copy(polygon_data))
    else:
        ax.add_collection(copy(self.polygon_data))

    if self.contour_data is not None:
        for i in range(len(self.contour_data[&#34;x&#34;])):
            ax.plot(self.contour_data[&#34;x&#34;][i],
                    self.contour_data[&#34;y&#34;][i],
                    color=self.contour_data[&#34;color&#34;][i],
                    linewidth=self.contour_data[&#34;linewidth&#34;][i],
                    linestyle=self.contour_data[&#34;linestyle&#34;][i],
                    marker=self.contour_data[&#34;marker&#34;][i],
                    zorder=self.contour_data[&#34;zorder&#34;][i])

    # set title
    if (title is not None):
        ax.set_title(title)

    # add text
    if (rayleighs is True):
        if isinstance(self.polygon_data, list):
            raise ValueError(&#34;Rayleighs Keyword is currently not available for mosaics with multiple sets of data.&#34;)

        # Create a colorbar, in Rayleighs, that accounts for the scaling limit we applied
        cbar_ticks = [float(j) / 5. for j in range(0, 6)]
        cbar_ticknames = [str(int(max_rayleighs / 5) * j) for j in range(0, 6)]

        # Any pixels with the max Rayleigh value could be greater than it, so we include the plus sign
        cbar_ticknames[-1] += &#34;+&#34;
        self.polygon_data.set_cmap(cbar_colormap)
        cbar = plt.colorbar(self.polygon_data, shrink=0.5, ticks=cbar_ticks, ax=ax)
        cbar.ax.set_yticklabels(cbar_ticknames)
        plt.text(1.025,
                 0.5,
                 &#34;Intensity (Rayleighs)&#34;,
                 fontsize=14,
                 transform=ax.transAxes,
                 va=&#34;center&#34;,
                 rotation=&#34;vertical&#34;,
                 weight=&#34;bold&#34;,
                 style=&#34;oblique&#34;)

    if (self.spect_cmap) is not None:

        if (self.spect_intensity_scale) is None:
            intensity_max = np.nan
            intensity_min = np.nan
        else:
            intensity_max = self.spect_intensity_scale[1]
            intensity_min = self.spect_intensity_scale[0]

        # Create a colorbar, in Rayleighs, that accounts for the scaling limit we applied
        cbar_ticks = [float(j) / 5. for j in range(0, 6)]
        cbar_ticknames = [str(int((intensity_max / 5) + intensity_min) * j) for j in range(0, 6)]

        # Any specrograph bins with the max intensity value could be greater than it, so we include the plus sign
        cbar_ticknames[-1] += &#34;+&#34;
        if isinstance(self.polygon_data, list):
            self.polygon_data[0].set_cmap(cbar_colormap)
        else:
            self.polygon_data.set_cmap(cbar_colormap)
        if isinstance(self.polygon_data, list):
            cbar = plt.colorbar(self.polygon_data[0], shrink=0.5, ticks=cbar_ticks, ax=ax)
        else:
            cbar = plt.colorbar(self.polygon_data, shrink=0.5, ticks=cbar_ticks, ax=ax)
        cbar.ax.set_yticklabels(cbar_ticknames)
        if (cbar_title is None):
            plt.text(1.025,
                     0.5,
                     &#34;Spectrograph Intensity (Rayleighs)&#34;,
                     fontsize=10,
                     transform=ax.transAxes,
                     va=&#34;center&#34;,
                     rotation=&#34;vertical&#34;,
                     weight=&#34;bold&#34;,
                     style=&#34;oblique&#34;)
        else:
            plt.text(1.025,
                     0.5,
                     cbar_title,
                     fontsize=10,
                     transform=ax.transAxes,
                     va=&#34;center&#34;,
                     rotation=&#34;vertical&#34;,
                     weight=&#34;bold&#34;,
                     style=&#34;oblique&#34;)

    # save figure or show it
    if (savefig is True):
        # check that filename has been set
        if (savefig_filename is None):
            raise ValueError(&#34;The savefig_filename parameter is missing, but required since savefig was set to True.&#34;)

        # save the figure
        f_extension = os.path.splitext(savefig_filename)[-1].lower()
        if (&#34;.jpg&#34; == f_extension or &#34;.jpeg&#34; == f_extension):
            # check quality setting
            if (savefig_quality is not None):
                plt.savefig(savefig_filename, quality=savefig_quality, bbox_inches=&#34;tight&#34;)
            else:
                plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)
        else:
            if (savefig_quality is not None):
                # quality specified, but output filename is not a JPG, so show a warning
                show_warning(&#34;The savefig_quality parameter was specified, but is only used for saving JPG files. The &#34; +
                             &#34;savefig_filename parameter was determined to not be a JPG file, so the quality will be ignored&#34;,
                             stacklevel=1)
            plt.savefig(savefig_filename, bbox_inches=&#34;tight&#34;)

        # clean up by closing the figure
        plt.close(fig)
    elif (returnfig is True):
        # return the figure and axis objects
        return (fig, ax)
    else:
        # show the figure
        plt.show(fig)

        # cleanup by closing the figure
        plt.close(fig)

    # return
    return None</code></pre>
</details>
<div class="desc"><p>Generate a plot of the mosaic data. </p>
<p>Either display it (default behaviour), save it to disk (using the <code>savefig</code> parameter), or
return the matplotlib plot object for further usage (using the <code>returnfig</code> parameter).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>map_extent</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>Latitude/longitude range to be visible on the rendered map. This is a list of 4 integers
and/or floats, in the order of [min_lon, max_lon, min_lat, max_lat].</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The matplotlib figure size to use when plotting. For example <code>figsize=(14,4)</code>.</dd>
<dt><strong><code>rayleighs</code></strong> :&ensp;<code>bool</code></dt>
<dd>Set to <code>True</code> if the data being plotted is in Rayleighs. Defaults to <code>False</code>.</dd>
<dt><strong><code>max_rayleighs</code></strong> :&ensp;<code>int</code></dt>
<dd>Max intensity scale for Rayleighs. Defaults to <code>20000</code>.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>The title to display above the plotted mosaic. Default is no title.</dd>
<dt><strong><code>ocean_color</code></strong> :&ensp;<code>str</code></dt>
<dd>Colour of the ocean. Default is cartopy's default shade of blue. Colours can be supplied
as a word, or hexcode prefixed with a '#' character (ie. <code>#55AADD</code>).</dd>
<dt><strong><code>land_color</code></strong> :&ensp;<code>str</code></dt>
<dd>Colour of the land. Default is <code>gray</code>. Colours can be supplied as a word, or hexcode
prefixed with a '#' character (ie. <code>#41BB87</code>).</dd>
<dt><strong><code>land_edgecolor</code></strong> :&ensp;<code>str</code></dt>
<dd>Color of the land edges. Default is <code>#8A8A8A</code>. Colours can be supplied as a word, or
hexcode prefixed with a '#' character.</dd>
<dt><strong><code>borders_color</code></strong> :&ensp;<code>str</code></dt>
<dd>Color of the country borders. Default is <code>AEAEAE</code>. Colours can be supplied as a word, or
hexcode prefixed with a '#' character.</dd>
<dt><strong><code>borders_disable</code></strong> :&ensp;<code>bool</code></dt>
<dd>Disbale rendering of the borders. Default is <code>False</code>.</dd>
<dt><strong><code>cbar_title</code></strong> :&ensp;<code>str</code></dt>
<dd>Title for the colorbar. Default is no title.</dd>
<dt><strong><code>colorbar_title</code></strong> :&ensp;<code>str</code></dt>
<dd>Deprecated as of v1.10.0. Use 'cbar_title' instead in the exact same way.</dd>
<dt><strong><code>cbar_colormap</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>The matplotlib colormap to use for the plotted color bar. Default is <code>gray</code>, unless
mosaic was created with spectrograph data, in which case defaults to the colormap
used for spectrograph data..</p>
<p>Commonly used colormaps are:</p>
<ul>
<li>REGO: <code>gist_heat</code></li>
<li>THEMIS ASI: <code>gray</code></li>
<li>TREx Blue: <code>Blues_r</code></li>
<li>TREx NIR: <code>gray</code></li>
<li>TREx RGB: <code>None</code></li>
</ul>
<p>A list of all available colormaps can be found on the
<a href="https://matplotlib.org/stable/gallery/color/colormap_reference.html">matplotlib documentation</a>.</p>
</dd>
<dt><strong><code>returnfig</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Instead of displaying the image, return the matplotlib figure object. This allows for further plot
manipulation, for example, adding labels or a title in a different location than the default. </p>
<p>Remember - if this parameter is supplied, be sure that you close your plot after finishing work
with it. This can be achieved by doing <code>plt.close(fig)</code>. </p>
<p>Note that this method cannot be used in combination with <code>savefig</code>.</p>
</dd>
<dt><strong><code>savefig</code></strong> :&ensp;<code>bool</code></dt>
<dd>Save the displayed image to disk instead of displaying it. The parameter savefig_filename is required if
this parameter is set to True. Defaults to <code>False</code>.</dd>
<dt><strong><code>savefig_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename to save the image to. Must be specified if the savefig parameter is set to True.</dd>
<dt><strong><code>savefig_quality</code></strong> :&ensp;<code>int</code></dt>
<dd>Quality level of the saved image. This can be specified if the savefig_filename is a JPG image. If it
is a PNG, quality is ignored. Default quality level for JPGs is matplotlib/Pillow's default of 75%.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The displayed montage, by default. If <code>savefig</code> is set to True, nothing will be returned. If <code>returnfig</code> is
set to True, the plotting variables <code>(fig, ax)</code> will be returned.
Raises:</p></div>
</dd>
<dt id="pyaurorax.tools.Mosaic.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print(self):
    &#34;&#34;&#34;
    A special print output for this class.
    &#34;&#34;&#34;
    # set special strings
    if isinstance(self.polygon_data, list):
        polycollection_str = &#34;[PolyCollection(...), ...]&#34;
    else:
        polycollection_str = &#34;PolyCollection(...)&#34;
    cartopy_projection_str = &#34;Projection(%s)&#34; % (self.cartopy_projection.to_string())
    if self.contour_data is not None:
        contour_data_str = &#34;%d Contours&#34; % (len(self.contour_data.get(&#34;x&#34;, [])), )
    else:
        contour_data_str = &#34;None&#34;

    # print
    print(&#34;Mosaic:&#34;)
    print(&#34;  %-23s: %s&#34; % (&#34;polygon_data&#34;, polycollection_str))
    print(&#34;  %-23s: %s&#34; % (&#34;cartopy_projection&#34;, cartopy_projection_str))
    print(&#34;  %-23s: %s&#34; % (&#34;contour_data&#34;, contour_data_str))
    print(&#34;  %-23s: %s&#34; % (&#34;spect_cmap&#34;, self.spect_cmap))
    print(&#34;  %-23s: %s&#34; % (&#34;spect_intensity_scale&#34;, self.spect_intensity_scale))</code></pre>
</details>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.tools.MosaicData"><code class="flex name class">
<span>class <span class="ident">MosaicData</span></span>
<span>(</span><span>site_uid_list: List[str],<br>timestamps: List[datetime.datetime],<br>images: Dict[str, numpy.ndarray],<br>images_dimensions: Dict[str, Tuple],<br>data_types: List[str])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class MosaicData:
    &#34;&#34;&#34;
    Prepared image data for use by mosaic routines.

    Attributes:
        site_uid_list (List[str]): 
            List of site unique identifiers contained within this object.

        timestamps (List[datetime.datetime]): 
            Timestamps of corresponding images.

        images (Dict[str, numpy.ndarray]): 
            Image data prepared into the necessary format; a dictionary. Keys are the site UID, 
            ndarray is the prepared data.

        images_dimensions (Dict[str, Tuple]): 
            The image dimensions.

        data_types (List[str]): 
            The data types for each data object.    
    &#34;&#34;&#34;

    site_uid_list: List[str]
    timestamps: List[datetime.datetime]
    images: Dict[str, ndarray]
    images_dimensions: Dict[str, Tuple]
    data_types: List[str]

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        # set special strings
        unique_dimensions_str = str(list(dict.fromkeys(self.images_dimensions.values()))).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;).replace(&#34;), (&#34;, &#34;),(&#34;)
        images_str = &#34;Dict[%d sites of array(dims=%s)]&#34; % (len(self.images.keys()), unique_dimensions_str)
        timestamps_str = &#34;[%d timestamps]&#34; % (len(self.timestamps))

        # return
        return &#34;MosaicData(images=%s, timestamps=%s, site_uid_list=%s)&#34; % (images_str, timestamps_str, self.site_uid_list.__repr__())

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;
        # set special strings
        unique_dimensions_str = str(list(dict.fromkeys(self.images_dimensions.values()))).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;).replace(&#34;), (&#34;, &#34;),(&#34;)
        images_str = &#34;Dict[%d sites of array(dims=%s)]&#34; % (len(self.images.keys()), unique_dimensions_str)
        timestamps_str = &#34;[%d timestamps]&#34; % (len(self.timestamps))

        # print
        print(&#34;MosaicData:&#34;)
        print(&#34;  %-19s: %s&#34; % (&#34;site_uid_list&#34;, self.site_uid_list))
        print(&#34;  %-19s: %s&#34; % (&#34;timestamps&#34;, timestamps_str))
        print(&#34;  %-19s: %s&#34; % (&#34;images&#34;, images_str))
        print(&#34;  %-19s: %s&#34; % (&#34;images_dimensions&#34;, self.images_dimensions))
        print(&#34;  %-19s: %s&#34; % (&#34;data_types&#34;, self.data_types))</code></pre>
</details>
<div class="desc"><p>Prepared image data for use by mosaic routines.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>site_uid_list</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of site unique identifiers contained within this object.</dd>
<dt><strong><code>timestamps</code></strong> :&ensp;<code>List[datetime.datetime]</code></dt>
<dd>Timestamps of corresponding images.</dd>
<dt><strong><code>images</code></strong> :&ensp;<code>Dict[str, numpy.ndarray]</code></dt>
<dd>Image data prepared into the necessary format; a dictionary. Keys are the site UID,
ndarray is the prepared data.</dd>
<dt><strong><code>images_dimensions</code></strong> :&ensp;<code>Dict[str, Tuple]</code></dt>
<dd>The image dimensions.</dd>
<dt><strong><code>data_types</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>The data types for each data object.</dd>
</dl></div>
<h3>Class variables</h3>
<dl>
<dt id="pyaurorax.tools.MosaicData.data_types"><code class="name">var <span class="ident">data_types</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.tools.MosaicData.images"><code class="name">var <span class="ident">images</span> : Dict[str, numpy.ndarray]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.tools.MosaicData.images_dimensions"><code class="name">var <span class="ident">images_dimensions</span> : Dict[str, Tuple]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.tools.MosaicData.site_uid_list"><code class="name">var <span class="ident">site_uid_list</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.tools.MosaicData.timestamps"><code class="name">var <span class="ident">timestamps</span> : List[datetime.datetime]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.tools.MosaicData.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print(self):
    &#34;&#34;&#34;
    A special print output for this class.
    &#34;&#34;&#34;
    # set special strings
    unique_dimensions_str = str(list(dict.fromkeys(self.images_dimensions.values()))).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;).replace(&#34;), (&#34;, &#34;),(&#34;)
    images_str = &#34;Dict[%d sites of array(dims=%s)]&#34; % (len(self.images.keys()), unique_dimensions_str)
    timestamps_str = &#34;[%d timestamps]&#34; % (len(self.timestamps))

    # print
    print(&#34;MosaicData:&#34;)
    print(&#34;  %-19s: %s&#34; % (&#34;site_uid_list&#34;, self.site_uid_list))
    print(&#34;  %-19s: %s&#34; % (&#34;timestamps&#34;, timestamps_str))
    print(&#34;  %-19s: %s&#34; % (&#34;images&#34;, images_str))
    print(&#34;  %-19s: %s&#34; % (&#34;images_dimensions&#34;, self.images_dimensions))
    print(&#34;  %-19s: %s&#34; % (&#34;data_types&#34;, self.data_types))</code></pre>
</details>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.tools.MosaicSkymap"><code class="flex name class">
<span>class <span class="ident">MosaicSkymap</span></span>
<span>(</span><span>site_uid_list: List[str],<br>elevation: List[numpy.ndarray],<br>polyfill_lat: List[numpy.ndarray],<br>polyfill_lon: List[numpy.ndarray])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class MosaicSkymap:
    &#34;&#34;&#34;
    Prepared skymap data for use by mosaic routines.

    Attributes:
        site_uid_list (List[str]): 
            List of site unique identifiers contained within this object.

        elevation (List[numpy.ndarray]): 
            List of elevation data, with each element corresponding to each site. Order 
            matches that of the `site_uid_list` attribute.

        polyfoll_lat (List[numpy.ndarray]): 
            List of latitude polygon data, with each element corresponding to each site. 
            Order matches that of the `site_uid_list` attribute. 

        polyfoll_lon (List[numpy.ndarray]): 
            List of longitude polygon data, with each element corresponding to each site. 
            Order matches that of the `site_uid_list` attribute. 

    &#34;&#34;&#34;

    site_uid_list: List[str]
    elevation: List[ndarray]
    polyfill_lat: List[ndarray]
    polyfill_lon: List[ndarray]

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        # set special strings
        unique_polyfill_lat_dims = str(list(dict.fromkeys(fill_arr.shape
                                                          for fill_arr in self.polyfill_lat))).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;,
                                                                                                                        &#34;&#34;).replace(&#34;), (&#34;, &#34;),(&#34;)
        unique_polyfill_lon_dims = str(list(dict.fromkeys(fill_arr.shape
                                                          for fill_arr in self.polyfill_lon))).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;,
                                                                                                                        &#34;&#34;).replace(&#34;), (&#34;, &#34;),(&#34;)
        unique_elevation_dims = str(list(dict.fromkeys(el.shape for el in self.elevation))).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;).replace(&#34;), (&#34;, &#34;),(&#34;)

        polyfill_lat_str = &#34;array(dims=%s, dtype=%s)&#34; % (unique_polyfill_lat_dims, self.polyfill_lat[0].dtype)
        polyfill_lon_str = &#34;array(dims=%s, dtype=%s)&#34; % (unique_polyfill_lon_dims, self.polyfill_lon[0].dtype)
        elevation_str = &#34;array(dims=%s, dtype=%s)&#34; % (unique_elevation_dims, self.elevation[0].dtype)

        # return
        return &#34;MosaicSkymap(polyfill_lat=%s, polyfill_lon=%s, elevation=%s, site_uid_list=%s)&#34; % (
            polyfill_lat_str,
            polyfill_lon_str,
            elevation_str,
            self.site_uid_list.__repr__(),
        )

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;
        unique_polyfill_lat_dims = str(list(dict.fromkeys(fill_arr.shape
                                                          for fill_arr in self.polyfill_lat))).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;,
                                                                                                                        &#34;&#34;).replace(&#34;), (&#34;, &#34;),(&#34;)
        unique_polyfill_lon_dims = str(list(dict.fromkeys(fill_arr.shape
                                                          for fill_arr in self.polyfill_lon))).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;,
                                                                                                                        &#34;&#34;).replace(&#34;), (&#34;, &#34;),(&#34;)
        unique_elevation_dims = str(list(dict.fromkeys(el.shape for el in self.elevation))).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;).replace(&#34;), (&#34;, &#34;),(&#34;)

        polyfill_lat_str = &#34;array(dims=%s, dtype=%s)&#34; % (unique_polyfill_lat_dims, self.polyfill_lat[0].dtype)
        polyfill_lon_str = &#34;array(dims=%s, dtype=%s)&#34; % (unique_polyfill_lon_dims, self.polyfill_lon[0].dtype)
        elevation_str = &#34;array(dims=%s, dtype=%s)&#34; % (unique_elevation_dims, self.elevation[0].dtype)

        # print
        print(&#34;MosaicSkymap:&#34;)
        print(&#34;  %-15s: %s&#34; % (&#34;polyfill_lat&#34;, polyfill_lat_str))
        print(&#34;  %-15s: %s&#34; % (&#34;polyfill_lon&#34;, polyfill_lon_str))
        print(&#34;  %-15s: %s&#34; % (&#34;elevation&#34;, elevation_str))
        print(&#34;  %-15s: %s&#34; % (&#34;site_uid_list&#34;, self.site_uid_list))</code></pre>
</details>
<div class="desc"><p>Prepared skymap data for use by mosaic routines.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>site_uid_list</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of site unique identifiers contained within this object.</dd>
<dt><strong><code>elevation</code></strong> :&ensp;<code>List[numpy.ndarray]</code></dt>
<dd>List of elevation data, with each element corresponding to each site. Order
matches that of the <code>site_uid_list</code> attribute.</dd>
<dt><strong><code>polyfoll_lat</code></strong> :&ensp;<code>List[numpy.ndarray]</code></dt>
<dd>List of latitude polygon data, with each element corresponding to each site.
Order matches that of the <code>site_uid_list</code> attribute. </dd>
<dt><strong><code>polyfoll_lon</code></strong> :&ensp;<code>List[numpy.ndarray]</code></dt>
<dd>List of longitude polygon data, with each element corresponding to each site.
Order matches that of the <code>site_uid_list</code> attribute.</dd>
</dl></div>
<h3>Class variables</h3>
<dl>
<dt id="pyaurorax.tools.MosaicSkymap.elevation"><code class="name">var <span class="ident">elevation</span> : List[numpy.ndarray]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.tools.MosaicSkymap.polyfill_lat"><code class="name">var <span class="ident">polyfill_lat</span> : List[numpy.ndarray]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.tools.MosaicSkymap.polyfill_lon"><code class="name">var <span class="ident">polyfill_lon</span> : List[numpy.ndarray]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.tools.MosaicSkymap.site_uid_list"><code class="name">var <span class="ident">site_uid_list</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.tools.MosaicSkymap.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print(self):
    &#34;&#34;&#34;
    A special print output for this class.
    &#34;&#34;&#34;
    unique_polyfill_lat_dims = str(list(dict.fromkeys(fill_arr.shape
                                                      for fill_arr in self.polyfill_lat))).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;,
                                                                                                                    &#34;&#34;).replace(&#34;), (&#34;, &#34;),(&#34;)
    unique_polyfill_lon_dims = str(list(dict.fromkeys(fill_arr.shape
                                                      for fill_arr in self.polyfill_lon))).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;,
                                                                                                                    &#34;&#34;).replace(&#34;), (&#34;, &#34;),(&#34;)
    unique_elevation_dims = str(list(dict.fromkeys(el.shape for el in self.elevation))).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;).replace(&#34;), (&#34;, &#34;),(&#34;)

    polyfill_lat_str = &#34;array(dims=%s, dtype=%s)&#34; % (unique_polyfill_lat_dims, self.polyfill_lat[0].dtype)
    polyfill_lon_str = &#34;array(dims=%s, dtype=%s)&#34; % (unique_polyfill_lon_dims, self.polyfill_lon[0].dtype)
    elevation_str = &#34;array(dims=%s, dtype=%s)&#34; % (unique_elevation_dims, self.elevation[0].dtype)

    # print
    print(&#34;MosaicSkymap:&#34;)
    print(&#34;  %-15s: %s&#34; % (&#34;polyfill_lat&#34;, polyfill_lat_str))
    print(&#34;  %-15s: %s&#34; % (&#34;polyfill_lon&#34;, polyfill_lon_str))
    print(&#34;  %-15s: %s&#34; % (&#34;elevation&#34;, elevation_str))
    print(&#34;  %-15s: %s&#34; % (&#34;site_uid_list&#34;, self.site_uid_list))</code></pre>
</details>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.tools.ToolsManager"><code class="flex name class">
<span>class <span class="ident">ToolsManager</span></span>
<span>(</span><span>aurorax_obj)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ToolsManager:
    &#34;&#34;&#34;
    The ToolsManager object is initialized within every PyAuroraX object. It acts as a way to access 
    the submodules and carry over configuration information in the super class.
    &#34;&#34;&#34;

    def __init__(self, aurorax_obj):
        self.__aurorax_obj = aurorax_obj

        # initialize sub-modules
        self.__bounding_box = BoundingBoxManager(self.__aurorax_obj)
        self.__calibration = CalibrationManager()
        self.__ccd_contour = CCDContourManager()
        self.__grid_files = GridFilesManager(self.__aurorax_obj)
        self.__keogram = KeogramManager()
        self.__montage = MontageManager()
        self.__mosaic = MosaicManager(self.__aurorax_obj)
        self.__spectra = SpectraManager()

    # ------------------------------------------
    # properties for submodule managers
    # ------------------------------------------
    @property
    def bounding_box(self):
        &#34;&#34;&#34;
        Access to the `bounding_box` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__bounding_box

    @property
    def calibration(self):
        &#34;&#34;&#34;
        Access to the `calibration` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__calibration

    @property
    def ccd_contour(self):
        &#34;&#34;&#34;
        Access to the `ccd_contour` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__ccd_contour

    @property
    def grid_files(self):
        &#34;&#34;&#34;
        Access to the `grid_files` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__grid_files

    @property
    def keogram(self):
        &#34;&#34;&#34;
        Access to the `keogram` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__keogram

    @property
    def montage(self):
        &#34;&#34;&#34;
        Access to the `montage` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__montage

    @property
    def mosaic(self):
        &#34;&#34;&#34;
        Access to the `mosaic` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__mosaic

    @property
    def spectra(self):
        &#34;&#34;&#34;
        Access to the `spectra` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__spectra

    # ------------------------------------------
    # functions available at this manager level
    # ------------------------------------------
    def display(self,
                image: np.ndarray,
                cmap: Optional[str] = None,
                figsize: Optional[Tuple[int, int]] = None,
                aspect: Optional[Union[Literal[&#34;equal&#34;, &#34;auto&#34;], float]] = None,
                colorbar: bool = False,
                title: Optional[str] = None,
                returnfig: bool = False,
                savefig: bool = False,
                savefig_filename: Optional[str] = None,
                savefig_quality: Optional[int] = None) -&gt; Any:
        &#34;&#34;&#34;
        Render a visualization of a single image.

        Either display it (default behaviour), save it to disk (using the `savefig` parameter), or 
        return the matplotlib plot object for further usage (using the `returnfig` parameter).

        Args:
            image (numpy.ndarray): 
                The image to display, represented as a numpy array.

            cmap (str): 
                The matplotlib colormap to use.

                Commonly used colormaps are:

                - REGO: `gist_heat`
                - THEMIS ASI: `gray`
                - TREx Blue: `Blues_r`
                - TREx NIR: `gray`
                - TREx RGB: `None`

                A list of all available colormaps can be found on the 
                [matplotlib documentation](https://matplotlib.org/stable/gallery/color/colormap_reference.html).

            figsize (tuple): 
                The matplotlib figure size to use when displaying, tuple of two integers (ie. `figsize=(14, 4)`)
        
            aspect (str or float): 
                The matplotlib imshow aspect ration to use. A common value for this is `auto`. All valid values 
                can be found on the [matplotlib documentation](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html).

            colorbar (bool): 
                Display a colorbar. Default is `False`.

            title (str): 
                A title to display above the rendered image. Defaults to no title.

            returnfig (bool): 
                Instead of displaying the image, return the matplotlib figure object. This allows for further plot 
                manipulation, for example, adding labels or a title in a different location than the default. 
                
                Remember - if this parameter is supplied, be sure that you close your plot after finishing work 
                with it. This can be achieved by doing `plt.close(fig)`. 
                
                Note that this method cannot be used in combination with `savefig`.

            savefig (bool): 
                Save the displayed image to disk instead of displaying it. The parameter savefig_filename is required if 
                this parameter is set to True. Defaults to `False`.

            savefig_filename (str): 
                Filename to save the image to. Must be specified if the savefig parameter is set to True.

            savefig_quality (int): 
                Quality level of the saved image. This can be specified if the savefig_filename is a JPG image. If it
                is a PNG, quality is ignored. Default quality level for JPGs is matplotlib/Pillow&#39;s default of 75%.

        Returns:
            The displayed image, by default. If `savefig` is set to True, nothing will be returned. If `returnfig` is 
            set to True, the plotting variables `(fig, ax)` will be returned.

        Raises:
            ValueError: issues encountered with supplied parameters.
        &#34;&#34;&#34;
        return func_display(image, cmap, figsize, aspect, colorbar, title, returnfig, savefig, savefig_filename, savefig_quality)

    def movie(
        self,
        input_filenames: List[str],
        output_filename: str,
        n_parallel: int = 1,
        fps: int = 25,
        progress_bar_disable: bool = False,
    ) -&gt; None:
        &#34;&#34;&#34;
        Generate a movie file from a list of filenames. Note that the codec used is &#34;mp4v&#34;.

        Args:
            input_filenames (List[str]): 
                Filenames of frames to use for movie generation. No sorting is applied, so it is 
                assumed the list is in the desired order. This parameter is required.
            
            output_filename (str): 
                Filename for the created movie file. This parameter is required.

            n_parallel (int): 
                Number of multiprocessing workers to use. Default is `1`, which does not use
                multiprocessing.

            fps (int): 
                Frames per second (FPS) for the movie file. Default is `25`.

            progress_bar_disable (bool): 
                Toggle the progress bars off. Default is `False`.        

        Raises:
            IOError: I/O related issue while generating movie
        &#34;&#34;&#34;
        return func_movie(self.__aurorax_obj, input_filenames, output_filename, n_parallel, fps, progress_bar_disable)

    def scale_intensity(
        self,
        data: np.ndarray,
        min: Optional[float] = None,
        max: Optional[float] = None,
        top: Optional[float] = None,
        memory_saver: bool = True,
    ) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Scale all values of an array that lie in the range min&lt;=x&lt;=max in to 
        the range 0&lt;=x&lt;=high.
        
        Args:
            data (numpy.ndarray): 
                Data array, can be 2, 3, or 4-dimensional. Assumed to be an image, or array of 
                images. Also assumed that the first 2 dimensions are the image&#39;s x and y 
                coordinates, and the following dimensions are some combination of the number of 
                images, and/or the colour channel.

            min (float): 
                Minimum value of array to be considered

            max (float): 
                Maximum value of array to be considered

            top (float): 
                Maximum value of the scaled result. If not supplied, the max value
                of the data array&#39;s dtype is used.

            memory_saver (bool): 
                Utilize less RAM when scaling a set of images. Defaults to `True`. If set to `False` then
                the scaling routine will be faster, but will utilize significantly more RAM.

        Returns:
            A new `numpy.ndarray` that is the same dimensions as the inputted data array, 
            with the scaling applied.

        Raises:
            ValueError: issues encountered with supplied min, max, or top value(s)
        &#34;&#34;&#34;
        return func_scale_intensity(data, min, max, top, memory_saver)

    def set_theme(self, theme: str) -&gt; None:
        &#34;&#34;&#34;
        A handy wrapper for setting the matplotlib global theme. Common choices are `light`, 
        `dark`, or `default`.

        Args:
            theme (str): 
                Theme name. Common choices are `light`, `dark`, or `default`. If default, then
                matplotlib theme settings will be fully reset to their defaults.

                Additional themes can be found on the 
                [matplotlib documentation](https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html)
        &#34;&#34;&#34;
        return func_set_theme(theme)</code></pre>
</details>
<div class="desc"><p>The ToolsManager object is initialized within every PyAuroraX object. It acts as a way to access
the submodules and carry over configuration information in the super class.</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="pyaurorax.tools.ToolsManager.bounding_box"><code class="name">prop <span class="ident">bounding_box</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounding_box(self):
    &#34;&#34;&#34;
    Access to the `bounding_box` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__bounding_box</code></pre>
</details>
<div class="desc"><p>Access to the <code><a title="pyaurorax.tools.bounding_box" href="bounding_box/index.html">pyaurorax.tools.bounding_box</a></code> submodule from within a PyAuroraX object.</p></div>
</dd>
<dt id="pyaurorax.tools.ToolsManager.calibration"><code class="name">prop <span class="ident">calibration</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def calibration(self):
    &#34;&#34;&#34;
    Access to the `calibration` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__calibration</code></pre>
</details>
<div class="desc"><p>Access to the <code><a title="pyaurorax.tools.calibration" href="calibration/index.html">pyaurorax.tools.calibration</a></code> submodule from within a PyAuroraX object.</p></div>
</dd>
<dt id="pyaurorax.tools.ToolsManager.ccd_contour"><code class="name">prop <span class="ident">ccd_contour</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ccd_contour(self):
    &#34;&#34;&#34;
    Access to the `ccd_contour` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__ccd_contour</code></pre>
</details>
<div class="desc"><p>Access to the <code><a title="pyaurorax.tools.ccd_contour" href="ccd_contour/index.html">pyaurorax.tools.ccd_contour</a></code> submodule from within a PyAuroraX object.</p></div>
</dd>
<dt id="pyaurorax.tools.ToolsManager.grid_files"><code class="name">prop <span class="ident">grid_files</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def grid_files(self):
    &#34;&#34;&#34;
    Access to the `grid_files` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__grid_files</code></pre>
</details>
<div class="desc"><p>Access to the <code><a title="pyaurorax.tools.grid_files" href="grid_files/index.html">pyaurorax.tools.grid_files</a></code> submodule from within a PyAuroraX object.</p></div>
</dd>
<dt id="pyaurorax.tools.ToolsManager.keogram"><code class="name">prop <span class="ident">keogram</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def keogram(self):
    &#34;&#34;&#34;
    Access to the `keogram` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__keogram</code></pre>
</details>
<div class="desc"><p>Access to the <code><a title="pyaurorax.tools.keogram" href="keogram/index.html">pyaurorax.tools.keogram</a></code> submodule from within a PyAuroraX object.</p></div>
</dd>
<dt id="pyaurorax.tools.ToolsManager.montage"><code class="name">prop <span class="ident">montage</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def montage(self):
    &#34;&#34;&#34;
    Access to the `montage` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__montage</code></pre>
</details>
<div class="desc"><p>Access to the <code><a title="pyaurorax.tools.montage" href="montage/index.html">pyaurorax.tools.montage</a></code> submodule from within a PyAuroraX object.</p></div>
</dd>
<dt id="pyaurorax.tools.ToolsManager.mosaic"><code class="name">prop <span class="ident">mosaic</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mosaic(self):
    &#34;&#34;&#34;
    Access to the `mosaic` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__mosaic</code></pre>
</details>
<div class="desc"><p>Access to the <code><a title="pyaurorax.tools.mosaic" href="mosaic/index.html">pyaurorax.tools.mosaic</a></code> submodule from within a PyAuroraX object.</p></div>
</dd>
<dt id="pyaurorax.tools.ToolsManager.spectra"><code class="name">prop <span class="ident">spectra</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spectra(self):
    &#34;&#34;&#34;
    Access to the `spectra` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__spectra</code></pre>
</details>
<div class="desc"><p>Access to the <code><a title="pyaurorax.tools.spectra" href="spectra/index.html">pyaurorax.tools.spectra</a></code> submodule from within a PyAuroraX object.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.tools.ToolsManager.display"><code class="name flex">
<span>def <span class="ident">display</span></span>(<span>self,<br>image: numpy.ndarray,<br>cmap: str | None = None,<br>figsize: Tuple[int, int] | None = None,<br>aspect: Literal['equal', 'auto'] | float | None = None,<br>colorbar: bool = False,<br>title: str | None = None,<br>returnfig: bool = False,<br>savefig: bool = False,<br>savefig_filename: str | None = None,<br>savefig_quality: int | None = None) ‑> Any</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display(self,
            image: np.ndarray,
            cmap: Optional[str] = None,
            figsize: Optional[Tuple[int, int]] = None,
            aspect: Optional[Union[Literal[&#34;equal&#34;, &#34;auto&#34;], float]] = None,
            colorbar: bool = False,
            title: Optional[str] = None,
            returnfig: bool = False,
            savefig: bool = False,
            savefig_filename: Optional[str] = None,
            savefig_quality: Optional[int] = None) -&gt; Any:
    &#34;&#34;&#34;
    Render a visualization of a single image.

    Either display it (default behaviour), save it to disk (using the `savefig` parameter), or 
    return the matplotlib plot object for further usage (using the `returnfig` parameter).

    Args:
        image (numpy.ndarray): 
            The image to display, represented as a numpy array.

        cmap (str): 
            The matplotlib colormap to use.

            Commonly used colormaps are:

            - REGO: `gist_heat`
            - THEMIS ASI: `gray`
            - TREx Blue: `Blues_r`
            - TREx NIR: `gray`
            - TREx RGB: `None`

            A list of all available colormaps can be found on the 
            [matplotlib documentation](https://matplotlib.org/stable/gallery/color/colormap_reference.html).

        figsize (tuple): 
            The matplotlib figure size to use when displaying, tuple of two integers (ie. `figsize=(14, 4)`)
    
        aspect (str or float): 
            The matplotlib imshow aspect ration to use. A common value for this is `auto`. All valid values 
            can be found on the [matplotlib documentation](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html).

        colorbar (bool): 
            Display a colorbar. Default is `False`.

        title (str): 
            A title to display above the rendered image. Defaults to no title.

        returnfig (bool): 
            Instead of displaying the image, return the matplotlib figure object. This allows for further plot 
            manipulation, for example, adding labels or a title in a different location than the default. 
            
            Remember - if this parameter is supplied, be sure that you close your plot after finishing work 
            with it. This can be achieved by doing `plt.close(fig)`. 
            
            Note that this method cannot be used in combination with `savefig`.

        savefig (bool): 
            Save the displayed image to disk instead of displaying it. The parameter savefig_filename is required if 
            this parameter is set to True. Defaults to `False`.

        savefig_filename (str): 
            Filename to save the image to. Must be specified if the savefig parameter is set to True.

        savefig_quality (int): 
            Quality level of the saved image. This can be specified if the savefig_filename is a JPG image. If it
            is a PNG, quality is ignored. Default quality level for JPGs is matplotlib/Pillow&#39;s default of 75%.

    Returns:
        The displayed image, by default. If `savefig` is set to True, nothing will be returned. If `returnfig` is 
        set to True, the plotting variables `(fig, ax)` will be returned.

    Raises:
        ValueError: issues encountered with supplied parameters.
    &#34;&#34;&#34;
    return func_display(image, cmap, figsize, aspect, colorbar, title, returnfig, savefig, savefig_filename, savefig_quality)</code></pre>
</details>
<div class="desc"><p>Render a visualization of a single image.</p>
<p>Either display it (default behaviour), save it to disk (using the <code>savefig</code> parameter), or
return the matplotlib plot object for further usage (using the <code>returnfig</code> parameter).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>The image to display, represented as a numpy array.</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>The matplotlib colormap to use.</p>
<p>Commonly used colormaps are:</p>
<ul>
<li>REGO: <code>gist_heat</code></li>
<li>THEMIS ASI: <code>gray</code></li>
<li>TREx Blue: <code>Blues_r</code></li>
<li>TREx NIR: <code>gray</code></li>
<li>TREx RGB: <code>None</code></li>
</ul>
<p>A list of all available colormaps can be found on the
<a href="https://matplotlib.org/stable/gallery/color/colormap_reference.html">matplotlib documentation</a>.</p>
</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The matplotlib figure size to use when displaying, tuple of two integers (ie. <code>figsize=(14, 4)</code>)</dd>
<dt><strong><code>aspect</code></strong> :&ensp;<code>str</code> or <code>float</code></dt>
<dd>The matplotlib imshow aspect ration to use. A common value for this is <code>auto</code>. All valid values
can be found on the <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.imshow.html">matplotlib documentation</a>.</dd>
<dt><strong><code>colorbar</code></strong> :&ensp;<code>bool</code></dt>
<dd>Display a colorbar. Default is <code>False</code>.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>A title to display above the rendered image. Defaults to no title.</dd>
<dt><strong><code>returnfig</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Instead of displaying the image, return the matplotlib figure object. This allows for further plot
manipulation, for example, adding labels or a title in a different location than the default. </p>
<p>Remember - if this parameter is supplied, be sure that you close your plot after finishing work
with it. This can be achieved by doing <code>plt.close(fig)</code>. </p>
<p>Note that this method cannot be used in combination with <code>savefig</code>.</p>
</dd>
<dt><strong><code>savefig</code></strong> :&ensp;<code>bool</code></dt>
<dd>Save the displayed image to disk instead of displaying it. The parameter savefig_filename is required if
this parameter is set to True. Defaults to <code>False</code>.</dd>
<dt><strong><code>savefig_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename to save the image to. Must be specified if the savefig parameter is set to True.</dd>
<dt><strong><code>savefig_quality</code></strong> :&ensp;<code>int</code></dt>
<dd>Quality level of the saved image. This can be specified if the savefig_filename is a JPG image. If it
is a PNG, quality is ignored. Default quality level for JPGs is matplotlib/Pillow's default of 75%.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The displayed image, by default. If <code>savefig</code> is set to True, nothing will be returned. If <code>returnfig</code> is
set to True, the plotting variables <code>(fig, ax)</code> will be returned.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>issues encountered with supplied parameters.</dd>
</dl></div>
</dd>
<dt id="pyaurorax.tools.ToolsManager.movie"><code class="name flex">
<span>def <span class="ident">movie</span></span>(<span>self,<br>input_filenames: List[str],<br>output_filename: str,<br>n_parallel: int = 1,<br>fps: int = 25,<br>progress_bar_disable: bool = False) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def movie(
    self,
    input_filenames: List[str],
    output_filename: str,
    n_parallel: int = 1,
    fps: int = 25,
    progress_bar_disable: bool = False,
) -&gt; None:
    &#34;&#34;&#34;
    Generate a movie file from a list of filenames. Note that the codec used is &#34;mp4v&#34;.

    Args:
        input_filenames (List[str]): 
            Filenames of frames to use for movie generation. No sorting is applied, so it is 
            assumed the list is in the desired order. This parameter is required.
        
        output_filename (str): 
            Filename for the created movie file. This parameter is required.

        n_parallel (int): 
            Number of multiprocessing workers to use. Default is `1`, which does not use
            multiprocessing.

        fps (int): 
            Frames per second (FPS) for the movie file. Default is `25`.

        progress_bar_disable (bool): 
            Toggle the progress bars off. Default is `False`.        

    Raises:
        IOError: I/O related issue while generating movie
    &#34;&#34;&#34;
    return func_movie(self.__aurorax_obj, input_filenames, output_filename, n_parallel, fps, progress_bar_disable)</code></pre>
</details>
<div class="desc"><p>Generate a movie file from a list of filenames. Note that the codec used is "mp4v".</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_filenames</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>Filenames of frames to use for movie generation. No sorting is applied, so it is
assumed the list is in the desired order. This parameter is required.</dd>
<dt><strong><code>output_filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename for the created movie file. This parameter is required.</dd>
<dt><strong><code>n_parallel</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of multiprocessing workers to use. Default is <code>1</code>, which does not use
multiprocessing.</dd>
<dt><strong><code>fps</code></strong> :&ensp;<code>int</code></dt>
<dd>Frames per second (FPS) for the movie file. Default is <code>25</code>.</dd>
<dt><strong><code>progress_bar_disable</code></strong> :&ensp;<code>bool</code></dt>
<dd>Toggle the progress bars off. Default is <code>False</code>.
</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>IOError</code></dt>
<dd>I/O related issue while generating movie</dd>
</dl></div>
</dd>
<dt id="pyaurorax.tools.ToolsManager.scale_intensity"><code class="name flex">
<span>def <span class="ident">scale_intensity</span></span>(<span>self,<br>data: numpy.ndarray,<br>min: float | None = None,<br>max: float | None = None,<br>top: float | None = None,<br>memory_saver: bool = True) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale_intensity(
    self,
    data: np.ndarray,
    min: Optional[float] = None,
    max: Optional[float] = None,
    top: Optional[float] = None,
    memory_saver: bool = True,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Scale all values of an array that lie in the range min&lt;=x&lt;=max in to 
    the range 0&lt;=x&lt;=high.
    
    Args:
        data (numpy.ndarray): 
            Data array, can be 2, 3, or 4-dimensional. Assumed to be an image, or array of 
            images. Also assumed that the first 2 dimensions are the image&#39;s x and y 
            coordinates, and the following dimensions are some combination of the number of 
            images, and/or the colour channel.

        min (float): 
            Minimum value of array to be considered

        max (float): 
            Maximum value of array to be considered

        top (float): 
            Maximum value of the scaled result. If not supplied, the max value
            of the data array&#39;s dtype is used.

        memory_saver (bool): 
            Utilize less RAM when scaling a set of images. Defaults to `True`. If set to `False` then
            the scaling routine will be faster, but will utilize significantly more RAM.

    Returns:
        A new `numpy.ndarray` that is the same dimensions as the inputted data array, 
        with the scaling applied.

    Raises:
        ValueError: issues encountered with supplied min, max, or top value(s)
    &#34;&#34;&#34;
    return func_scale_intensity(data, min, max, top, memory_saver)</code></pre>
</details>
<div class="desc"><p>Scale all values of an array that lie in the range min&lt;=x&lt;=max in to
the range 0&lt;=x&lt;=high.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Data array, can be 2, 3, or 4-dimensional. Assumed to be an image, or array of
images. Also assumed that the first 2 dimensions are the image's x and y
coordinates, and the following dimensions are some combination of the number of
images, and/or the colour channel.</dd>
<dt><strong><code>min</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum value of array to be considered</dd>
<dt><strong><code>max</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum value of array to be considered</dd>
<dt><strong><code>top</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum value of the scaled result. If not supplied, the max value
of the data array's dtype is used.</dd>
<dt><strong><code>memory_saver</code></strong> :&ensp;<code>bool</code></dt>
<dd>Utilize less RAM when scaling a set of images. Defaults to <code>True</code>. If set to <code>False</code> then
the scaling routine will be faster, but will utilize significantly more RAM.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new <code>numpy.ndarray</code> that is the same dimensions as the inputted data array,
with the scaling applied.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>issues encountered with supplied min, max, or top value(s)</dd>
</dl></div>
</dd>
<dt id="pyaurorax.tools.ToolsManager.set_theme"><code class="name flex">
<span>def <span class="ident">set_theme</span></span>(<span>self, theme: str) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_theme(self, theme: str) -&gt; None:
    &#34;&#34;&#34;
    A handy wrapper for setting the matplotlib global theme. Common choices are `light`, 
    `dark`, or `default`.

    Args:
        theme (str): 
            Theme name. Common choices are `light`, `dark`, or `default`. If default, then
            matplotlib theme settings will be fully reset to their defaults.

            Additional themes can be found on the 
            [matplotlib documentation](https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html)
    &#34;&#34;&#34;
    return func_set_theme(theme)</code></pre>
</details>
<div class="desc"><p>A handy wrapper for setting the matplotlib global theme. Common choices are <code>light</code>,
<code>dark</code>, or <code>default</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>theme</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Theme name. Common choices are <code>light</code>, <code>dark</code>, or <code>default</code>. If default, then
matplotlib theme settings will be fully reset to their defaults.</p>
<p>Additional themes can be found on the
<a href="https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html">matplotlib documentation</a></p>
</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.css" integrity="sha512-b+T2i3P45i1LZM7I00Ci5QquB9szqaxu+uuk5TUSGjZQ4w4n+qujQiIuvTv2BxE7WCGQCifNMksyKILDiHzsOg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.js" integrity="sha512-2B9/byNV1KKRm5nQ2RLViPFD6U4dUjDGwuW1GU+ImJh8YinPU9Zlq1GzdTMO+G2ROrB5o1qasJBy1ttYz0wCug==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyaurorax" href="../index.html">pyaurorax</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pyaurorax.tools.bounding_box" href="bounding_box/index.html">pyaurorax.tools.bounding_box</a></code></li>
<li><code><a title="pyaurorax.tools.calibration" href="calibration/index.html">pyaurorax.tools.calibration</a></code></li>
<li><code><a title="pyaurorax.tools.ccd_contour" href="ccd_contour/index.html">pyaurorax.tools.ccd_contour</a></code></li>
<li><code><a title="pyaurorax.tools.classes" href="classes/index.html">pyaurorax.tools.classes</a></code></li>
<li><code><a title="pyaurorax.tools.grid_files" href="grid_files/index.html">pyaurorax.tools.grid_files</a></code></li>
<li><code><a title="pyaurorax.tools.keogram" href="keogram/index.html">pyaurorax.tools.keogram</a></code></li>
<li><code><a title="pyaurorax.tools.montage" href="montage/index.html">pyaurorax.tools.montage</a></code></li>
<li><code><a title="pyaurorax.tools.mosaic" href="mosaic/index.html">pyaurorax.tools.mosaic</a></code></li>
<li><code><a title="pyaurorax.tools.spectra" href="spectra/index.html">pyaurorax.tools.spectra</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyaurorax.tools.Keogram" href="#pyaurorax.tools.Keogram">Keogram</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.tools.Keogram.plot" href="#pyaurorax.tools.Keogram.plot">plot</a></code></li>
<li><code><a title="pyaurorax.tools.Keogram.pretty_print" href="#pyaurorax.tools.Keogram.pretty_print">pretty_print</a></code></li>
<li><code><a title="pyaurorax.tools.Keogram.set_geographic_latitudes" href="#pyaurorax.tools.Keogram.set_geographic_latitudes">set_geographic_latitudes</a></code></li>
<li><code><a title="pyaurorax.tools.Keogram.set_magnetic_latitudes" href="#pyaurorax.tools.Keogram.set_magnetic_latitudes">set_magnetic_latitudes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.tools.Montage" href="#pyaurorax.tools.Montage">Montage</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.tools.Montage.plot" href="#pyaurorax.tools.Montage.plot">plot</a></code></li>
<li><code><a title="pyaurorax.tools.Montage.pretty_print" href="#pyaurorax.tools.Montage.pretty_print">pretty_print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.tools.Mosaic" href="#pyaurorax.tools.Mosaic">Mosaic</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.tools.Mosaic.add_geo_contours" href="#pyaurorax.tools.Mosaic.add_geo_contours">add_geo_contours</a></code></li>
<li><code><a title="pyaurorax.tools.Mosaic.add_mag_contours" href="#pyaurorax.tools.Mosaic.add_mag_contours">add_mag_contours</a></code></li>
<li><code><a title="pyaurorax.tools.Mosaic.cartopy_projection" href="#pyaurorax.tools.Mosaic.cartopy_projection">cartopy_projection</a></code></li>
<li><code><a title="pyaurorax.tools.Mosaic.contour_data" href="#pyaurorax.tools.Mosaic.contour_data">contour_data</a></code></li>
<li><code><a title="pyaurorax.tools.Mosaic.plot" href="#pyaurorax.tools.Mosaic.plot">plot</a></code></li>
<li><code><a title="pyaurorax.tools.Mosaic.polygon_data" href="#pyaurorax.tools.Mosaic.polygon_data">polygon_data</a></code></li>
<li><code><a title="pyaurorax.tools.Mosaic.pretty_print" href="#pyaurorax.tools.Mosaic.pretty_print">pretty_print</a></code></li>
<li><code><a title="pyaurorax.tools.Mosaic.spect_cmap" href="#pyaurorax.tools.Mosaic.spect_cmap">spect_cmap</a></code></li>
<li><code><a title="pyaurorax.tools.Mosaic.spect_intensity_scale" href="#pyaurorax.tools.Mosaic.spect_intensity_scale">spect_intensity_scale</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.tools.MosaicData" href="#pyaurorax.tools.MosaicData">MosaicData</a></code></h4>
<ul class="two-column">
<li><code><a title="pyaurorax.tools.MosaicData.data_types" href="#pyaurorax.tools.MosaicData.data_types">data_types</a></code></li>
<li><code><a title="pyaurorax.tools.MosaicData.images" href="#pyaurorax.tools.MosaicData.images">images</a></code></li>
<li><code><a title="pyaurorax.tools.MosaicData.images_dimensions" href="#pyaurorax.tools.MosaicData.images_dimensions">images_dimensions</a></code></li>
<li><code><a title="pyaurorax.tools.MosaicData.pretty_print" href="#pyaurorax.tools.MosaicData.pretty_print">pretty_print</a></code></li>
<li><code><a title="pyaurorax.tools.MosaicData.site_uid_list" href="#pyaurorax.tools.MosaicData.site_uid_list">site_uid_list</a></code></li>
<li><code><a title="pyaurorax.tools.MosaicData.timestamps" href="#pyaurorax.tools.MosaicData.timestamps">timestamps</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.tools.MosaicSkymap" href="#pyaurorax.tools.MosaicSkymap">MosaicSkymap</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.tools.MosaicSkymap.elevation" href="#pyaurorax.tools.MosaicSkymap.elevation">elevation</a></code></li>
<li><code><a title="pyaurorax.tools.MosaicSkymap.polyfill_lat" href="#pyaurorax.tools.MosaicSkymap.polyfill_lat">polyfill_lat</a></code></li>
<li><code><a title="pyaurorax.tools.MosaicSkymap.polyfill_lon" href="#pyaurorax.tools.MosaicSkymap.polyfill_lon">polyfill_lon</a></code></li>
<li><code><a title="pyaurorax.tools.MosaicSkymap.pretty_print" href="#pyaurorax.tools.MosaicSkymap.pretty_print">pretty_print</a></code></li>
<li><code><a title="pyaurorax.tools.MosaicSkymap.site_uid_list" href="#pyaurorax.tools.MosaicSkymap.site_uid_list">site_uid_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.tools.ToolsManager" href="#pyaurorax.tools.ToolsManager">ToolsManager</a></code></h4>
<ul class="two-column">
<li><code><a title="pyaurorax.tools.ToolsManager.bounding_box" href="#pyaurorax.tools.ToolsManager.bounding_box">bounding_box</a></code></li>
<li><code><a title="pyaurorax.tools.ToolsManager.calibration" href="#pyaurorax.tools.ToolsManager.calibration">calibration</a></code></li>
<li><code><a title="pyaurorax.tools.ToolsManager.ccd_contour" href="#pyaurorax.tools.ToolsManager.ccd_contour">ccd_contour</a></code></li>
<li><code><a title="pyaurorax.tools.ToolsManager.display" href="#pyaurorax.tools.ToolsManager.display">display</a></code></li>
<li><code><a title="pyaurorax.tools.ToolsManager.grid_files" href="#pyaurorax.tools.ToolsManager.grid_files">grid_files</a></code></li>
<li><code><a title="pyaurorax.tools.ToolsManager.keogram" href="#pyaurorax.tools.ToolsManager.keogram">keogram</a></code></li>
<li><code><a title="pyaurorax.tools.ToolsManager.montage" href="#pyaurorax.tools.ToolsManager.montage">montage</a></code></li>
<li><code><a title="pyaurorax.tools.ToolsManager.mosaic" href="#pyaurorax.tools.ToolsManager.mosaic">mosaic</a></code></li>
<li><code><a title="pyaurorax.tools.ToolsManager.movie" href="#pyaurorax.tools.ToolsManager.movie">movie</a></code></li>
<li><code><a title="pyaurorax.tools.ToolsManager.scale_intensity" href="#pyaurorax.tools.ToolsManager.scale_intensity">scale_intensity</a></code></li>
<li><code><a title="pyaurorax.tools.ToolsManager.set_theme" href="#pyaurorax.tools.ToolsManager.set_theme">set_theme</a></code></li>
<li><code><a title="pyaurorax.tools.ToolsManager.spectra" href="#pyaurorax.tools.ToolsManager.spectra">spectra</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
