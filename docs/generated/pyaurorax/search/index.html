<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.3">
<title>pyaurorax.search API documentation</title>
<meta name="description" content="Interact with the AuroraX search engine. This includes finding data sources, searching
for conjunctions or ephemeris data, and uploading/managing …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
<style>
@media screen and (max-width: 699px) {
#content {
padding-left: 2em;
padding-right: 2em;
padding-top: 0;
}
}
@media screen and (min-width: 700px) {
#content {
max-width: 125ch;
padding-left: 3em;
padding-right: 3em;
padding-top: 1em;
border-left: 1px solid #ddd;
}
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyaurorax.search</code></h1>
</header>
<section id="section-intro">
<p>Interact with the AuroraX search engine. This includes finding data sources, searching
for conjunctions or ephemeris data, and uploading/managing your own data in the AuroraX platform.</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pyaurorax.search.api" href="api/index.html">pyaurorax.search.api</a></code></dt>
<dd>
<div class="desc"><p>Interface for AuroraX API requests. Primarily an under-the-hood module
not needed for most use-cases.</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.search.availability" href="availability/index.html">pyaurorax.search.availability</a></code></dt>
<dd>
<div class="desc"><p>Retrieve availability information about data in the AuroraX search engine.</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.search.conjunctions" href="conjunctions/index.html">pyaurorax.search.conjunctions</a></code></dt>
<dd>
<div class="desc"><p>Use the AuroraX search engine to find conjunctions between groupings
of data sources …</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.search.data_products" href="data_products/index.html">pyaurorax.search.data_products</a></code></dt>
<dd>
<div class="desc"><p>Use the AuroraX search engine to search and upload data product records …</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.search.ephemeris" href="ephemeris/index.html">pyaurorax.search.ephemeris</a></code></dt>
<dd>
<div class="desc"><p>Use the AuroraX search engine to search and upload ephemeris records …</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.search.location" href="location.html">pyaurorax.search.location</a></code></dt>
<dd>
<div class="desc"><p>AuroraX <code><a title="pyaurorax.search.location.Location" href="location.html#pyaurorax.search.location.Location">Location</a></code> class definition</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.search.metadata" href="metadata/index.html">pyaurorax.search.metadata</a></code></dt>
<dd>
<div class="desc"><p>Interacting with the data source metadata schemas …</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.search.requests" href="requests/index.html">pyaurorax.search.requests</a></code></dt>
<dd>
<div class="desc"><p>Helper methods for retrieving data from an AuroraX search engine API
request …</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.search.sources" href="sources/index.html">pyaurorax.search.sources</a></code></dt>
<dd>
<div class="desc"><p>Manage AuroraX data sources utilized by the search engine.</p></div>
</dd>
<dt><code class="name"><a title="pyaurorax.search.util" href="util/index.html">pyaurorax.search.util</a></code></dt>
<dd>
<div class="desc"><p>Utility methods. For example, converting arbitrary geographic locations to North/South
B-trace geographic locations.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyaurorax.search.AvailabilityResult"><code class="flex name class">
<span>class <span class="ident">AvailabilityResult</span></span>
<span>(</span><span>data_source: <a title="pyaurorax.search.sources.classes.data_source.DataSource" href="sources/classes/data_source.html#pyaurorax.search.sources.classes.data_source.DataSource">DataSource</a>,<br>available_data_products: Dict | None = None,<br>available_ephemeris: Dict | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class definition for data availability information</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_source</code></strong> :&ensp;<code><a title="pyaurorax.search.DataSource" href="#pyaurorax.search.DataSource">DataSource</a></code></dt>
<dd>the data source that the records are associated with</dd>
<dt><strong><code>available_ephemeris</code></strong> :&ensp;<code>Dict</code></dt>
<dd>the ephemeris availability information</dd>
<dt><strong><code>available_data_products</code></strong> :&ensp;<code>Dict</code></dt>
<dd>the data product availability information</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class AvailabilityResult:
    &#34;&#34;&#34;
    Class definition for data availability information

    Attributes:
        data_source (pyaurorax.search.DataSource): 
            the data source that the records are associated with
        available_ephemeris (Dict): 
            the ephemeris availability information
        available_data_products (Dict): 
            the data product availability information
    &#34;&#34;&#34;
    data_source: DataSource
    available_data_products: Optional[Dict] = None
    available_ephemeris: Optional[Dict] = None</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pyaurorax.search.AvailabilityResult.available_data_products"><code class="name">var <span class="ident">available_data_products</span> : Dict | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.search.AvailabilityResult.available_ephemeris"><code class="name">var <span class="ident">available_ephemeris</span> : Dict | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyaurorax.search.AvailabilityResult.data_source"><code class="name">var <span class="ident">data_source</span> : <a title="pyaurorax.search.sources.classes.data_source.DataSource" href="sources/classes/data_source.html#pyaurorax.search.sources.classes.data_source.DataSource">DataSource</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.Conjunction"><code class="flex name class">
<span>class <span class="ident">Conjunction</span></span>
<span>(</span><span>conjunction_type: str,<br>start: datetime.datetime,<br>end: datetime.datetime,<br>data_sources: List[<a title="pyaurorax.search.sources.classes.data_source.DataSource" href="sources/classes/data_source.html#pyaurorax.search.sources.classes.data_source.DataSource">DataSource</a>],<br>min_distance: float,<br>max_distance: float,<br>events: List[Dict],<br>closest_epoch: datetime.datetime,<br>farthest_epoch: datetime.datetime)</span>
</code></dt>
<dd>
<div class="desc"><p>Conjunction object</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>conjunction_type</code></strong></dt>
<dd>the type of location data used when the
conjunction was found (either 'nbtrace', 'sbtrace', or 'geographic')</dd>
<dt><strong><code>start</code></strong></dt>
<dd>start timestamp of the conjunction</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end timestamp of the conjunction</dd>
<dt><strong><code>data_sources</code></strong></dt>
<dd>data sources in the conjunction</dd>
<dt><strong><code>min_distance</code></strong></dt>
<dd>minimum kilometer distance of the conjunction</dd>
<dt><strong><code>max_distance</code></strong></dt>
<dd>maximum kilometer distance of the conjunction</dd>
<dt><strong><code>events</code></strong></dt>
<dd>the sub-conjunctions that make up this over-arching
conjunction (the conjunctions between each set of two data
sources)</dd>
<dt><strong><code>closest_epoch</code></strong></dt>
<dd>timestamp for when data sources were closest</dd>
<dt><strong><code>farthest_epoch</code></strong></dt>
<dd>timestamp for when data sources were farthest</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Conjunction:
    &#34;&#34;&#34;
    Conjunction object

    Attributes:
        conjunction_type: the type of location data used when the
            conjunction was found (either &#39;nbtrace&#39;, &#39;sbtrace&#39;, or &#39;geographic&#39;)
        start: start timestamp of the conjunction
        end: end timestamp of the conjunction
        data_sources: data sources in the conjunction
        min_distance: minimum kilometer distance of the conjunction
        max_distance: maximum kilometer distance of the conjunction
        events: the sub-conjunctions that make up this over-arching
            conjunction (the conjunctions between each set of two data
            sources)
        closest_epoch: timestamp for when data sources were closest
        farthest_epoch: timestamp for when data sources were farthest
    &#34;&#34;&#34;

    def __init__(
        self,
        conjunction_type: str,
        start: datetime.datetime,
        end: datetime.datetime,
        data_sources: List[DataSource],
        min_distance: float,
        max_distance: float,
        events: List[Dict],
        closest_epoch: datetime.datetime,
        farthest_epoch: datetime.datetime,
    ):
        self.conjunction_type = conjunction_type
        self.start = start
        self.end = end
        self.data_sources = data_sources
        self.min_distance = min_distance
        self.max_distance = max_distance
        self.events = events
        self.closest_epoch = closest_epoch
        self.farthest_epoch = farthest_epoch

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        return f&#34;Conjunction(start={repr(self.start)}, end={repr(self.end)}, min_distance={self.min_distance:.2f}, &#34; \
            f&#34;max_distance={self.max_distance:.2f}, data_sources=[...], events=[...])&#34;</code></pre>
</details>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch"><code class="flex name class">
<span>class <span class="ident">ConjunctionSearch</span></span>
<span>(</span><span>aurorax_obj: PyAuroraX,<br>start: datetime.datetime,<br>end: datetime.datetime,<br>distance: Union[int, float, Dict],<br>ground: Optional[List[Dict]] = None,<br>space: Optional[List[Dict]] = None,<br>events: Optional[List[Dict]] = None,<br>conjunction_types: Optional[List[str]] = None,<br>epoch_search_precision: Optional[int] = None,<br>response_format: Optional[Dict] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class representing a conjunction search</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start timestamp of the search (inclusive)</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end timestamp of the search (inclusive)</dd>
<dt><strong><code>distance</code></strong></dt>
<dd>the maximum distance allowed between data sources when searching for
conjunctions. This can either be a number (int or float), or a dictionary
modified from the output of the "get_advanced_distances_combos()" function.</dd>
<dt><strong><code>ground</code></strong></dt>
<dd>
<p>list of ground instrument search parameters, defaults to []</p>
<p>Example:</p>
<pre><code>[{
    "programs": ["themis-asi"],
    "platforms": ["gillam", "rabbit lake"],
    "instrument_types": ["RGB"],
    "ephemeris_metadata_filters": {
        "logical_operator": "AND",
        "expressions": [
            {
                "key": "calgary_apa_ml_v1",
                "operator": "in",
                "values": [ "classified as APA" ]
            }
        ]
    }
}]
</code></pre>
</dd>
<dt><strong><code>space</code></strong></dt>
<dd>
<p>list of one or more space instrument search parameters, defaults to []</p>
<p>Example:</p>
<pre><code>[{
    "programs": ["themis-asi", "swarm"],
    "platforms": ["themisa", "swarma"],
    "instrument_types": ["footprint"],
    "ephemeris_metadata_filters": {
        "logical_operator": "AND",
        "expressions": [
            {
                "key": "nbtrace_region",
                "operator": "in",
                "values": [ "north auroral oval" ]
            }
        ]
    },
    "hemisphere": [
        "northern"
    ]
}]
</code></pre>
</dd>
<dt><strong><code>events</code></strong></dt>
<dd>
<p>list of one or more events search parameters, defaults to []</p>
<p>Example:</p>
<pre><code>[{
    "programs": [ "events" ],
    "instrument_types": [ "substorm onsets" ]
}]
</code></pre>
</dd>
<dt><strong><code>conjunction_types</code></strong></dt>
<dd>list of conjunction types, defaults to ["nbtrace"]. Options are
in the pyaurorax.conjunctions module, or at the top level using the
pyaurorax.CONJUNCTION_TYPE_* variables.</dd>
<dt><strong><code>epoch_search_precision</code></strong></dt>
<dd>the time precision to which conjunctions are calculated. Can be
30 or 60 seconds. Defaults to 60 seconds. Note - this parameter is under active
development and still considered "alpha".</dd>
<dt><strong><code>response_format</code></strong></dt>
<dd>JSON representation of desired data response format</dd>
<dt><strong><code>request</code></strong></dt>
<dd>AuroraXResponse object returned when the search is executed</dd>
<dt><strong><code>request_id</code></strong></dt>
<dd>unique ID assigned to the request by the AuroraX API</dd>
<dt><strong><code>request_url</code></strong></dt>
<dd>unique URL assigned to the request by the AuroraX API</dd>
<dt><strong><code>executed</code></strong></dt>
<dd>indicates if the search has been executed/started</dd>
<dt><strong><code>completed</code></strong></dt>
<dd>indicates if the search has finished</dd>
<dt><strong><code>data_url</code></strong></dt>
<dd>the URL where data is accessed</dd>
<dt><strong><code>query</code></strong></dt>
<dd>the query for this request as JSON</dd>
<dt><strong><code>status</code></strong></dt>
<dd>the status of the query</dd>
<dt><strong><code>data</code></strong></dt>
<dd>the conjunctions found</dd>
<dt><strong><code>logs</code></strong></dt>
<dd>all log messages outputted by the AuroraX API for this request</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConjunctionSearch:
    &#34;&#34;&#34;
    Class representing a conjunction search

    Attributes:
        start: start timestamp of the search (inclusive)
        end: end timestamp of the search (inclusive)
        distance: the maximum distance allowed between data sources when searching for
            conjunctions. This can either be a number (int or float), or a dictionary
            modified from the output of the &#34;get_advanced_distances_combos()&#34; function.
        ground: list of ground instrument search parameters, defaults to []

            Example:

                [{
                    &#34;programs&#34;: [&#34;themis-asi&#34;],
                    &#34;platforms&#34;: [&#34;gillam&#34;, &#34;rabbit lake&#34;],
                    &#34;instrument_types&#34;: [&#34;RGB&#34;],
                    &#34;ephemeris_metadata_filters&#34;: {
                        &#34;logical_operator&#34;: &#34;AND&#34;,
                        &#34;expressions&#34;: [
                            {
                                &#34;key&#34;: &#34;calgary_apa_ml_v1&#34;,
                                &#34;operator&#34;: &#34;in&#34;,
                                &#34;values&#34;: [ &#34;classified as APA&#34; ]
                            }
                        ]
                    }
                }]
        space: list of one or more space instrument search parameters, defaults to []

            Example:

                [{
                    &#34;programs&#34;: [&#34;themis-asi&#34;, &#34;swarm&#34;],
                    &#34;platforms&#34;: [&#34;themisa&#34;, &#34;swarma&#34;],
                    &#34;instrument_types&#34;: [&#34;footprint&#34;],
                    &#34;ephemeris_metadata_filters&#34;: {
                        &#34;logical_operator&#34;: &#34;AND&#34;,
                        &#34;expressions&#34;: [
                            {
                                &#34;key&#34;: &#34;nbtrace_region&#34;,
                                &#34;operator&#34;: &#34;in&#34;,
                                &#34;values&#34;: [ &#34;north auroral oval&#34; ]
                            }
                        ]
                    },
                    &#34;hemisphere&#34;: [
                        &#34;northern&#34;
                    ]
                }]
        events: list of one or more events search parameters, defaults to []

            Example:

                [{
                    &#34;programs&#34;: [ &#34;events&#34; ],
                    &#34;instrument_types&#34;: [ &#34;substorm onsets&#34; ]
                }]
        conjunction_types: list of conjunction types, defaults to [&#34;nbtrace&#34;]. Options are
            in the pyaurorax.conjunctions module, or at the top level using the
            pyaurorax.CONJUNCTION_TYPE_* variables.
        epoch_search_precision: the time precision to which conjunctions are calculated. Can be
            30 or 60 seconds. Defaults to 60 seconds. Note - this parameter is under active
            development and still considered &#34;alpha&#34;.
        response_format: JSON representation of desired data response format
        request: AuroraXResponse object returned when the search is executed
        request_id: unique ID assigned to the request by the AuroraX API
        request_url: unique URL assigned to the request by the AuroraX API
        executed: indicates if the search has been executed/started
        completed: indicates if the search has finished
        data_url: the URL where data is accessed
        query: the query for this request as JSON
        status: the status of the query
        data: the conjunctions found
        logs: all log messages outputted by the AuroraX API for this request
    &#34;&#34;&#34;

    __STANDARD_POLLING_SLEEP_TIME: float = 1.0

    def __init__(self,
                 aurorax_obj: PyAuroraX,
                 start: datetime.datetime,
                 end: datetime.datetime,
                 distance: Union[int, float, Dict],
                 ground: Optional[List[Dict]] = None,
                 space: Optional[List[Dict]] = None,
                 events: Optional[List[Dict]] = None,
                 conjunction_types: Optional[List[str]] = None,
                 epoch_search_precision: Optional[int] = None,
                 response_format: Optional[Dict] = None):

        # set variables using passed in args
        self.aurorax_obj = aurorax_obj
        self.start = start
        self.end = end
        self.ground = [] if ground is None else ground
        self.space = [] if space is None else space
        self.events = [] if events is None else events
        self.distance = distance
        self.conjunction_types = [CONJUNCTION_TYPE_NBTRACE] if conjunction_types is None else conjunction_types
        self.epoch_search_precision = 60 if epoch_search_precision is None else epoch_search_precision
        self.response_format = response_format

        # initialize additional variables
        self.request = None
        self.request_id = &#34;&#34;
        self.request_url = &#34;&#34;
        self.executed = False
        self.completed = False
        self.data_url = &#34;&#34;
        self.query = {}
        self.status = {}
        self.data = []
        self.logs = []

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return &#34;ConjunctionSearch(executed=%s, completed=%s, request_id=&#39;%s&#39;)&#34; % (
            self.executed,
            self.completed,
            self.request_id,
        )

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;
        # set status and query strings
        max_len = 80
        status_str = str(self.status)
        query_str = str(self.query)
        if (len(status_str) &gt; max_len):
            status_str = &#34;%s...&#34; % (status_str[0:max_len])
        if (len(query_str) &gt; max_len):
            query_str = &#34;%s...&#34; % (query_str[0:max_len])

        # set results string
        if (self.executed is True):
            if (len(self.data) == 0):
                data_str = &#34;[0 conjunction results]&#34;
            elif (len(self.data) == 1):
                data_str = &#34;[1 conjunction result]&#34;
            else:
                data_str = &#34;[%d conjunction results]&#34; % (len(self.data))
        else:
            data_str = &#34;&#34;

        # set logs string
        if (self.executed is True):
            if (len(self.logs) == 0):
                logs_str = &#34;[0 log messages]&#34;
            elif (len(self.logs) == 1):
                logs_str = &#34;[1 log message]&#34;
            else:
                logs_str = &#34;[%d log messages]&#34; % (len(self.logs))
        else:
            logs_str = &#34;&#34;

        # print
        print(&#34;ConjunctionSearch:&#34;)
        print(&#34;  %-13s: %s&#34; % (&#34;executed&#34;, self.executed))
        print(&#34;  %-13s: %s&#34; % (&#34;completed&#34;, self.completed))
        print(&#34;  %-13s: %s&#34; % (&#34;request_id&#34;, self.request_id))
        print(&#34;  %-13s: %s&#34; % (&#34;request&#34;, self.request))
        print(&#34;  %-13s: %s&#34; % (&#34;request_url&#34;, self.request_url))
        print(&#34;  %-13s: %s&#34; % (&#34;data_url&#34;, self.data_url))
        print(&#34;  %-13s: %s&#34; % (&#34;query&#34;, query_str))
        print(&#34;  %-13s: %s&#34; % (&#34;status&#34;, status_str))
        print(&#34;  %-13s: %s&#34; % (&#34;data&#34;, data_str))
        print(&#34;  %-13s: %s&#34; % (&#34;logs&#34;, logs_str))

    def __fill_in_missing_distances(self, curr_distances: Dict) -&gt; Dict:
        # get all distances possible
        all_distances = self.get_advanced_distances_combos()

        # go through current distances and fill in the values
        for curr_key, curr_value in curr_distances.items():
            curr_key_split = curr_key.split(&#39;-&#39;)
            curr_key1 = curr_key_split[0].strip()
            curr_key2 = curr_key_split[1].strip()
            for all_key in all_distances.keys():
                if (curr_key1 in all_key and curr_key2 in all_key):
                    # found the matching key, replace the value
                    all_distances[all_key] = curr_value

        # return
        return all_distances

    def check_criteria_block_count_validity(self) -&gt; None:
        &#34;&#34;&#34;
        Check the number of of criteria blocks to see if there
        is too many. A max of 10 is allowed by the AuroraX
        conjunction search engine. An exception is raised if
        it was determined to have too many.

        Raises:
            pyaurorax.exceptions.AuroraXError: too many criteria blocks are found
        &#34;&#34;&#34;
        count_ground = 0
        count_space = 0
        count_events = 0
        if (self.ground is not None):
            count_ground = len(self.ground)
        if (self.space is not None):
            count_space = len(self.space)
        if (self.events is not None):
            count_events = len(self.events)
        if ((count_ground + count_space + count_events) &gt; 10):
            raise AuroraXError(&#34;Number of criteria blocks exceeds 10, please reduce the count&#34;)

    def get_advanced_distances_combos(self, default_distance: Optional[Union[int, float]] = None) -&gt; Dict:
        &#34;&#34;&#34;
        Get the advanced distances combinations for this search

        Args:
            default_distance: the default distance to use, defaults to None

        Returns:
            the advanced distances combinations
        &#34;&#34;&#34;
        # set input arrays
        options = []
        if (self.ground is not None):
            for i in range(0, len(self.ground)):
                options.append(&#34;ground%d&#34; % (i + 1))
        if (self.space is not None):
            for i in range(0, len(self.space)):
                options.append(&#34;space%d&#34; % (i + 1))
        if (self.events is not None):
            for i in range(0, len(self.events)):
                options.append(&#34;events%d&#34; % (i + 1))

        # derive all combinations of options of size 2
        combinations = {}
        for element in itertools.combinations(options, r=2):
            combinations[&#34;%s-%s&#34; % (element[0], element[1])] = default_distance

        # return
        return combinations

    @property
    def distance(self) -&gt; Union[int, float, Dict[str, Union[int, float]]]:
        &#34;&#34;&#34;
        Property for the distance parameter

        Returns:
            the distance dictionary with all combinations
        &#34;&#34;&#34;
        return self.__distance

    @distance.setter
    def distance(self, distance: Union[int, float, Dict[str, Union[int, float]]]) -&gt; None:
        # set distances to a dict if it&#39;s an int or float
        if (isinstance(distance, int) or isinstance(distance, float)):
            self.__distance = self.get_advanced_distances_combos(default_distance=distance)  # type: ignore
        else:
            # is a dict, fill in any gaps
            self.__distance = self.__fill_in_missing_distances(distance)  # type: ignore

    @property
    def query(self) -&gt; Dict:
        &#34;&#34;&#34;
        Property for the query value

        Returns:
            the query parameter
        &#34;&#34;&#34;
        self._query = {
            &#34;start&#34;: self.start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
            &#34;end&#34;: self.end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
            &#34;ground&#34;: self.ground,
            &#34;space&#34;: self.space,
            &#34;events&#34;: self.events,
            &#34;conjunction_types&#34;: self.conjunction_types,
            &#34;max_distances&#34;: self.distance,
            &#34;epoch_search_precision&#34;: self.epoch_search_precision if self.epoch_search_precision in [30, 60] else 60,
        }
        return self._query

    @query.setter
    def query(self, query: Dict) -&gt; None:
        self._query = query

    def execute(self) -&gt; None:
        &#34;&#34;&#34;
        Initiate a conjunction search request

        Raises:
            pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
        &#34;&#34;&#34;
        # check number of criteria blocks
        self.check_criteria_block_count_validity()

        # do request
        url = &#34;%s/%s&#34; % (self.aurorax_obj.api_base_url, self.aurorax_obj.search.api.URL_SUFFIX_CONJUNCTION_SEARCH)
        req = AuroraXAPIRequest(self.aurorax_obj, method=&#34;post&#34;, url=url, body=self.query, null_response=True)
        res = req.execute()

        # set request ID, request_url, executed
        self.executed = True
        if res.status_code == 202:
            # request successfully dispatched
            self.executed = True
            self.request_url = res.request.headers[&#34;location&#34;]
            self.request_id = self.request_url.rsplit(&#34;/&#34;, 1)[-1]

        # set request variable
        self.request = res

    def update_status(self, status: Optional[Dict] = None) -&gt; None:
        &#34;&#34;&#34;
        Update the status of this conjunction search request

        Args:
            status: the previously-retrieved status of this request (include
                to avoid requesting it from the API again), defaults to None

        Raises:
            pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
        &#34;&#34;&#34;
        # get the status if it isn&#39;t passed in
        if (status is None):
            status = requests_get_status(self.aurorax_obj, self.request_url)

        # check response
        if (status is None):
            raise AuroraXAPIError(&#34;Could not retrieve status for this request&#34;)

        # update request status by checking if data URI is set
        if (status[&#34;search_result&#34;][&#34;data_uri&#34;] is not None):
            self.completed = True
            self.data_url = &#34;%s/data&#34; % (self.request_url)

        # set class variable &#34;status&#34; and &#34;logs&#34;
        self.status = status
        self.logs = status[&#34;logs&#34;]

    def check_for_data(self) -&gt; bool:
        &#34;&#34;&#34;
        Check to see if data is available for this conjunction
        search request

        Returns:
            True if data is available, else False

        Raises:
            pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
        &#34;&#34;&#34;
        self.update_status()
        return self.completed

    def get_data(self) -&gt; None:
        &#34;&#34;&#34;
        Retrieve the data available for this conjunction search request

        Raises:
            pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
        &#34;&#34;&#34;
        # check if completed yet
        if (self.completed is False):
            print(&#34;No data available, update status or check for data first&#34;)
            return

        # get data
        raw_data = requests_get_data(self.aurorax_obj, self.data_url, self.response_format, False)

        # set data variable
        if (self.response_format is not None):
            self.data = raw_data
        else:
            # cast data source objects
            for i in range(0, len(raw_data)):
                for j in range(0, len(raw_data[i][&#34;data_sources&#34;])):
                    ds = DataSource(**raw_data[i][&#34;data_sources&#34;][j], format=FORMAT_BASIC_INFO)
                    raw_data[i][&#34;data_sources&#34;][j] = ds

            # cast conjunctions
            self.data = [Conjunction(**c) for c in raw_data]

    def wait(self, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Block and wait until the request is complete and data is
        available for retrieval

        Args:
            poll_interval: time in seconds to wait between polling attempts, defaults
                to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME
            verbose: output poll times and other progress messages, defaults to False

        Raises:
            pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
        &#34;&#34;&#34;
        url = &#34;%s/%s&#34; % (self.aurorax_obj.api_base_url, self.aurorax_obj.search.api.URL_SUFFIX_CONJUNCTION_REQUEST.format(self.request_id))
        self.update_status(requests_wait_for_data(self.aurorax_obj, url, poll_interval, verbose))

    def cancel(self, wait: bool = False, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; int:
        &#34;&#34;&#34;
        Cancel the conjunction search request

        This method returns immediately by default since the API processes
        this request asynchronously. If you would prefer to wait for it
        to be completed, set the &#39;wait&#39; parameter to True. You can adjust
        the polling time using the &#39;poll_interval&#39; parameter.

        Args:
            wait: wait until the cancellation request has been
                completed (may wait for several minutes)
            poll_interval: seconds to wait between polling
                calls, defaults to STANDARD_POLLING_SLEEP_TIME.
            verbose: output poll times and other progress messages, defaults
                to False

        Returns:
            1 on success

        Raises:
            pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
        &#34;&#34;&#34;
        url = &#34;%s/%s&#34; % (self.aurorax_obj.api_base_url, self.aurorax_obj.search.api.URL_SUFFIX_CONJUNCTION_REQUEST.format(self.request_id))
        return requests_cancel(self.aurorax_obj, url, wait, poll_interval, verbose)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyaurorax.search.ConjunctionSearch.distance"><code class="name">prop <span class="ident">distance</span> : Union[int, float, Dict[str, Union[int, float]]]</code></dt>
<dd>
<div class="desc"><p>Property for the distance parameter</p>
<h2 id="returns">Returns</h2>
<p>the distance dictionary with all combinations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def distance(self) -&gt; Union[int, float, Dict[str, Union[int, float]]]:
    &#34;&#34;&#34;
    Property for the distance parameter

    Returns:
        the distance dictionary with all combinations
    &#34;&#34;&#34;
    return self.__distance</code></pre>
</details>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch.query"><code class="name">prop <span class="ident">query</span> : Dict</code></dt>
<dd>
<div class="desc"><p>Property for the query value</p>
<h2 id="returns">Returns</h2>
<p>the query parameter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def query(self) -&gt; Dict:
    &#34;&#34;&#34;
    Property for the query value

    Returns:
        the query parameter
    &#34;&#34;&#34;
    self._query = {
        &#34;start&#34;: self.start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        &#34;end&#34;: self.end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        &#34;ground&#34;: self.ground,
        &#34;space&#34;: self.space,
        &#34;events&#34;: self.events,
        &#34;conjunction_types&#34;: self.conjunction_types,
        &#34;max_distances&#34;: self.distance,
        &#34;epoch_search_precision&#34;: self.epoch_search_precision if self.epoch_search_precision in [30, 60] else 60,
    }
    return self._query</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.ConjunctionSearch.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self, wait: bool = False, poll_interval: float = 1.0, verbose: bool = False) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Cancel the conjunction search request</p>
<p>This method returns immediately by default since the API processes
this request asynchronously. If you would prefer to wait for it
to be completed, set the 'wait' parameter to True. You can adjust
the polling time using the 'poll_interval' parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wait</code></strong></dt>
<dd>wait until the cancellation request has been
completed (may wait for several minutes)</dd>
<dt><strong><code>poll_interval</code></strong></dt>
<dd>seconds to wait between polling
calls, defaults to STANDARD_POLLING_SLEEP_TIME.</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>output poll times and other progress messages, defaults
to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>1 on success</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXAPIError" href="../exceptions.html#pyaurorax.exceptions.AuroraXAPIError">AuroraXAPIError</a></code></dt>
<dd>An API error was encountered</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch.check_criteria_block_count_validity"><code class="name flex">
<span>def <span class="ident">check_criteria_block_count_validity</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Check the number of of criteria blocks to see if there
is too many. A max of 10 is allowed by the AuroraX
conjunction search engine. An exception is raised if
it was determined to have too many.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXError" href="../exceptions.html#pyaurorax.exceptions.AuroraXError">AuroraXError</a></code></dt>
<dd>too many criteria blocks are found</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch.check_for_data"><code class="name flex">
<span>def <span class="ident">check_for_data</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check to see if data is available for this conjunction
search request</p>
<h2 id="returns">Returns</h2>
<p>True if data is available, else False</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXAPIError" href="../exceptions.html#pyaurorax.exceptions.AuroraXAPIError">AuroraXAPIError</a></code></dt>
<dd>An API error was encountered</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initiate a conjunction search request</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXAPIError" href="../exceptions.html#pyaurorax.exceptions.AuroraXAPIError">AuroraXAPIError</a></code></dt>
<dd>An API error was encountered</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch.get_advanced_distances_combos"><code class="name flex">
<span>def <span class="ident">get_advanced_distances_combos</span></span>(<span>self, default_distance: Optional[Union[int, float]] = None) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Get the advanced distances combinations for this search</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>default_distance</code></strong></dt>
<dd>the default distance to use, defaults to None</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the advanced distances combinations</p></div>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the data available for this conjunction search request</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXAPIError" href="../exceptions.html#pyaurorax.exceptions.AuroraXAPIError">AuroraXAPIError</a></code></dt>
<dd>An API error was encountered</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch.update_status"><code class="name flex">
<span>def <span class="ident">update_status</span></span>(<span>self, status: Optional[Dict] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Update the status of this conjunction search request</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>status</code></strong></dt>
<dd>the previously-retrieved status of this request (include
to avoid requesting it from the API again), defaults to None</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXAPIError" href="../exceptions.html#pyaurorax.exceptions.AuroraXAPIError">AuroraXAPIError</a></code></dt>
<dd>An API error was encountered</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.ConjunctionSearch.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span>(<span>self, poll_interval: float = 1.0, verbose: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Block and wait until the request is complete and data is
available for retrieval</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>poll_interval</code></strong></dt>
<dd>time in seconds to wait between polling attempts, defaults
to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>output poll times and other progress messages, defaults to False</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXAPIError" href="../exceptions.html#pyaurorax.exceptions.AuroraXAPIError">AuroraXAPIError</a></code></dt>
<dd>An API error was encountered</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.DataProductData"><code class="flex name class">
<span>class <span class="ident">DataProductData</span></span>
<span>(</span><span>data_source: <a title="pyaurorax.search.sources.classes.data_source.DataSource" href="sources/classes/data_source.html#pyaurorax.search.sources.classes.data_source.DataSource">DataSource</a>,<br>data_product_type: str,<br>start: datetime.datetime,<br>end: datetime.datetime,<br>url: str,<br>metadata: Dict | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Data product object</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_source</code></strong></dt>
<dd>data source that the ephemeris record is associated with</dd>
<dt><strong><code>data_product_type</code></strong></dt>
<dd>data product type ("keogram", "movie", "summary_plot")</dd>
<dt><strong><code>start</code></strong></dt>
<dd>starting timestamp for the record (assumed it is in UTC), inclusive</dd>
<dt><strong><code>end</code></strong></dt>
<dd>ending timestamp for the record (assumed it is in UTC), inclusive</dd>
<dt><strong><code>url</code></strong></dt>
<dd>the URL of data product</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>metadata for this record (arbitrary keys and values)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataProductData:
    &#34;&#34;&#34;
    Data product object

    Attributes:
        data_source: data source that the ephemeris record is associated with
        data_product_type: data product type (&#34;keogram&#34;, &#34;movie&#34;, &#34;summary_plot&#34;)
        start: starting timestamp for the record (assumed it is in UTC), inclusive
        end: ending timestamp for the record (assumed it is in UTC), inclusive
        url: the URL of data product
        metadata: metadata for this record (arbitrary keys and values)
    &#34;&#34;&#34;

    def __init__(
        self,
        data_source: DataSource,
        data_product_type: str,
        start: datetime.datetime,
        end: datetime.datetime,
        url: str,
        metadata: Optional[Dict] = None,
    ):
        self.data_source = data_source
        self.data_product_type = data_product_type
        self.start = start
        self.end = end
        self.url = url
        self.metadata = metadata

    def to_json_serializable(self) -&gt; Dict:
        &#34;&#34;&#34;
        Convert object to a JSON-serializable object (ie. translate
        datetime objects to strings)

        Returns:
            a dictionary object that is JSON-serializable
        &#34;&#34;&#34;
        # init
        d = self.__dict__

        # format epoch as str
        if (type(d[&#34;start&#34;]) is datetime.datetime):
            d[&#34;start&#34;] = d[&#34;start&#34;].strftime(&#34;%Y-%m-%dT%H:%M:00.000&#34;)
        if (type(d[&#34;end&#34;]) is datetime.datetime):
            d[&#34;end&#34;] = d[&#34;end&#34;].strftime(&#34;%Y-%m-%dT%H:%M:00.000&#34;)

        # format metadata
        if (self.metadata is not None):
            for key, value in self.metadata.items():
                if (isinstance(value, datetime.datetime) is True or isinstance(value, datetime.date) is True):
                    self.metadata[key] = self.metadata[key].strftime(&#34;%Y-%m-%dT%H:%M:%S.%f&#34;)
        # if (isinstance(self.metadata, list) is True):
        #     self.metadata = {}

        # format data source fields for query
        d[&#34;program&#34;] = self.data_source.program
        d[&#34;platform&#34;] = self.data_source.platform
        d[&#34;instrument_type&#34;] = self.data_source.instrument_type
        del d[&#34;data_source&#34;]

        # return
        return d

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        # shorten the metadata and url
        max_len = 20
        attr_metadata = f&#34;{self.metadata}&#34;
        if (len(attr_metadata) &gt; max_len):
            attr_metadata = attr_metadata[0:max_len] + &#34;...}&#34;
        attr_url = f&#34;{self.url}&#34;
        if (len(attr_url) &gt; max_len):
            attr_url = attr_url[0:max_len] + &#34;...&#34;

        # return formatted representation
        return f&#34;DataProductData(start={repr(self.start)}, end={repr(self.end)}, data_product_type=&#39;{self.data_product_type}&#39;, &#34; \
            f&#34;url=&#39;{attr_url}&#39;, metadata={attr_metadata}, data_source=DataSource(...))&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.DataProductData.to_json_serializable"><code class="name flex">
<span>def <span class="ident">to_json_serializable</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Convert object to a JSON-serializable object (ie. translate
datetime objects to strings)</p>
<h2 id="returns">Returns</h2>
<p>a dictionary object that is JSON-serializable</p></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.DataProductSearch"><code class="flex name class">
<span>class <span class="ident">DataProductSearch</span></span>
<span>(</span><span>aurorax_obj: PyAuroraX,<br>start: datetime.datetime,<br>end: datetime.datetime,<br>programs: Optional[List[str]] = None,<br>platforms: Optional[List[str]] = None,<br>instrument_types: Optional[List[str]] = None,<br>data_product_types: Optional[List[str]] = None,<br>metadata_filters: Optional[List[Dict]] = None,<br>metadata_filters_logical_operator: Optional[str] = None,<br>response_format: Optional[Dict] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class representing a data product search</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start timestamp of the search (inclusive)</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end timestamp of the search (inclusive)</dd>
<dt><strong><code>programs</code></strong></dt>
<dd>list of program names to search</dd>
<dt><strong><code>platforms</code></strong></dt>
<dd>list of platform names to search</dd>
<dt><strong><code>instrument_types</code></strong></dt>
<dd>list of instrument types to search</dd>
<dt><strong><code>data_product_types</code></strong></dt>
<dd>list of dictionaries describing data product
types to filter on e.g. "keogram", defaults to None. Options are in the
pyaurorax.data_products module, or at the top level using the
pyaurorax.DATA_PRODUCT_TYPE* variables.</dd>
<dt><strong><code>metadata_filters</code></strong></dt>
<dd>
<p>list of dictionaries describing metadata keys and
values to filter on, defaults to None</p>
<p>Example:</p>
<pre><code>[{
    "key": "nbtrace_region",
    "operator": "in",
    "values": ["north polar cap"]
}]
</code></pre>
</dd>
<dt><strong><code>metadata_filters_logical_operator</code></strong></dt>
<dd>the logical operator to use when
evaluating metadata filters (either 'AND' or 'OR'), defaults
to "AND"</dd>
<dt><strong><code>response_format</code></strong></dt>
<dd>JSON representation of desired data response format</dd>
<dt><strong><code>request</code></strong></dt>
<dd>AuroraXResponse object returned when the search is executed</dd>
<dt><strong><code>request_id</code></strong></dt>
<dd>unique ID assigned to the request by the AuroraX API</dd>
<dt><strong><code>request_url</code></strong></dt>
<dd>unique URL assigned to the request by the AuroraX API</dd>
<dt><strong><code>executed</code></strong></dt>
<dd>indicates if the search has been executed/started</dd>
<dt><strong><code>completed</code></strong></dt>
<dd>indicates if the search has finished</dd>
<dt><strong><code>data_url</code></strong></dt>
<dd>the URL where data is accessed</dd>
<dt><strong><code>query</code></strong></dt>
<dd>the query for this request as JSON</dd>
<dt><strong><code>status</code></strong></dt>
<dd>the status of the query</dd>
<dt><strong><code>data</code></strong></dt>
<dd>the data product records found</dd>
<dt><strong><code>logs</code></strong></dt>
<dd>all log messages outputted by the AuroraX API for this request</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataProductSearch:
    &#34;&#34;&#34;
    Class representing a data product search

    Attributes:
        start: start timestamp of the search (inclusive)
        end: end timestamp of the search (inclusive)
        programs: list of program names to search
        platforms: list of platform names to search
        instrument_types: list of instrument types to search
        data_product_types: list of dictionaries describing data product
            types to filter on e.g. &#34;keogram&#34;, defaults to None. Options are in the
            pyaurorax.data_products module, or at the top level using the
            pyaurorax.DATA_PRODUCT_TYPE* variables.
        metadata_filters: list of dictionaries describing metadata keys and
            values to filter on, defaults to None

            Example:

                [{
                    &#34;key&#34;: &#34;nbtrace_region&#34;,
                    &#34;operator&#34;: &#34;in&#34;,
                    &#34;values&#34;: [&#34;north polar cap&#34;]
                }]
        metadata_filters_logical_operator: the logical operator to use when
            evaluating metadata filters (either &#39;AND&#39; or &#39;OR&#39;), defaults
            to &#34;AND&#34;
        response_format: JSON representation of desired data response format
        request: AuroraXResponse object returned when the search is executed
        request_id: unique ID assigned to the request by the AuroraX API
        request_url: unique URL assigned to the request by the AuroraX API
        executed: indicates if the search has been executed/started
        completed: indicates if the search has finished
        data_url: the URL where data is accessed
        query: the query for this request as JSON
        status: the status of the query
        data: the data product records found
        logs: all log messages outputted by the AuroraX API for this request
    &#34;&#34;&#34;

    __STANDARD_POLLING_SLEEP_TIME: float = 1.0

    def __init__(self,
                 aurorax_obj: PyAuroraX,
                 start: datetime.datetime,
                 end: datetime.datetime,
                 programs: Optional[List[str]] = None,
                 platforms: Optional[List[str]] = None,
                 instrument_types: Optional[List[str]] = None,
                 data_product_types: Optional[List[str]] = None,
                 metadata_filters: Optional[List[Dict]] = None,
                 metadata_filters_logical_operator: Optional[str] = None,
                 response_format: Optional[Dict] = None) -&gt; None:

        # set variables using passed in args
        self.aurorax_obj = aurorax_obj
        self.start = start
        self.end = end
        self.programs = programs
        self.platforms = platforms
        self.instrument_types = instrument_types
        self.data_product_types = data_product_types
        self.metadata_filters = metadata_filters
        self.metadata_filters_logical_operator = &#34;AND&#34; if metadata_filters_logical_operator is None else metadata_filters_logical_operator
        self.response_format = response_format

        # initialize additional variables
        self.request = None
        self.request_id = &#34;&#34;
        self.request_url = &#34;&#34;
        self.executed = False
        self.completed = False
        self.data_url = &#34;&#34;
        self.query = {}
        self.status = {}
        self.data = []
        self.logs = []

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        return &#34;DataProductSearch(executed=%s, completed=%s, request_id=&#39;%s&#39;)&#34; % (
            self.executed,
            self.completed,
            self.request_id,
        )

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;
        # set status and query strings
        max_len = 80
        status_str = str(self.status)
        query_str = str(self.query)
        if (len(status_str) &gt; max_len):
            status_str = &#34;%s...&#34; % (status_str[0:max_len])
        if (len(query_str) &gt; max_len):
            query_str = &#34;%s...&#34; % (query_str[0:max_len])

        # set results string
        if (self.executed is True):
            if (len(self.data) == 0):
                data_str = &#34;[0 data product results]&#34;
            elif (len(self.data) == 1):
                data_str = &#34;[1 data product result]&#34;
            else:
                data_str = &#34;[%d data product results]&#34; % (len(self.data))
        else:
            data_str = &#34;&#34;

        # set logs string
        if (self.executed is True):
            if (len(self.logs) == 0):
                logs_str = &#34;[0 log messages]&#34;
            elif (len(self.logs) == 1):
                logs_str = &#34;[1 log message]&#34;
            else:
                logs_str = &#34;[%d log messages]&#34; % (len(self.logs))
        else:
            logs_str = &#34;&#34;

        # print
        print(&#34;DataProductSearch:&#34;)
        print(&#34;  %-13s: %s&#34; % (&#34;executed&#34;, self.executed))
        print(&#34;  %-13s: %s&#34; % (&#34;completed&#34;, self.completed))
        print(&#34;  %-13s: %s&#34; % (&#34;request_id&#34;, self.request_id))
        print(&#34;  %-13s: %s&#34; % (&#34;request&#34;, self.request))
        print(&#34;  %-13s: %s&#34; % (&#34;request_url&#34;, self.request_url))
        print(&#34;  %-13s: %s&#34; % (&#34;data_url&#34;, self.data_url))
        print(&#34;  %-13s: %s&#34; % (&#34;query&#34;, query_str))
        print(&#34;  %-13s: %s&#34; % (&#34;status&#34;, status_str))
        print(&#34;  %-13s: %s&#34; % (&#34;data&#34;, data_str))
        print(&#34;  %-13s: %s&#34; % (&#34;logs&#34;, logs_str))

    @property
    def query(self):
        &#34;&#34;&#34;
        Property for the query value
        &#34;&#34;&#34;
        self._query = {
            &#34;data_sources&#34;: {
                &#34;programs&#34;: [] if not self.programs else self.programs,
                &#34;platforms&#34;: [] if not self.platforms else self.platforms,
                &#34;instrument_types&#34;: [] if not self.instrument_types else self.instrument_types,
                &#34;data_product_metadata_filters&#34;: {} if not self.metadata_filters else {
                    &#34;logical_operator&#34;: self.metadata_filters_logical_operator,
                    &#34;expressions&#34;: self.metadata_filters
                },
            },
            &#34;start&#34;: self.start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
            &#34;end&#34;: self.end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
            &#34;data_product_type_filters&#34;: [] if not self.data_product_types else self.data_product_types,
        }
        return self._query

    @query.setter
    def query(self, query):
        self._query = query

    def execute(self) -&gt; None:
        &#34;&#34;&#34;
        Initiate a data product search request
        &#34;&#34;&#34;
        # do request
        url = &#34;%s/%s&#34; % (self.aurorax_obj.api_base_url, self.aurorax_obj.search.api.URL_SUFFIX_DATA_PRODUCTS_SEARCH)
        req = AuroraXAPIRequest(self.aurorax_obj, method=&#34;post&#34;, url=url, body=self.query, null_response=True)
        res = req.execute()

        # set request ID, request_url, executed
        self.executed = True
        if (res.status_code == 202):
            # request successfully dispatched
            self.executed = True
            self.request_url = res.request.headers[&#34;location&#34;]
            self.request_id = self.request_url.rsplit(&#34;/&#34;, 1)[-1]

        # set request variable
        self.request = res

    def update_status(self, status: Optional[Dict] = None) -&gt; None:
        &#34;&#34;&#34;
        Update the status of this data product search request

        Args:
            status: the previously-retrieved status of this request (include
                to avoid requesting it from the API again), defaults to None
        &#34;&#34;&#34;
        # get the status if it isn&#39;t passed in
        if (status is None):
            status = requests_get_status(self.aurorax_obj, self.request_url)

        # check response
        if (status is None):
            raise AuroraXAPIError(&#34;Could not retrieve status for this request&#34;)

        # update request status by checking if data URI is set
        if (status[&#34;search_result&#34;][&#34;data_uri&#34;] is not None):
            self.completed = True
            self.data_url = &#34;%s/data&#34; % (self.request_url)

        # set class variable &#34;status&#34; and &#34;logs&#34;
        self.status = status
        self.logs = status[&#34;logs&#34;]

    def check_for_data(self) -&gt; bool:
        &#34;&#34;&#34;
        Check to see if data is available for this data product
        search request

        Returns:
            True if data is available, else False
        &#34;&#34;&#34;
        self.update_status()
        return self.completed

    def get_data(self) -&gt; None:
        &#34;&#34;&#34;
        Retrieve the data available for this data product search request
        &#34;&#34;&#34;
        # check if completed yet
        if (self.completed is False):
            print(&#34;No data available, update status or check for data first&#34;)
            return

        # get data
        raw_data = requests_get_data(self.aurorax_obj, self.data_url, self.response_format, False)

        # set data variable
        if (self.response_format is not None):
            self.data = raw_data
        else:
            # cast data source objects
            for i in range(0, len(raw_data)):
                ds = DataSource(**raw_data[i][&#34;data_source&#34;], format=FORMAT_BASIC_INFO)
                raw_data[i][&#34;data_source&#34;] = ds

            # cast data product objects
            self.data = [DataProductData(**dp) for dp in raw_data]

    def wait(self, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Block and wait for the request to complete and data is available
        for retrieval

        Args:
            poll_interval: time in seconds to wait between polling attempts,
                defaults to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME
            verbose: output poll times and other progress messages, defaults
                to False
        &#34;&#34;&#34;
        url = &#34;%s/%s&#34; % (self.aurorax_obj.api_base_url, self.aurorax_obj.search.api.URL_SUFFIX_DATA_PRODUCTS_REQUEST.format(self.request_id))
        self.update_status(requests_wait_for_data(self.aurorax_obj, url, poll_interval, verbose))

    def cancel(self, wait: bool = False, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; int:
        &#34;&#34;&#34;
        Cancel the data product search request

        This method returns immediately by default since the API processes
        this request asynchronously. If you would prefer to wait for it
        to be completed, set the &#39;wait&#39; parameter to True. You can adjust
        the polling time using the &#39;poll_interval&#39; parameter.

        Args:
            wait: wait until the cancellation request has been
                completed (may wait for several minutes)
            poll_interval: seconds to wait between polling
                calls, defaults to STANDARD_POLLING_SLEEP_TIME.
            verbose: output poll times and other progress messages, defaults
                to False

        Returns:
            1 on success

        Raises:
            pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
            pyaurorax.exceptions.AuroraXUnauthorizedError: invalid API key for this operation
        &#34;&#34;&#34;
        url = &#34;%s/%s&#34; % (self.aurorax_obj.api_base_url, self.aurorax_obj.search.api.URL_SUFFIX_DATA_PRODUCTS_REQUEST.format(self.request_id))
        return requests_cancel(self.aurorax_obj, url, wait, poll_interval, verbose)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyaurorax.search.DataProductSearch.query"><code class="name">prop <span class="ident">query</span></code></dt>
<dd>
<div class="desc"><p>Property for the query value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def query(self):
    &#34;&#34;&#34;
    Property for the query value
    &#34;&#34;&#34;
    self._query = {
        &#34;data_sources&#34;: {
            &#34;programs&#34;: [] if not self.programs else self.programs,
            &#34;platforms&#34;: [] if not self.platforms else self.platforms,
            &#34;instrument_types&#34;: [] if not self.instrument_types else self.instrument_types,
            &#34;data_product_metadata_filters&#34;: {} if not self.metadata_filters else {
                &#34;logical_operator&#34;: self.metadata_filters_logical_operator,
                &#34;expressions&#34;: self.metadata_filters
            },
        },
        &#34;start&#34;: self.start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        &#34;end&#34;: self.end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        &#34;data_product_type_filters&#34;: [] if not self.data_product_types else self.data_product_types,
    }
    return self._query</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.DataProductSearch.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self, wait: bool = False, poll_interval: float = 1.0, verbose: bool = False) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Cancel the data product search request</p>
<p>This method returns immediately by default since the API processes
this request asynchronously. If you would prefer to wait for it
to be completed, set the 'wait' parameter to True. You can adjust
the polling time using the 'poll_interval' parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wait</code></strong></dt>
<dd>wait until the cancellation request has been
completed (may wait for several minutes)</dd>
<dt><strong><code>poll_interval</code></strong></dt>
<dd>seconds to wait between polling
calls, defaults to STANDARD_POLLING_SLEEP_TIME.</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>output poll times and other progress messages, defaults
to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>1 on success</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXAPIError" href="../exceptions.html#pyaurorax.exceptions.AuroraXAPIError">AuroraXAPIError</a></code></dt>
<dd>An API error was encountered</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnauthorizedError" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnauthorizedError">AuroraXUnauthorizedError</a></code></dt>
<dd>invalid API key for this operation</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.DataProductSearch.check_for_data"><code class="name flex">
<span>def <span class="ident">check_for_data</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check to see if data is available for this data product
search request</p>
<h2 id="returns">Returns</h2>
<p>True if data is available, else False</p></div>
</dd>
<dt id="pyaurorax.search.DataProductSearch.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initiate a data product search request</p></div>
</dd>
<dt id="pyaurorax.search.DataProductSearch.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the data available for this data product search request</p></div>
</dd>
<dt id="pyaurorax.search.DataProductSearch.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
<dt id="pyaurorax.search.DataProductSearch.update_status"><code class="name flex">
<span>def <span class="ident">update_status</span></span>(<span>self, status: Optional[Dict] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Update the status of this data product search request</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>status</code></strong></dt>
<dd>the previously-retrieved status of this request (include
to avoid requesting it from the API again), defaults to None</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.DataProductSearch.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span>(<span>self, poll_interval: float = 1.0, verbose: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Block and wait for the request to complete and data is available
for retrieval</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>poll_interval</code></strong></dt>
<dd>time in seconds to wait between polling attempts,
defaults to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>output poll times and other progress messages, defaults
to False</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.DataSource"><code class="flex name class">
<span>class <span class="ident">DataSource</span></span>
<span>(</span><span>identifier: int | None = None,<br>program: str | None = None,<br>platform: str | None = None,<br>instrument_type: str | None = None,<br>source_type: str | None = None,<br>display_name: str | None = None,<br>metadata: Dict | None = None,<br>owner: str | None = None,<br>maintainers: List[str] | None = None,<br>ephemeris_metadata_schema: List[Dict] | None = None,<br>data_product_metadata_schema: List[Dict] | None = None,<br>stats: <a title="pyaurorax.search.sources.classes.data_source_stats.DataSourceStatistics" href="sources/classes/data_source_stats.html#pyaurorax.search.sources.classes.data_source_stats.DataSourceStatistics">DataSourceStatistics</a> | None = None,<br>format: str = 'full_record')</span>
</code></dt>
<dd>
<div class="desc"><p>AuroraX data source record</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>identifier</code></strong> :&ensp;<code>int</code></dt>
<dd>the unique AuroraX data source identifier</dd>
<dt><strong><code>program</code></strong> :&ensp;<code>str</code></dt>
<dd>the program for this data source</dd>
<dt><strong><code>platform</code></strong> :&ensp;<code>str</code></dt>
<dd>the platform for this data source</dd>
<dt><strong><code>instrument_type</code></strong> :&ensp;<code>str</code></dt>
<dd>the instrument type for this data source</dd>
<dt><strong><code>source_type</code></strong> :&ensp;<code>str</code></dt>
<dd>the data source type for this data source. Options are
in the pyaurorax.search.sources module, or at the top level using the
pyaurorax.search.SOURCE_TYPE_* variables.</dd>
<dt><strong><code>display_name</code></strong> :&ensp;<code>str</code></dt>
<dd>the display name for this data source</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>Dict</code></dt>
<dd>metadata for this data source (arbitrary keys and values)</dd>
<dt><strong><code>owner</code></strong> :&ensp;<code>str</code></dt>
<dd>the owner's email address of this data source</dd>
<dt><strong><code>maintainers</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>the email addresses of AuroraX accounts that can alter
this data source and its associated records</dd>
<dt><strong><code>ephemeris_metadata_schema</code></strong> :&ensp;<code>Dict</code></dt>
<dd>a list of dictionaries capturing the metadata
keys and values that can appear in ephemeris records associated with
this data source</dd>
<dt><strong><code>data_product_metadata_schema</code></strong> :&ensp;<code>Dict</code></dt>
<dd>a list of dictionaries capturing the metadata
keys and values that can appear in data product records associated with
this data source</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>the format used when printing the data source, defaults to
"full_record". Other options are in the pyaurorax.search.sources module, or
at the top level using the pyaurorax.search.FORMAT_* variables.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataSource:
    &#34;&#34;&#34;
    AuroraX data source record

    Attributes:
        identifier (int): the unique AuroraX data source identifier
        program (str): the program for this data source
        platform (str): the platform for this data source
        instrument_type (str): the instrument type for this data source
        source_type (str): the data source type for this data source. Options are
            in the pyaurorax.search.sources module, or at the top level using the
            pyaurorax.search.SOURCE_TYPE_* variables.
        display_name (str): the display name for this data source
        metadata (Dict): metadata for this data source (arbitrary keys and values)
        owner (str): the owner&#39;s email address of this data source
        maintainers (List[str]): the email addresses of AuroraX accounts that can alter
            this data source and its associated records
        ephemeris_metadata_schema (Dict): a list of dictionaries capturing the metadata
            keys and values that can appear in ephemeris records associated with
            this data source
        data_product_metadata_schema (Dict): a list of dictionaries capturing the metadata
            keys and values that can appear in data product records associated with
            this data source
        format (str): the format used when printing the data source, defaults to
            &#34;full_record&#34;. Other options are in the pyaurorax.search.sources module, or
            at the top level using the pyaurorax.search.FORMAT_* variables.
    &#34;&#34;&#34;

    def __init__(self,
                 identifier: Optional[int] = None,
                 program: Optional[str] = None,
                 platform: Optional[str] = None,
                 instrument_type: Optional[str] = None,
                 source_type: Optional[str] = None,
                 display_name: Optional[str] = None,
                 metadata: Optional[Dict] = None,
                 owner: Optional[str] = None,
                 maintainers: Optional[List[str]] = None,
                 ephemeris_metadata_schema: Optional[List[Dict]] = None,
                 data_product_metadata_schema: Optional[List[Dict]] = None,
                 stats: Optional[DataSourceStatistics] = None,
                 format: str = FORMAT_FULL_RECORD):
        self.identifier = identifier
        self.program = program
        self.platform = platform
        self.instrument_type = instrument_type
        self.source_type = source_type
        self.display_name = display_name
        self.metadata = metadata
        self.owner = owner
        self.maintainers = maintainers
        self.ephemeris_metadata_schema = ephemeris_metadata_schema
        self.data_product_metadata_schema = data_product_metadata_schema
        self.stats = stats
        self.format = format

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        return &#34;DataSource(identifier=%s, program=&#39;%s&#39;, platform=&#39;%s&#39;, instrument_type=&#39;%s&#39;, source_type=&#39;%s&#39;, display_name=&#39;%s&#39;, ...)&#34; % (
            self.identifier,
            self.program,
            self.platform,
            self.instrument_type,
            self.source_type,
            self.display_name,
        )

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;
        max_len = 80
        print(&#34;DataSource:&#34;)
        print(&#34;  %-30s: %d&#34; % (&#34;identifier&#34;, self.identifier))
        print(&#34;  %-30s: %s&#34; % (&#34;program&#34;, self.program))
        print(&#34;  %-30s: %s&#34; % (&#34;platform&#34;, self.platform))
        print(&#34;  %-30s: %s&#34; % (&#34;instrument_type&#34;, self.instrument_type))
        print(&#34;  %-30s: %s&#34; % (&#34;source_type&#34;, self.source_type))
        print(&#34;  %-30s: %s&#34; % (&#34;display_name&#34;, self.display_name))
        print(&#34;  %-30s: %s&#34; % (&#34;metadata&#34;, self.metadata))
        print(&#34;  %-30s: %s&#34; % (&#34;owner&#34;, self.owner))
        print(&#34;  %-30s: %s&#34; % (&#34;maintainers&#34;, self.maintainers))
        if (self.ephemeris_metadata_schema is not None and len(str(self.ephemeris_metadata_schema)) &gt; max_len):
            ephemeris_metadata_schema_str = &#34;%s...&#34; % (str(self.ephemeris_metadata_schema)[0:max_len])
        else:
            ephemeris_metadata_schema_str = self.ephemeris_metadata_schema
        print(&#34;  %-30s: %s&#34; % (&#34;ephemeris_metadata_schema&#34;, ephemeris_metadata_schema_str))
        if (self.data_product_metadata_schema is not None and len(str(self.data_product_metadata_schema)) &gt; max_len):
            data_product_metadata_schema_str = &#34;%s...&#34; % (str(self.data_product_metadata_schema)[0:max_len])
        else:
            data_product_metadata_schema_str = self.data_product_metadata_schema
        print(&#34;  %-30s: %s&#34; % (&#34;data_product_metadata_schema&#34;, data_product_metadata_schema_str))
        if (self.stats is not None and len(str(self.stats)) &gt; max_len):
            stats_str = &#34;%s...&#34; % (str(self.stats)[0:max_len])
        else:
            stats_str = self.data_product_metadata_schema
        print(&#34;  %-30s: %s&#34; % (&#34;stats&#34;, stats_str))
        print(&#34;  %-30s: %s&#34; % (&#34;format&#34;, self.format))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.DataSource.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.EphemerisData"><code class="flex name class">
<span>class <span class="ident">EphemerisData</span></span>
<span>(</span><span>data_source: <a title="pyaurorax.search.sources.classes.data_source.DataSource" href="sources/classes/data_source.html#pyaurorax.search.sources.classes.data_source.DataSource">DataSource</a>,<br>epoch: datetime.datetime,<br>location_geo: <a title="pyaurorax.search.location.Location" href="location.html#pyaurorax.search.location.Location">Location</a> | None = None,<br>nbtrace: <a title="pyaurorax.search.location.Location" href="location.html#pyaurorax.search.location.Location">Location</a> | None = None,<br>sbtrace: <a title="pyaurorax.search.location.Location" href="location.html#pyaurorax.search.location.Location">Location</a> | None = None,<br>location_gsm: <a title="pyaurorax.search.location.Location" href="location.html#pyaurorax.search.location.Location">Location</a> | None = None,<br>metadata: Dict | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Ephemeris object</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>data_source</code></strong></dt>
<dd>data source that the ephemeris record is associated with</dd>
<dt><strong><code>epoch</code></strong></dt>
<dd>timestamp for the record (assumed it is in UTC)</dd>
<dt><strong><code>location_geo</code></strong></dt>
<dd>Location object containing geographic latitude and longitude</dd>
<dt><strong><code>location_gsm</code></strong></dt>
<dd>Location object containing GSM latitude and longitude (leave
empty for data sources with a type of 'ground')</dd>
<dt><strong><code>nbtrace</code></strong></dt>
<dd>Location object with north B-trace geographic latitude and longitude</dd>
<dt><strong><code>sbtrace</code></strong></dt>
<dd>Location object with south B-trace geographic latitude and longitude</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>metadata for this record (arbitrary keys and values)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EphemerisData:
    &#34;&#34;&#34;
    Ephemeris object

    Attributes:
        data_source: data source that the ephemeris record is associated with
        epoch: timestamp for the record (assumed it is in UTC)
        location_geo: Location object containing geographic latitude and longitude
        location_gsm: Location object containing GSM latitude and longitude (leave
            empty for data sources with a type of &#39;ground&#39;)
        nbtrace: Location object with north B-trace geographic latitude and longitude
        sbtrace: Location object with south B-trace geographic latitude and longitude
        metadata: metadata for this record (arbitrary keys and values)
    &#34;&#34;&#34;

    def __init__(self,
                 data_source: DataSource,
                 epoch: datetime.datetime,
                 location_geo: Optional[Location] = None,
                 nbtrace: Optional[Location] = None,
                 sbtrace: Optional[Location] = None,
                 location_gsm: Optional[Location] = None,
                 metadata: Optional[Dict] = None):
        self.data_source = data_source
        self.epoch = epoch
        self.location_geo = Location(lat=None, lon=None) if location_geo is None else location_geo
        self.nbtrace = Location(lat=None, lon=None) if nbtrace is None else nbtrace
        self.sbtrace = Location(lat=None, lon=None) if sbtrace is None else sbtrace
        self.location_gsm = Location(lat=None, lon=None) if location_gsm is None else location_gsm
        self.metadata = metadata

    def to_json_serializable(self) -&gt; Dict:
        &#34;&#34;&#34;
        Convert object to a JSON-serializable object (ie. translate
        datetime objects to strings)

        Returns:
            a dictionary object that is JSON-serializable
        &#34;&#34;&#34;
        # init
        d = self.__dict__

        # format epoch as str
        if (isinstance(d[&#34;epoch&#34;], datetime.datetime) is True):
            d[&#34;epoch&#34;] = d[&#34;epoch&#34;].strftime(&#34;%Y-%m-%dT%H:%M:00.000Z&#34;)

        # format location
        if (isinstance(d[&#34;location_geo&#34;], Location) is True):
            d[&#34;location_geo&#34;] = d[&#34;location_geo&#34;].to_json_serializable()
        if (isinstance(d[&#34;location_gsm&#34;], Location) is True):
            d[&#34;location_gsm&#34;] = d[&#34;location_gsm&#34;].to_json_serializable()
        if (isinstance(d[&#34;nbtrace&#34;], Location) is True):
            d[&#34;nbtrace&#34;] = d[&#34;nbtrace&#34;].to_json_serializable()
        if (isinstance(d[&#34;sbtrace&#34;], Location) is True):
            d[&#34;sbtrace&#34;] = d[&#34;sbtrace&#34;].to_json_serializable()

        # format metadata
        if (self.metadata is not None):
            for key, value in self.metadata.items():
                if (isinstance(value, datetime.datetime) is True or isinstance(value, datetime.date) is True):
                    self.metadata[key] = self.metadata[key].strftime(&#34;%Y-%m-%dT%H:%M:%S.%f&#34;)
        # if (isinstance(self.metadata, list) is True):
        #     self.metadata = {}

        # format data source fields for query
        d[&#34;program&#34;] = self.data_source.program
        d[&#34;platform&#34;] = self.data_source.platform
        d[&#34;instrument_type&#34;] = self.data_source.instrument_type
        del d[&#34;data_source&#34;]

        # return
        return d

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        # shorten the metadata
        max_len = 20
        attr_metadata = f&#34;{self.metadata}&#34;
        if (len(attr_metadata) &gt; max_len):
            attr_metadata = attr_metadata[0:max_len] + &#34;...}&#34;

        # return formatted representation
        return f&#34;EphemerisData(epoch={repr(self.epoch)}, location_geo={repr(self.location_geo)}, &#34; \
            f&#34;location_gsm={repr(self.location_gsm)}, nbtrace={repr(self.nbtrace)}, sbtrace={repr(self.sbtrace)}, &#34; \
            f&#34;metadata={attr_metadata}, data_source=DataSource(...))&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.EphemerisData.to_json_serializable"><code class="name flex">
<span>def <span class="ident">to_json_serializable</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Convert object to a JSON-serializable object (ie. translate
datetime objects to strings)</p>
<h2 id="returns">Returns</h2>
<p>a dictionary object that is JSON-serializable</p></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.EphemerisSearch"><code class="flex name class">
<span>class <span class="ident">EphemerisSearch</span></span>
<span>(</span><span>aurorax_obj: PyAuroraX,<br>start: datetime.datetime,<br>end: datetime.datetime,<br>programs: Optional[List[str]] = None,<br>platforms: Optional[List[str]] = None,<br>instrument_types: Optional[List[str]] = None,<br>metadata_filters: Optional[List[Dict]] = None,<br>metadata_filters_logical_operator: "Optional[Literal['AND', 'OR']]" = None,<br>response_format: Optional[Dict] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class representing an ephemeris search</p>
<p>Note: At least one search criteria from programs, platforms, or instrument_types
must be specified.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>start timestamp of the search (inclusive)</dd>
<dt><strong><code>end</code></strong></dt>
<dd>end timestamp of the search (inclusive)</dd>
<dt><strong><code>programs</code></strong></dt>
<dd>list of programs to search through, defaults to None</dd>
<dt><strong><code>platforms</code></strong></dt>
<dd>list of platforms to search through, defaults to None</dd>
<dt><strong><code>instrument_types</code></strong></dt>
<dd>list of instrument types to search through, defaults to None</dd>
<dt><strong><code>metadata_filters</code></strong></dt>
<dd>
<p>list of dictionaries describing metadata keys and
values to filter on, defaults to None</p>
<p>e.g. {
"key": "string",
"operator": "=",
"values": [
"string"
]
}</p>
</dd>
<dt><strong><code>metadata_filters_logical_operator</code></strong></dt>
<dd>the logical operator to use when
evaluating metadata filters (either 'AND' or 'OR'), defaults
to "AND"</dd>
<dt><strong><code>response_format</code></strong></dt>
<dd>JSON representation of desired data response format</dd>
<dt><strong><code>request</code></strong></dt>
<dd>AuroraXResponse object returned when the search is executed</dd>
<dt><strong><code>request_id</code></strong></dt>
<dd>unique ID assigned to the request by the AuroraX API</dd>
<dt><strong><code>request_url</code></strong></dt>
<dd>unique URL assigned to the request by the AuroraX API</dd>
<dt><strong><code>executed</code></strong></dt>
<dd>indicates if the search has been executed/started</dd>
<dt><strong><code>completed</code></strong></dt>
<dd>indicates if the search has finished</dd>
<dt><strong><code>data_url</code></strong></dt>
<dd>the URL where data is accessed</dd>
<dt><strong><code>query</code></strong></dt>
<dd>the query for this request as JSON</dd>
<dt><strong><code>status</code></strong></dt>
<dd>the status of the query</dd>
<dt><strong><code>data</code></strong></dt>
<dd>the ephemeris records found</dd>
<dt><strong><code>logs</code></strong></dt>
<dd>all log messages outputted by the AuroraX API for this request</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EphemerisSearch:
    &#34;&#34;&#34;
    Class representing an ephemeris search

    Note: At least one search criteria from programs, platforms, or instrument_types
    must be specified.

    Args:
        start: start timestamp of the search (inclusive)
        end: end timestamp of the search (inclusive)
        programs: list of programs to search through, defaults to None
        platforms: list of platforms to search through, defaults to None
        instrument_types: list of instrument types to search through, defaults to None
        metadata_filters: list of dictionaries describing metadata keys and
            values to filter on, defaults to None

            e.g. {
                &#34;key&#34;: &#34;string&#34;,
                &#34;operator&#34;: &#34;=&#34;,
                &#34;values&#34;: [
                    &#34;string&#34;
                ]
            }
        metadata_filters_logical_operator: the logical operator to use when
            evaluating metadata filters (either &#39;AND&#39; or &#39;OR&#39;), defaults
            to &#34;AND&#34;
        response_format: JSON representation of desired data response format
        request: AuroraXResponse object returned when the search is executed
        request_id: unique ID assigned to the request by the AuroraX API
        request_url: unique URL assigned to the request by the AuroraX API
        executed: indicates if the search has been executed/started
        completed: indicates if the search has finished
        data_url: the URL where data is accessed
        query: the query for this request as JSON
        status: the status of the query
        data: the ephemeris records found
        logs: all log messages outputted by the AuroraX API for this request
    &#34;&#34;&#34;

    __STANDARD_POLLING_SLEEP_TIME: float = 1.0

    def __init__(self,
                 aurorax_obj: PyAuroraX,
                 start: datetime.datetime,
                 end: datetime.datetime,
                 programs: Optional[List[str]] = None,
                 platforms: Optional[List[str]] = None,
                 instrument_types: Optional[List[str]] = None,
                 metadata_filters: Optional[List[Dict]] = None,
                 metadata_filters_logical_operator: Optional[Literal[&#34;AND&#34;, &#34;OR&#34;]] = None,
                 response_format: Optional[Dict] = None) -&gt; None:

        # set variables using passed in args
        self.aurorax_obj = aurorax_obj
        self.start = start
        self.end = end
        self.programs = programs
        self.platforms = platforms
        self.instrument_types = instrument_types
        self.metadata_filters = metadata_filters
        self.metadata_filters_logical_operator = &#34;AND&#34; if metadata_filters_logical_operator is None else metadata_filters_logical_operator
        self.response_format = response_format

        # initialize additional variables
        self.request = None
        self.request_id = &#34;&#34;
        self.request_url = &#34;&#34;
        self.executed = False
        self.completed = False
        self.data_url = &#34;&#34;
        self.query = {}
        self.status = {}
        self.data = []
        self.logs = []

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        return &#34;EphemerisSearch(executed=%s, completed=%s, request_id=&#39;%s&#39;)&#34; % (
            self.executed,
            self.completed,
            self.request_id,
        )

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;
        # set status and query strings
        max_len = 80
        status_str = str(self.status)
        query_str = str(self.query)
        if (len(status_str) &gt; max_len):
            status_str = &#34;%s...&#34; % (status_str[0:max_len])
        if (len(query_str) &gt; max_len):
            query_str = &#34;%s...&#34; % (query_str[0:max_len])

        # set results string
        if (self.executed is True):
            if (len(self.data) == 0):
                data_str = &#34;[0 ephemeris results]&#34;
            elif (len(self.data) == 1):
                data_str = &#34;[1 ephemeris result]&#34;
            else:
                data_str = &#34;[%d ephemeris results]&#34; % (len(self.data))
        else:
            data_str = &#34;&#34;

        # set logs string
        if (self.executed is True):
            if (len(self.logs) == 0):
                logs_str = &#34;[0 log messages]&#34;
            elif (len(self.logs) == 1):
                logs_str = &#34;[1 log message]&#34;
            else:
                logs_str = &#34;[%d log messages]&#34; % (len(self.logs))
        else:
            logs_str = &#34;&#34;

        # print
        print(&#34;EphemerisSearch:&#34;)
        print(&#34;  %-13s: %s&#34; % (&#34;executed&#34;, self.executed))
        print(&#34;  %-13s: %s&#34; % (&#34;completed&#34;, self.completed))
        print(&#34;  %-13s: %s&#34; % (&#34;request_id&#34;, self.request_id))
        print(&#34;  %-13s: %s&#34; % (&#34;request&#34;, self.request))
        print(&#34;  %-13s: %s&#34; % (&#34;request_url&#34;, self.request_url))
        print(&#34;  %-13s: %s&#34; % (&#34;data_url&#34;, self.data_url))
        print(&#34;  %-13s: %s&#34; % (&#34;query&#34;, query_str))
        print(&#34;  %-13s: %s&#34; % (&#34;status&#34;, status_str))
        print(&#34;  %-13s: %s&#34; % (&#34;data&#34;, data_str))
        print(&#34;  %-13s: %s&#34; % (&#34;logs&#34;, logs_str))

    @property
    def query(self):
        &#34;&#34;&#34;
        Property for the query value
        &#34;&#34;&#34;
        self._query = {
            &#34;data_sources&#34;: {
                &#34;programs&#34;: [] if not self.programs else self.programs,
                &#34;platforms&#34;: [] if not self.platforms else self.platforms,
                &#34;instrument_types&#34;: [] if not self.instrument_types else self.instrument_types,
                &#34;ephemeris_metadata_filters&#34;: {} if not self.metadata_filters else {
                    &#34;logical_operator&#34;: self.metadata_filters_logical_operator,
                    &#34;expressions&#34;: self.metadata_filters
                },
            },
            &#34;start&#34;: self.start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
            &#34;end&#34;: self.end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        }
        return self._query

    @query.setter
    def query(self, query):
        self._query = query

    def execute(self) -&gt; None:
        &#34;&#34;&#34;
        Initiate ephemeris search request

        Raises:
            pyaurorax.exceptions.AuroraXError: invalid request parameters are set
        &#34;&#34;&#34;
        # check for at least one filter criteria
        if not (self.programs or self.platforms or self.instrument_types or self.metadata_filters):
            raise AuroraXError(&#34;At least one filter criteria parameter besides &#39;start&#39; and &#39;end&#39; must be specified&#34;)

        # do request
        url = &#34;%s/%s&#34; % (self.aurorax_obj.api_base_url, self.aurorax_obj.search.api.URL_SUFFIX_EPHEMERIS_SEARCH)
        req = AuroraXAPIRequest(self.aurorax_obj, method=&#34;post&#34;, url=url, body=self.query, null_response=True)
        res = req.execute()

        # set request ID, request_url, executed
        self.executed = True
        if (res.status_code == 202):
            # request successfully dispatched
            self.executed = True
            self.request_url = res.request.headers[&#34;location&#34;]
            self.request_id = self.request_url.rsplit(&#34;/&#34;, 1)[-1]

        # set the request variable
        self.request = res

    def update_status(self, status: Optional[Dict] = None) -&gt; None:
        &#34;&#34;&#34;
        Update the status of this ephemeris search request

        Args:
            status: the previously-retrieved status of this request (include
                to avoid requesting it from the API again), defaults to None
        &#34;&#34;&#34;
        # get the status if it isn&#39;t passed in
        if (status is None):
            status = requests_get_status(self.aurorax_obj, self.request_url)

        # check response
        if (status is None):
            raise AuroraXAPIError(&#34;Could not retrieve status for this request&#34;)

        # update request status by checking if data URI is set
        if (status[&#34;search_result&#34;][&#34;data_uri&#34;] is not None):
            self.completed = True
            self.data_url = &#34;%s/data&#34; % (self.request_url)

        # set class variable &#34;status&#34; and &#34;logs&#34;
        self.status = status
        self.logs = status[&#34;logs&#34;]

    def check_for_data(self) -&gt; bool:
        &#34;&#34;&#34;
        Check to see if data is available for this ephemeris
        search request

        Returns:
            True if data is available, else False
        &#34;&#34;&#34;
        self.update_status()
        return self.completed

    def get_data(self) -&gt; None:
        &#34;&#34;&#34;
        Retrieve the data available for this ephemeris search request
        &#34;&#34;&#34;
        # check if completed yet
        if (self.completed is False):
            print(&#34;No data available, update status or check for data first&#34;)
            return

        # get data
        raw_data = requests_get_data(self.aurorax_obj, self.data_url, self.response_format, False)

        # set data variable
        if (self.response_format is not None):
            self.data = raw_data
        else:
            # cast data source objects
            for i in range(0, len(raw_data)):
                ds = DataSource(**raw_data[i][&#34;data_source&#34;], format=FORMAT_BASIC_INFO)
                raw_data[i][&#34;data_source&#34;] = ds

            # cast ephemeris objects
            self.data = [EphemerisData(**e) for e in raw_data]

    def wait(self, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Block and wait for the request to complete and data is
        available for retrieval

        Args:
            poll_interval: time in seconds to wait between polling attempts,
                defaults to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME
            verbose: output poll times and other progress messages, defaults
                to False
        &#34;&#34;&#34;
        url = &#34;%s/%s&#34; % (self.aurorax_obj.api_base_url, self.aurorax_obj.search.api.URL_SUFFIX_EPHEMERIS_REQUEST.format(self.request_id))
        self.update_status(requests_wait_for_data(self.aurorax_obj, url, poll_interval, verbose))

    def cancel(self, wait: bool = False, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; int:
        &#34;&#34;&#34;
        Cancel the ephemeris search request

        This method returns immediately by default since the API processes
        this request asynchronously. If you would prefer to wait for it
        to be completed, set the &#39;wait&#39; parameter to True. You can adjust
        the polling time using the &#39;poll_interval&#39; parameter.

        Args:
            wait: wait until the cancellation request has been
                completed (may wait for several minutes)
            poll_interval: seconds to wait between polling
                calls, defaults to STANDARD_POLLING_SLEEP_TIME.
            verbose: output poll times and other progress messages, defaults
                to False

        Returns:
            1 on success

        Raises:
            pyaurorax.exceptions.AuroraXUnauthorizedError: invalid API key for this operation
            pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
        &#34;&#34;&#34;
        url = &#34;%s/%s&#34; % (self.aurorax_obj.api_base_url, self.aurorax_obj.search.api.URL_SUFFIX_EPHEMERIS_REQUEST.format(self.request_id))
        return requests_cancel(self.aurorax_obj, url, wait, poll_interval, verbose)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyaurorax.search.EphemerisSearch.query"><code class="name">prop <span class="ident">query</span></code></dt>
<dd>
<div class="desc"><p>Property for the query value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def query(self):
    &#34;&#34;&#34;
    Property for the query value
    &#34;&#34;&#34;
    self._query = {
        &#34;data_sources&#34;: {
            &#34;programs&#34;: [] if not self.programs else self.programs,
            &#34;platforms&#34;: [] if not self.platforms else self.platforms,
            &#34;instrument_types&#34;: [] if not self.instrument_types else self.instrument_types,
            &#34;ephemeris_metadata_filters&#34;: {} if not self.metadata_filters else {
                &#34;logical_operator&#34;: self.metadata_filters_logical_operator,
                &#34;expressions&#34;: self.metadata_filters
            },
        },
        &#34;start&#34;: self.start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        &#34;end&#34;: self.end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
    }
    return self._query</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.EphemerisSearch.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self, wait: bool = False, poll_interval: float = 1.0, verbose: bool = False) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Cancel the ephemeris search request</p>
<p>This method returns immediately by default since the API processes
this request asynchronously. If you would prefer to wait for it
to be completed, set the 'wait' parameter to True. You can adjust
the polling time using the 'poll_interval' parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wait</code></strong></dt>
<dd>wait until the cancellation request has been
completed (may wait for several minutes)</dd>
<dt><strong><code>poll_interval</code></strong></dt>
<dd>seconds to wait between polling
calls, defaults to STANDARD_POLLING_SLEEP_TIME.</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>output poll times and other progress messages, defaults
to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>1 on success</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnauthorizedError" href="../exceptions.html#pyaurorax.exceptions.AuroraXUnauthorizedError">AuroraXUnauthorizedError</a></code></dt>
<dd>invalid API key for this operation</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXAPIError" href="../exceptions.html#pyaurorax.exceptions.AuroraXAPIError">AuroraXAPIError</a></code></dt>
<dd>An API error was encountered</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.EphemerisSearch.check_for_data"><code class="name flex">
<span>def <span class="ident">check_for_data</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check to see if data is available for this ephemeris
search request</p>
<h2 id="returns">Returns</h2>
<p>True if data is available, else False</p></div>
</dd>
<dt id="pyaurorax.search.EphemerisSearch.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initiate ephemeris search request</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXError" href="../exceptions.html#pyaurorax.exceptions.AuroraXError">AuroraXError</a></code></dt>
<dd>invalid request parameters are set</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.EphemerisSearch.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the data available for this ephemeris search request</p></div>
</dd>
<dt id="pyaurorax.search.EphemerisSearch.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
<dt id="pyaurorax.search.EphemerisSearch.update_status"><code class="name flex">
<span>def <span class="ident">update_status</span></span>(<span>self, status: Optional[Dict] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Update the status of this ephemeris search request</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>status</code></strong></dt>
<dd>the previously-retrieved status of this request (include
to avoid requesting it from the API again), defaults to None</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.EphemerisSearch.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span>(<span>self, poll_interval: float = 1.0, verbose: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Block and wait for the request to complete and data is
available for retrieval</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>poll_interval</code></strong></dt>
<dd>time in seconds to wait between polling attempts,
defaults to pyaurorax.requests.STANDARD_POLLING_SLEEP_TIME</dd>
<dt><strong><code>verbose</code></strong></dt>
<dd>output poll times and other progress messages, defaults
to False</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.Location"><code class="flex name class">
<span>class <span class="ident">Location</span></span>
<span>(</span><span>lat: float | None = None, lon: float | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Representation for an AuroraX location, such as geographic coordinates, GSM coordinates,
or northern/southern B-trace magnetic footprints.</p>
<p>Latitude and longitude values are in decimal degrees format, ranging from -90 to 90
for latitude and -180 to 180 for longitude.</p>
<p>Note that latitude and longitude must both be numbers, or both be None.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>lat</code></strong> :&ensp;<code>float</code></dt>
<dd>latitude value</dd>
<dt><strong><code>lon</code></strong> :&ensp;<code>float</code></dt>
<dd>longitude value</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if both latitude and longitude are not real numbers, or not both None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Location:
    &#34;&#34;&#34;
    Representation for an AuroraX location, such as geographic coordinates, GSM coordinates,
    or northern/southern B-trace magnetic footprints.

    Latitude and longitude values are in decimal degrees format, ranging from -90 to 90
    for latitude and -180 to 180 for longitude.

    Note that latitude and longitude must both be numbers, or both be None.

    Attributes:
        lat (float): latitude value
        lon (float): longitude value
    
    Raises:
        ValueError: if both latitude and longitude are not real numbers, or not both None.
    &#34;&#34;&#34;

    def __init__(self, lat: Optional[float] = None, lon: Optional[float] = None):
        if (lat is None and lon is not None) or (lat is not None and lon is None):
            # one of them is None, not allowed
            raise ValueError(&#34;Latitude and longitude must both be numbers, or both be None&#34;)
        self.__lat = lat
        self.__lon = lon

    @property
    def lat(self):
        return self.__lat

    @lat.setter
    def lat(self, value: float):
        if (self.__lon is None and value is not None) or (self.__lon is not None and value is None):
            # one of them is None, not allowed
            raise ValueError(&#34;Latitude and longitude must both be numbers, or both be None&#34;)
        self.__lat = value

    @property
    def lon(self):
        return self.__lon

    @lon.setter
    def lon(self, value: float):
        if (self.__lat is None and value is not None) or (self.__lat is not None and value is None):
            # one of them is None, not allowed
            raise ValueError(&#34;Latitude and longitude must both be numbers, or both be None&#34;)
        self.__lon = value

    def to_json_serializable(self) -&gt; Dict:
        &#34;&#34;&#34;
        Convert object to a JSON-serializable object (ie. translate
        datetime objects to strings)

        Returns:
            a dictionary object that is JSON-serializable
        &#34;&#34;&#34;
        return {&#34;lat&#34;: self.lat, &#34;lon&#34;: self.lon}

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        return &#34;%s(lat=%s, lon=%s)&#34; % (self.__class__.__name__, str(self.lat), str(self.lon))</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyaurorax.search.Location.lat"><code class="name">prop <span class="ident">lat</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lat(self):
    return self.__lat</code></pre>
</details>
</dd>
<dt id="pyaurorax.search.Location.lon"><code class="name">prop <span class="ident">lon</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lon(self):
    return self.__lon</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.Location.to_json_serializable"><code class="name flex">
<span>def <span class="ident">to_json_serializable</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Convert object to a JSON-serializable object (ie. translate
datetime objects to strings)</p>
<h2 id="returns">Returns</h2>
<p>a dictionary object that is JSON-serializable</p></div>
</dd>
</dl>
</dd>
<dt id="pyaurorax.search.SearchManager"><code class="flex name class">
<span>class <span class="ident">SearchManager</span></span>
<span>(</span><span>aurorax_obj)</span>
</code></dt>
<dd>
<div class="desc"><p>The SearchManager object is initialized within every PyAuroraX object. It acts as a way to access
the submodules and carry over configuration information in the super class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SearchManager:
    &#34;&#34;&#34;
    The SearchManager object is initialized within every PyAuroraX object. It acts as a way to access 
    the submodules and carry over configuration information in the super class.
    &#34;&#34;&#34;

    def __init__(self, aurorax_obj):
        self.__aurorax_obj = aurorax_obj

        # initialize sub-modules
        self.__util = UtilManager()
        self.__api = module_api
        self.__sources = SourcesManager(self.__aurorax_obj)
        self.__availability = AvailabilityManager(self.__aurorax_obj)
        self.__metadata = MetadataManager(self.__aurorax_obj)
        self.__requests = RequestsManager(self.__aurorax_obj)
        self.__ephemeris = EphemerisManager(self.__aurorax_obj)
        self.__data_products = DataProductsManager(self.__aurorax_obj)
        self.__conjunctions = ConjunctionsManager(self.__aurorax_obj)

    # ------------------------------------------
    # properties for submodule managers
    # ------------------------------------------
    @property
    def util(self):
        &#34;&#34;&#34;
        Access to the `util` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__util

    @property
    def api(self):
        &#34;&#34;&#34;
        Access to the `api` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__api

    @property
    def sources(self):
        &#34;&#34;&#34;
        Access to the `sources` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__sources

    @property
    def availability(self):
        &#34;&#34;&#34;
        Access to the `availability` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__availability

    @property
    def metadata(self):
        &#34;&#34;&#34;
        Access to the `metadata` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__metadata

    @property
    def requests(self):
        &#34;&#34;&#34;
        Access to the `requests` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__requests

    @property
    def ephemeris(self):
        &#34;&#34;&#34;
        Access to the `ephemeris` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__ephemeris

    @property
    def data_products(self):
        &#34;&#34;&#34;
        Access to the `data_products` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__data_products

    @property
    def conjunctions(self):
        &#34;&#34;&#34;
        Access to the `conjunctions` submodule from within a PyAuroraX object.
        &#34;&#34;&#34;
        return self.__conjunctions</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyaurorax.search.SearchManager.api"><code class="name">prop <span class="ident">api</span></code></dt>
<dd>
<div class="desc"><p>Access to the <code><a title="pyaurorax.search.api" href="api/index.html">pyaurorax.search.api</a></code> submodule from within a PyAuroraX object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def api(self):
    &#34;&#34;&#34;
    Access to the `api` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__api</code></pre>
</details>
</dd>
<dt id="pyaurorax.search.SearchManager.availability"><code class="name">prop <span class="ident">availability</span></code></dt>
<dd>
<div class="desc"><p>Access to the <code><a title="pyaurorax.search.availability" href="availability/index.html">pyaurorax.search.availability</a></code> submodule from within a PyAuroraX object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def availability(self):
    &#34;&#34;&#34;
    Access to the `availability` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__availability</code></pre>
</details>
</dd>
<dt id="pyaurorax.search.SearchManager.conjunctions"><code class="name">prop <span class="ident">conjunctions</span></code></dt>
<dd>
<div class="desc"><p>Access to the <code><a title="pyaurorax.search.conjunctions" href="conjunctions/index.html">pyaurorax.search.conjunctions</a></code> submodule from within a PyAuroraX object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def conjunctions(self):
    &#34;&#34;&#34;
    Access to the `conjunctions` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__conjunctions</code></pre>
</details>
</dd>
<dt id="pyaurorax.search.SearchManager.data_products"><code class="name">prop <span class="ident">data_products</span></code></dt>
<dd>
<div class="desc"><p>Access to the <code><a title="pyaurorax.search.data_products" href="data_products/index.html">pyaurorax.search.data_products</a></code> submodule from within a PyAuroraX object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_products(self):
    &#34;&#34;&#34;
    Access to the `data_products` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__data_products</code></pre>
</details>
</dd>
<dt id="pyaurorax.search.SearchManager.ephemeris"><code class="name">prop <span class="ident">ephemeris</span></code></dt>
<dd>
<div class="desc"><p>Access to the <code><a title="pyaurorax.search.ephemeris" href="ephemeris/index.html">pyaurorax.search.ephemeris</a></code> submodule from within a PyAuroraX object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ephemeris(self):
    &#34;&#34;&#34;
    Access to the `ephemeris` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__ephemeris</code></pre>
</details>
</dd>
<dt id="pyaurorax.search.SearchManager.metadata"><code class="name">prop <span class="ident">metadata</span></code></dt>
<dd>
<div class="desc"><p>Access to the <code><a title="pyaurorax.search.metadata" href="metadata/index.html">pyaurorax.search.metadata</a></code> submodule from within a PyAuroraX object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def metadata(self):
    &#34;&#34;&#34;
    Access to the `metadata` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__metadata</code></pre>
</details>
</dd>
<dt id="pyaurorax.search.SearchManager.requests"><code class="name">prop <span class="ident">requests</span></code></dt>
<dd>
<div class="desc"><p>Access to the <code><a title="pyaurorax.search.requests" href="requests/index.html">pyaurorax.search.requests</a></code> submodule from within a PyAuroraX object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def requests(self):
    &#34;&#34;&#34;
    Access to the `requests` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__requests</code></pre>
</details>
</dd>
<dt id="pyaurorax.search.SearchManager.sources"><code class="name">prop <span class="ident">sources</span></code></dt>
<dd>
<div class="desc"><p>Access to the <code><a title="pyaurorax.search.sources" href="sources/index.html">pyaurorax.search.sources</a></code> submodule from within a PyAuroraX object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sources(self):
    &#34;&#34;&#34;
    Access to the `sources` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__sources</code></pre>
</details>
</dd>
<dt id="pyaurorax.search.SearchManager.util"><code class="name">prop <span class="ident">util</span></code></dt>
<dd>
<div class="desc"><p>Access to the <code><a title="pyaurorax.search.util" href="util/index.html">pyaurorax.search.util</a></code> submodule from within a PyAuroraX object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def util(self):
    &#34;&#34;&#34;
    Access to the `util` submodule from within a PyAuroraX object.
    &#34;&#34;&#34;
    return self.__util</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.css" integrity="sha512-b+T2i3P45i1LZM7I00Ci5QquB9szqaxu+uuk5TUSGjZQ4w4n+qujQiIuvTv2BxE7WCGQCifNMksyKILDiHzsOg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.js" integrity="sha512-2B9/byNV1KKRm5nQ2RLViPFD6U4dUjDGwuW1GU+ImJh8YinPU9Zlq1GzdTMO+G2ROrB5o1qasJBy1ttYz0wCug==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyaurorax" href="../index.html">pyaurorax</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pyaurorax.search.api" href="api/index.html">pyaurorax.search.api</a></code></li>
<li><code><a title="pyaurorax.search.availability" href="availability/index.html">pyaurorax.search.availability</a></code></li>
<li><code><a title="pyaurorax.search.conjunctions" href="conjunctions/index.html">pyaurorax.search.conjunctions</a></code></li>
<li><code><a title="pyaurorax.search.data_products" href="data_products/index.html">pyaurorax.search.data_products</a></code></li>
<li><code><a title="pyaurorax.search.ephemeris" href="ephemeris/index.html">pyaurorax.search.ephemeris</a></code></li>
<li><code><a title="pyaurorax.search.location" href="location.html">pyaurorax.search.location</a></code></li>
<li><code><a title="pyaurorax.search.metadata" href="metadata/index.html">pyaurorax.search.metadata</a></code></li>
<li><code><a title="pyaurorax.search.requests" href="requests/index.html">pyaurorax.search.requests</a></code></li>
<li><code><a title="pyaurorax.search.sources" href="sources/index.html">pyaurorax.search.sources</a></code></li>
<li><code><a title="pyaurorax.search.util" href="util/index.html">pyaurorax.search.util</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyaurorax.search.AvailabilityResult" href="#pyaurorax.search.AvailabilityResult">AvailabilityResult</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.search.AvailabilityResult.available_data_products" href="#pyaurorax.search.AvailabilityResult.available_data_products">available_data_products</a></code></li>
<li><code><a title="pyaurorax.search.AvailabilityResult.available_ephemeris" href="#pyaurorax.search.AvailabilityResult.available_ephemeris">available_ephemeris</a></code></li>
<li><code><a title="pyaurorax.search.AvailabilityResult.data_source" href="#pyaurorax.search.AvailabilityResult.data_source">data_source</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.Conjunction" href="#pyaurorax.search.Conjunction">Conjunction</a></code></h4>
</li>
<li>
<h4><code><a title="pyaurorax.search.ConjunctionSearch" href="#pyaurorax.search.ConjunctionSearch">ConjunctionSearch</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.search.ConjunctionSearch.cancel" href="#pyaurorax.search.ConjunctionSearch.cancel">cancel</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.check_criteria_block_count_validity" href="#pyaurorax.search.ConjunctionSearch.check_criteria_block_count_validity">check_criteria_block_count_validity</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.check_for_data" href="#pyaurorax.search.ConjunctionSearch.check_for_data">check_for_data</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.distance" href="#pyaurorax.search.ConjunctionSearch.distance">distance</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.execute" href="#pyaurorax.search.ConjunctionSearch.execute">execute</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.get_advanced_distances_combos" href="#pyaurorax.search.ConjunctionSearch.get_advanced_distances_combos">get_advanced_distances_combos</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.get_data" href="#pyaurorax.search.ConjunctionSearch.get_data">get_data</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.pretty_print" href="#pyaurorax.search.ConjunctionSearch.pretty_print">pretty_print</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.query" href="#pyaurorax.search.ConjunctionSearch.query">query</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.update_status" href="#pyaurorax.search.ConjunctionSearch.update_status">update_status</a></code></li>
<li><code><a title="pyaurorax.search.ConjunctionSearch.wait" href="#pyaurorax.search.ConjunctionSearch.wait">wait</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.DataProductData" href="#pyaurorax.search.DataProductData">DataProductData</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.search.DataProductData.to_json_serializable" href="#pyaurorax.search.DataProductData.to_json_serializable">to_json_serializable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.DataProductSearch" href="#pyaurorax.search.DataProductSearch">DataProductSearch</a></code></h4>
<ul class="two-column">
<li><code><a title="pyaurorax.search.DataProductSearch.cancel" href="#pyaurorax.search.DataProductSearch.cancel">cancel</a></code></li>
<li><code><a title="pyaurorax.search.DataProductSearch.check_for_data" href="#pyaurorax.search.DataProductSearch.check_for_data">check_for_data</a></code></li>
<li><code><a title="pyaurorax.search.DataProductSearch.execute" href="#pyaurorax.search.DataProductSearch.execute">execute</a></code></li>
<li><code><a title="pyaurorax.search.DataProductSearch.get_data" href="#pyaurorax.search.DataProductSearch.get_data">get_data</a></code></li>
<li><code><a title="pyaurorax.search.DataProductSearch.pretty_print" href="#pyaurorax.search.DataProductSearch.pretty_print">pretty_print</a></code></li>
<li><code><a title="pyaurorax.search.DataProductSearch.query" href="#pyaurorax.search.DataProductSearch.query">query</a></code></li>
<li><code><a title="pyaurorax.search.DataProductSearch.update_status" href="#pyaurorax.search.DataProductSearch.update_status">update_status</a></code></li>
<li><code><a title="pyaurorax.search.DataProductSearch.wait" href="#pyaurorax.search.DataProductSearch.wait">wait</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.DataSource" href="#pyaurorax.search.DataSource">DataSource</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.search.DataSource.pretty_print" href="#pyaurorax.search.DataSource.pretty_print">pretty_print</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.EphemerisData" href="#pyaurorax.search.EphemerisData">EphemerisData</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.search.EphemerisData.to_json_serializable" href="#pyaurorax.search.EphemerisData.to_json_serializable">to_json_serializable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.EphemerisSearch" href="#pyaurorax.search.EphemerisSearch">EphemerisSearch</a></code></h4>
<ul class="two-column">
<li><code><a title="pyaurorax.search.EphemerisSearch.cancel" href="#pyaurorax.search.EphemerisSearch.cancel">cancel</a></code></li>
<li><code><a title="pyaurorax.search.EphemerisSearch.check_for_data" href="#pyaurorax.search.EphemerisSearch.check_for_data">check_for_data</a></code></li>
<li><code><a title="pyaurorax.search.EphemerisSearch.execute" href="#pyaurorax.search.EphemerisSearch.execute">execute</a></code></li>
<li><code><a title="pyaurorax.search.EphemerisSearch.get_data" href="#pyaurorax.search.EphemerisSearch.get_data">get_data</a></code></li>
<li><code><a title="pyaurorax.search.EphemerisSearch.pretty_print" href="#pyaurorax.search.EphemerisSearch.pretty_print">pretty_print</a></code></li>
<li><code><a title="pyaurorax.search.EphemerisSearch.query" href="#pyaurorax.search.EphemerisSearch.query">query</a></code></li>
<li><code><a title="pyaurorax.search.EphemerisSearch.update_status" href="#pyaurorax.search.EphemerisSearch.update_status">update_status</a></code></li>
<li><code><a title="pyaurorax.search.EphemerisSearch.wait" href="#pyaurorax.search.EphemerisSearch.wait">wait</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.Location" href="#pyaurorax.search.Location">Location</a></code></h4>
<ul class="">
<li><code><a title="pyaurorax.search.Location.lat" href="#pyaurorax.search.Location.lat">lat</a></code></li>
<li><code><a title="pyaurorax.search.Location.lon" href="#pyaurorax.search.Location.lon">lon</a></code></li>
<li><code><a title="pyaurorax.search.Location.to_json_serializable" href="#pyaurorax.search.Location.to_json_serializable">to_json_serializable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyaurorax.search.SearchManager" href="#pyaurorax.search.SearchManager">SearchManager</a></code></h4>
<ul class="two-column">
<li><code><a title="pyaurorax.search.SearchManager.api" href="#pyaurorax.search.SearchManager.api">api</a></code></li>
<li><code><a title="pyaurorax.search.SearchManager.availability" href="#pyaurorax.search.SearchManager.availability">availability</a></code></li>
<li><code><a title="pyaurorax.search.SearchManager.conjunctions" href="#pyaurorax.search.SearchManager.conjunctions">conjunctions</a></code></li>
<li><code><a title="pyaurorax.search.SearchManager.data_products" href="#pyaurorax.search.SearchManager.data_products">data_products</a></code></li>
<li><code><a title="pyaurorax.search.SearchManager.ephemeris" href="#pyaurorax.search.SearchManager.ephemeris">ephemeris</a></code></li>
<li><code><a title="pyaurorax.search.SearchManager.metadata" href="#pyaurorax.search.SearchManager.metadata">metadata</a></code></li>
<li><code><a title="pyaurorax.search.SearchManager.requests" href="#pyaurorax.search.SearchManager.requests">requests</a></code></li>
<li><code><a title="pyaurorax.search.SearchManager.sources" href="#pyaurorax.search.SearchManager.sources">sources</a></code></li>
<li><code><a title="pyaurorax.search.SearchManager.util" href="#pyaurorax.search.SearchManager.util">util</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.3</a>.</p>
</footer>
</body>
</html>
