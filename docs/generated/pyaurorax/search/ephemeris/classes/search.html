<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>pyaurorax.search.ephemeris.classes.search API documentation</title>
<meta name="description" content="Class definition for an ephemeris search">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
<style>
@media screen and (max-width: 699px) {
#content {
padding-left: 2em;
padding-right: 2em;
padding-top: 0;
}
}
@media screen and (min-width: 700px) {
#content {
max-width: 125ch;
padding-left: 3em;
padding-right: 3em;
padding-top: 1em;
border-left: 1px solid #ddd;
}
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyaurorax.search.ephemeris.classes.search</code></h1>
</header>
<section id="section-intro">
<p>Class definition for an ephemeris search</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyaurorax.search.ephemeris.classes.search.EphemerisSearch"><code class="flex name class">
<span>class <span class="ident">EphemerisSearch</span></span>
<span>(</span><span>aurorax_obj:Â PyAuroraX,<br>start:Â datetime.datetime,<br>end:Â datetime.datetime,<br>programs:Â Optional[List[str]]Â =Â None,<br>platforms:Â Optional[List[str]]Â =Â None,<br>instrument_types:Â Optional[List[str]]Â =Â None,<br>metadata_filters:Â Optional[Union[MetadataFilter,Â List[Dict]]]Â =Â None,<br>metadata_filters_logical_operator:Â "Optional[Literal['and',Â 'or',Â 'AND',Â 'OR']]"Â =Â None,<br>response_format:Â Optional[Dict]Â =Â None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EphemerisSearch:
    &#34;&#34;&#34;
    Class representing an ephemeris search

    Note: At least one search criteria from programs, platforms, or instrument_types
    must be specified.

    Attributes:
        start (datetime.datetime): 
            Start timestamp of the search (inclusive)

        end (datetime.datetime): 
            End timestamp of the search (inclusive)

        programs (List[str]): 
            List of programs to search through, defaults to None

        platforms (List[str]): 
            List of platforms to search through, defaults to None

        instrument_types (List[str]): 
            List of instrument types to search through, defaults to None

        metadata_filters (MetadataFilter or List[Dict]): 
            List of dictionaries describing metadata keys and values to filter on, defaults 
            to None

        metadata_filters_logical_operator (str): 
            The logical operator to use when evaluating metadata filters (either `AND` or `OR`), 
            defaults to `AND`

        response_format (Dict): 
            JSON representation of desired data response format
        
        request (AuroraXResponse): 
            AuroraXResponse object returned when the search is executed
        
        request_id (str): 
            Unique ID assigned to the request by the AuroraX API
       
        request_url (str): 
            Unique URL assigned to the request by the AuroraX API
     
        executed (bool): 
            Indicates if the search has been executed/started
     
        completed (bool): 
            Indicates if the search has finished
       
        data_url (str): 
            The URL where data is accessed
      
        query (Dict): 
            The query for this request as JSON
      
        status (Dict): 
            The status of the query
      
        data (List[EphemerisData]): 
            The ephemeris records found
      
        logs (List[Dict]): 
            All log messages outputted by the AuroraX API for this request
    &#34;&#34;&#34;

    __STANDARD_POLLING_SLEEP_TIME: float = 1.0

    def __init__(self,
                 aurorax_obj: PyAuroraX,
                 start: datetime.datetime,
                 end: datetime.datetime,
                 programs: Optional[List[str]] = None,
                 platforms: Optional[List[str]] = None,
                 instrument_types: Optional[List[str]] = None,
                 metadata_filters: Optional[Union[MetadataFilter, List[Dict]]] = None,
                 metadata_filters_logical_operator: Optional[Literal[&#34;and&#34;, &#34;or&#34;, &#34;AND&#34;, &#34;OR&#34;]] = None,
                 response_format: Optional[Dict] = None) -&gt; None:

        # show warnings
        if (isinstance(metadata_filters, MetadataFilter) and metadata_filters_logical_operator is not None):
            # logical operator supplied, but MetadataFilter supplied too
            show_warning(&#34;Supplying a MetadataFilter object in addition to the metadata_filters_logical_operator &#34; +
                         &#34;parameter is redundant. Only the MetadataFilter object is needed. The &#34; +
                         &#34;metadata_filters_logical_operator parameter will be ignored&#34;)

        # set variables using passed in args
        self.__aurorax_obj = aurorax_obj
        self.start = start
        self.end = end
        self.programs = programs
        self.platforms = platforms
        self.instrument_types = instrument_types
        self.metadata_filters = metadata_filters
        self.metadata_filters_logical_operator = &#34;AND&#34; if metadata_filters_logical_operator is None else metadata_filters_logical_operator.upper()
        self.response_format = response_format

        # initialize additional variables
        self.request = None
        self.request_id = &#34;&#34;
        self.request_url = &#34;&#34;
        self.executed = False
        self.completed = False
        self.data_url = &#34;&#34;
        self.__query = {}
        self.status = {}
        self.data = []
        self.logs = []

    def __str__(self) -&gt; str:
        return self.__repr__()

    def __repr__(self) -&gt; str:
        return &#34;EphemerisSearch(executed=%s, completed=%s, request_id=&#39;%s&#39;)&#34; % (
            self.executed,
            self.completed,
            self.request_id,
        )

    def pretty_print(self):
        &#34;&#34;&#34;
        A special print output for this class.
        &#34;&#34;&#34;
        # set status and query strings
        max_len = 80
        status_str = str(self.status)
        query_str = str(self.query)
        if (len(status_str) &gt; max_len):
            status_str = &#34;%s...&#34; % (status_str[0:max_len])
        if (len(query_str) &gt; max_len):
            query_str = &#34;%s...&#34; % (query_str[0:max_len])

        # set results string
        if (self.executed is True):
            if (len(self.data) == 1):
                data_str = &#34;[1 ephemeris result]&#34;
            else:
                data_str = &#34;[%d ephemeris results]&#34; % (len(self.data))
        else:
            data_str = &#34;&#34;

        # set logs string
        if (self.executed is True):
            if (len(self.logs) == 1):  # pragma: nocover-ok
                logs_str = &#34;[1 log message]&#34;
            else:
                logs_str = &#34;[%d log messages]&#34; % (len(self.logs))
        else:
            logs_str = &#34;&#34;

        # print
        print(&#34;EphemerisSearch:&#34;)
        print(&#34;  %-13s: %s&#34; % (&#34;executed&#34;, self.executed))
        print(&#34;  %-13s: %s&#34; % (&#34;completed&#34;, self.completed))
        print(&#34;  %-13s: %s&#34; % (&#34;request_id&#34;, self.request_id))
        print(&#34;  %-13s: %s&#34; % (&#34;request&#34;, self.request))
        print(&#34;  %-13s: %s&#34; % (&#34;request_url&#34;, self.request_url))
        print(&#34;  %-13s: %s&#34; % (&#34;data_url&#34;, self.data_url))
        print(&#34;  %-13s: %s&#34; % (&#34;query&#34;, query_str))
        print(&#34;  %-13s: %s&#34; % (&#34;status&#34;, status_str))
        print(&#34;  %-13s: %s&#34; % (&#34;data&#34;, data_str))
        print(&#34;  %-13s: %s&#34; % (&#34;logs&#34;, logs_str))

    @property
    def query(self):
        &#34;&#34;&#34;
        Property for the query value
        &#34;&#34;&#34;
        # set metadata filter value
        if (self.metadata_filters is None):
            metadata_filters_dict = {}
        elif (isinstance(self.metadata_filters, MetadataFilter) is True):
            # metadata filter is a class
            metadata_filters_dict = self.metadata_filters.to_query_dict()  # type: ignore
        else:
            # metadata filter is a dictionary
            metadata_filters_dict = {
                &#34;expressions&#34;: self.metadata_filters,
                &#34;logical_operator&#34;: self.metadata_filters_logical_operator,
            }

        # set query
        self.__query = {
            &#34;data_sources&#34;: {
                &#34;programs&#34;: [] if not self.programs else self.programs,
                &#34;platforms&#34;: [] if not self.platforms else self.platforms,
                &#34;instrument_types&#34;: [] if not self.instrument_types else self.instrument_types,
                &#34;ephemeris_metadata_filters&#34;: metadata_filters_dict,
            },
            &#34;start&#34;: self.start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
            &#34;end&#34;: self.end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        }

        # return
        return self.__query

    def execute(self) -&gt; None:
        &#34;&#34;&#34;
        Initiate ephemeris search request

        Raises:
            pyaurorax.exceptions.AuroraXError: Invalid request parameters are set
        &#34;&#34;&#34;
        # check for at least one filter criteria
        if not (self.programs or self.platforms or self.instrument_types or self.metadata_filters):  # pragma: nocover-ok
            raise AuroraXError(&#34;At least one filter criteria parameter besides &#39;start&#39; and &#39;end&#39; must be specified&#34;)

        # do request
        url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_EPHEMERIS_SEARCH)
        req = AuroraXAPIRequest(self.__aurorax_obj, method=&#34;post&#34;, url=url, body=self.query, null_response=True)
        res = req.execute()

        # set request ID, request_url, executed
        self.executed = True
        if (res.status_code == 202):
            # request successfully dispatched
            self.executed = True
            self.request_url = res.request.headers[&#34;location&#34;]
            self.request_id = self.request_url.rsplit(&#34;/&#34;, 1)[-1]

        # set the request variable
        self.request = res

    def update_status(self, status: Optional[Dict] = None) -&gt; None:
        &#34;&#34;&#34;
        Update the status of this ephemeris search request

        Args:
            status (Dict): 
                The previously-retrieved status of this request (include to avoid requesting it 
                from the API again), defaults to None
        &#34;&#34;&#34;
        # get the status if it isn&#39;t passed in
        if (status is None):
            status = requests_get_status(self.__aurorax_obj, self.request_url)

        # check response
        if (status is None):  # pragma: nocover-ok
            raise AuroraXAPIError(&#34;Could not retrieve status for this request&#34;)

        # update request status by checking if data URI is set
        if (status[&#34;search_result&#34;][&#34;data_uri&#34;] is not None):
            self.completed = True
            self.data_url = &#34;%s/data&#34; % (self.request_url)

        # set class variable &#34;status&#34; and &#34;logs&#34;
        self.status = status
        self.logs = status[&#34;logs&#34;]

    def check_for_data(self) -&gt; bool:
        &#34;&#34;&#34;
        Check to see if data is available for this ephemeris search request

        Returns:
            True if data is available, else False
        &#34;&#34;&#34;
        self.update_status()
        return self.completed

    def get_data(self) -&gt; None:
        &#34;&#34;&#34;
        Retrieve the data available for this ephemeris search request
        &#34;&#34;&#34;
        # check if completed yet
        if (self.completed is False):
            print(&#34;No data available, update status or check for data first&#34;)
            return

        # get data
        raw_data = requests_get_data(self.__aurorax_obj, self.data_url, self.response_format, False)

        # set data variable
        if (self.response_format is not None):
            self.data = raw_data
        else:
            # cast data source objects
            for i in range(0, len(raw_data)):
                ds = DataSource(**raw_data[i][&#34;data_source&#34;], format=FORMAT_BASIC_INFO)
                raw_data[i][&#34;data_source&#34;] = ds

            # cast ephemeris objects
            self.data = [EphemerisData(**e) for e in raw_data]

    def wait(self, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; None:
        &#34;&#34;&#34;
        Block and wait for the request to complete and data is available for retrieval

        Args:
            poll_interval (float): 
                Time in seconds to wait between polling attempts, defaults to 1 second

            verbose (bool): 
                Output poll times and other progress messages, defaults to False
        &#34;&#34;&#34;
        url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_EPHEMERIS_REQUEST.format(self.request_id))
        self.update_status(requests_wait_for_data(self.__aurorax_obj, url, poll_interval, verbose))

    def cancel(self, wait: bool = False, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; int:
        &#34;&#34;&#34;
        Cancel the ephemeris search request

        This method returns immediately by default since the API processes
        this request asynchronously. If you would prefer to wait for it
        to be completed, set the &#39;wait&#39; parameter to True. You can adjust
        the polling time using the &#39;poll_interval&#39; parameter.

        Args:
            wait (bool): 
                Wait until the cancellation request has been completed (may wait for 
                several minutes)

            poll_interval (float): 
                Seconds to wait between polling calls, defaults to 1 second

            verbose (bool): 
                Output poll times and other progress messages, defaults to False

        Returns:
            1 on success

        Raises:
            pyaurorax.exceptions.AuroraXUnauthorizedError: Invalid API key for this operation
            pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
        &#34;&#34;&#34;
        url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_EPHEMERIS_REQUEST.format(self.request_id))
        return requests_cancel(self.__aurorax_obj, url, wait, poll_interval, verbose)

    def describe(self):
        &#34;&#34;&#34;
        Describe the ephemeris search as an &#34;SQL-like&#34; string.

        Returns:
            The &#34;SQL-like&#34; string describing the ephemeris search object
        &#34;&#34;&#34;
        # make request
        url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_DESCRIBE_EPHEMERIS_QUERY)
        req = AuroraXAPIRequest(self.__aurorax_obj, method=&#34;post&#34;, url=url, body=self.query)
        res = req.execute()

        # return
        return res.data</code></pre>
</details>
<div class="desc"><p>Class representing an ephemeris search</p>
<p>Note: At least one search criteria from programs, platforms, or instrument_types
must be specified.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>Start timestamp of the search (inclusive)</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>End timestamp of the search (inclusive)</dd>
<dt><strong><code>programs</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of programs to search through, defaults to None</dd>
<dt><strong><code>platforms</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of platforms to search through, defaults to None</dd>
<dt><strong><code>instrument_types</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of instrument types to search through, defaults to None</dd>
<dt><strong><code>metadata_filters</code></strong> :&ensp;<code>MetadataFilter</code> or <code>List[Dict]</code></dt>
<dd>List of dictionaries describing metadata keys and values to filter on, defaults
to None</dd>
<dt><strong><code>metadata_filters_logical_operator</code></strong> :&ensp;<code>str</code></dt>
<dd>The logical operator to use when evaluating metadata filters (either <code>AND</code> or <code>OR</code>),
defaults to <code>AND</code></dd>
<dt><strong><code>response_format</code></strong> :&ensp;<code>Dict</code></dt>
<dd>JSON representation of desired data response format</dd>
<dt><strong><code>request</code></strong> :&ensp;<code>AuroraXResponse</code></dt>
<dd>AuroraXResponse object returned when the search is executed</dd>
<dt><strong><code>request_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique ID assigned to the request by the AuroraX API</dd>
<dt><strong><code>request_url</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Unique URL assigned to the request by the AuroraX API</p>
<p>executed (bool):
Indicates if the search has been executed/started</p>
<p>completed (bool):
Indicates if the search has finished</p>
<p>data_url (str):
The URL where data is accessed</p>
<p>query (Dict):
The query for this request as JSON</p>
<p>status (Dict):
The status of the query</p>
<p>data (List[EphemerisData]):
The ephemeris records found</p>
<p>logs (List[Dict]):
All log messages outputted by the AuroraX API for this request</p>
</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="pyaurorax.search.ephemeris.classes.search.EphemerisSearch.query"><code class="name">prop <span class="ident">query</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def query(self):
    &#34;&#34;&#34;
    Property for the query value
    &#34;&#34;&#34;
    # set metadata filter value
    if (self.metadata_filters is None):
        metadata_filters_dict = {}
    elif (isinstance(self.metadata_filters, MetadataFilter) is True):
        # metadata filter is a class
        metadata_filters_dict = self.metadata_filters.to_query_dict()  # type: ignore
    else:
        # metadata filter is a dictionary
        metadata_filters_dict = {
            &#34;expressions&#34;: self.metadata_filters,
            &#34;logical_operator&#34;: self.metadata_filters_logical_operator,
        }

    # set query
    self.__query = {
        &#34;data_sources&#34;: {
            &#34;programs&#34;: [] if not self.programs else self.programs,
            &#34;platforms&#34;: [] if not self.platforms else self.platforms,
            &#34;instrument_types&#34;: [] if not self.instrument_types else self.instrument_types,
            &#34;ephemeris_metadata_filters&#34;: metadata_filters_dict,
        },
        &#34;start&#34;: self.start.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
        &#34;end&#34;: self.end.strftime(&#34;%Y-%m-%dT%H:%M:%S&#34;),
    }

    # return
    return self.__query</code></pre>
</details>
<div class="desc"><p>Property for the query value</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.ephemeris.classes.search.EphemerisSearch.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self, wait:Â boolÂ =Â False, poll_interval:Â floatÂ =Â 1.0, verbose:Â boolÂ =Â False) â€‘>Â int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self, wait: bool = False, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; int:
    &#34;&#34;&#34;
    Cancel the ephemeris search request

    This method returns immediately by default since the API processes
    this request asynchronously. If you would prefer to wait for it
    to be completed, set the &#39;wait&#39; parameter to True. You can adjust
    the polling time using the &#39;poll_interval&#39; parameter.

    Args:
        wait (bool): 
            Wait until the cancellation request has been completed (may wait for 
            several minutes)

        poll_interval (float): 
            Seconds to wait between polling calls, defaults to 1 second

        verbose (bool): 
            Output poll times and other progress messages, defaults to False

    Returns:
        1 on success

    Raises:
        pyaurorax.exceptions.AuroraXUnauthorizedError: Invalid API key for this operation
        pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
    &#34;&#34;&#34;
    url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_EPHEMERIS_REQUEST.format(self.request_id))
    return requests_cancel(self.__aurorax_obj, url, wait, poll_interval, verbose)</code></pre>
</details>
<div class="desc"><p>Cancel the ephemeris search request</p>
<p>This method returns immediately by default since the API processes
this request asynchronously. If you would prefer to wait for it
to be completed, set the 'wait' parameter to True. You can adjust
the polling time using the 'poll_interval' parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wait</code></strong> :&ensp;<code>bool</code></dt>
<dd>Wait until the cancellation request has been completed (may wait for
several minutes)</dd>
<dt><strong><code>poll_interval</code></strong> :&ensp;<code>float</code></dt>
<dd>Seconds to wait between polling calls, defaults to 1 second</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Output poll times and other progress messages, defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>1 on success</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnauthorizedError" href="../../../exceptions.html#pyaurorax.exceptions.AuroraXUnauthorizedError">AuroraXUnauthorizedError</a></code></dt>
<dd>Invalid API key for this operation</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXAPIError" href="../../../exceptions.html#pyaurorax.exceptions.AuroraXAPIError">AuroraXAPIError</a></code></dt>
<dd>An API error was encountered</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.ephemeris.classes.search.EphemerisSearch.check_for_data"><code class="name flex">
<span>def <span class="ident">check_for_data</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_for_data(self) -&gt; bool:
    &#34;&#34;&#34;
    Check to see if data is available for this ephemeris search request

    Returns:
        True if data is available, else False
    &#34;&#34;&#34;
    self.update_status()
    return self.completed</code></pre>
</details>
<div class="desc"><p>Check to see if data is available for this ephemeris search request</p>
<h2 id="returns">Returns</h2>
<p>True if data is available, else False</p></div>
</dd>
<dt id="pyaurorax.search.ephemeris.classes.search.EphemerisSearch.describe"><code class="name flex">
<span>def <span class="ident">describe</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe(self):
    &#34;&#34;&#34;
    Describe the ephemeris search as an &#34;SQL-like&#34; string.

    Returns:
        The &#34;SQL-like&#34; string describing the ephemeris search object
    &#34;&#34;&#34;
    # make request
    url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_DESCRIBE_EPHEMERIS_QUERY)
    req = AuroraXAPIRequest(self.__aurorax_obj, method=&#34;post&#34;, url=url, body=self.query)
    res = req.execute()

    # return
    return res.data</code></pre>
</details>
<div class="desc"><p>Describe the ephemeris search as an "SQL-like" string.</p>
<h2 id="returns">Returns</h2>
<p>The "SQL-like" string describing the ephemeris search object</p></div>
</dd>
<dt id="pyaurorax.search.ephemeris.classes.search.EphemerisSearch.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self) -&gt; None:
    &#34;&#34;&#34;
    Initiate ephemeris search request

    Raises:
        pyaurorax.exceptions.AuroraXError: Invalid request parameters are set
    &#34;&#34;&#34;
    # check for at least one filter criteria
    if not (self.programs or self.platforms or self.instrument_types or self.metadata_filters):  # pragma: nocover-ok
        raise AuroraXError(&#34;At least one filter criteria parameter besides &#39;start&#39; and &#39;end&#39; must be specified&#34;)

    # do request
    url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_EPHEMERIS_SEARCH)
    req = AuroraXAPIRequest(self.__aurorax_obj, method=&#34;post&#34;, url=url, body=self.query, null_response=True)
    res = req.execute()

    # set request ID, request_url, executed
    self.executed = True
    if (res.status_code == 202):
        # request successfully dispatched
        self.executed = True
        self.request_url = res.request.headers[&#34;location&#34;]
        self.request_id = self.request_url.rsplit(&#34;/&#34;, 1)[-1]

    # set the request variable
    self.request = res</code></pre>
</details>
<div class="desc"><p>Initiate ephemeris search request</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXError" href="../../../exceptions.html#pyaurorax.exceptions.AuroraXError">AuroraXError</a></code></dt>
<dd>Invalid request parameters are set</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.ephemeris.classes.search.EphemerisSearch.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(self) -&gt; None:
    &#34;&#34;&#34;
    Retrieve the data available for this ephemeris search request
    &#34;&#34;&#34;
    # check if completed yet
    if (self.completed is False):
        print(&#34;No data available, update status or check for data first&#34;)
        return

    # get data
    raw_data = requests_get_data(self.__aurorax_obj, self.data_url, self.response_format, False)

    # set data variable
    if (self.response_format is not None):
        self.data = raw_data
    else:
        # cast data source objects
        for i in range(0, len(raw_data)):
            ds = DataSource(**raw_data[i][&#34;data_source&#34;], format=FORMAT_BASIC_INFO)
            raw_data[i][&#34;data_source&#34;] = ds

        # cast ephemeris objects
        self.data = [EphemerisData(**e) for e in raw_data]</code></pre>
</details>
<div class="desc"><p>Retrieve the data available for this ephemeris search request</p></div>
</dd>
<dt id="pyaurorax.search.ephemeris.classes.search.EphemerisSearch.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print(self):
    &#34;&#34;&#34;
    A special print output for this class.
    &#34;&#34;&#34;
    # set status and query strings
    max_len = 80
    status_str = str(self.status)
    query_str = str(self.query)
    if (len(status_str) &gt; max_len):
        status_str = &#34;%s...&#34; % (status_str[0:max_len])
    if (len(query_str) &gt; max_len):
        query_str = &#34;%s...&#34; % (query_str[0:max_len])

    # set results string
    if (self.executed is True):
        if (len(self.data) == 1):
            data_str = &#34;[1 ephemeris result]&#34;
        else:
            data_str = &#34;[%d ephemeris results]&#34; % (len(self.data))
    else:
        data_str = &#34;&#34;

    # set logs string
    if (self.executed is True):
        if (len(self.logs) == 1):  # pragma: nocover-ok
            logs_str = &#34;[1 log message]&#34;
        else:
            logs_str = &#34;[%d log messages]&#34; % (len(self.logs))
    else:
        logs_str = &#34;&#34;

    # print
    print(&#34;EphemerisSearch:&#34;)
    print(&#34;  %-13s: %s&#34; % (&#34;executed&#34;, self.executed))
    print(&#34;  %-13s: %s&#34; % (&#34;completed&#34;, self.completed))
    print(&#34;  %-13s: %s&#34; % (&#34;request_id&#34;, self.request_id))
    print(&#34;  %-13s: %s&#34; % (&#34;request&#34;, self.request))
    print(&#34;  %-13s: %s&#34; % (&#34;request_url&#34;, self.request_url))
    print(&#34;  %-13s: %s&#34; % (&#34;data_url&#34;, self.data_url))
    print(&#34;  %-13s: %s&#34; % (&#34;query&#34;, query_str))
    print(&#34;  %-13s: %s&#34; % (&#34;status&#34;, status_str))
    print(&#34;  %-13s: %s&#34; % (&#34;data&#34;, data_str))
    print(&#34;  %-13s: %s&#34; % (&#34;logs&#34;, logs_str))</code></pre>
</details>
<div class="desc"><p>A special print output for this class.</p></div>
</dd>
<dt id="pyaurorax.search.ephemeris.classes.search.EphemerisSearch.update_status"><code class="name flex">
<span>def <span class="ident">update_status</span></span>(<span>self, status:Â Optional[Dict]Â =Â None) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_status(self, status: Optional[Dict] = None) -&gt; None:
    &#34;&#34;&#34;
    Update the status of this ephemeris search request

    Args:
        status (Dict): 
            The previously-retrieved status of this request (include to avoid requesting it 
            from the API again), defaults to None
    &#34;&#34;&#34;
    # get the status if it isn&#39;t passed in
    if (status is None):
        status = requests_get_status(self.__aurorax_obj, self.request_url)

    # check response
    if (status is None):  # pragma: nocover-ok
        raise AuroraXAPIError(&#34;Could not retrieve status for this request&#34;)

    # update request status by checking if data URI is set
    if (status[&#34;search_result&#34;][&#34;data_uri&#34;] is not None):
        self.completed = True
        self.data_url = &#34;%s/data&#34; % (self.request_url)

    # set class variable &#34;status&#34; and &#34;logs&#34;
    self.status = status
    self.logs = status[&#34;logs&#34;]</code></pre>
</details>
<div class="desc"><p>Update the status of this ephemeris search request</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>Dict</code></dt>
<dd>The previously-retrieved status of this request (include to avoid requesting it
from the API again), defaults to None</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.ephemeris.classes.search.EphemerisSearch.wait"><code class="name flex">
<span>def <span class="ident">wait</span></span>(<span>self, poll_interval:Â floatÂ =Â 1.0, verbose:Â boolÂ =Â False) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait(self, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; None:
    &#34;&#34;&#34;
    Block and wait for the request to complete and data is available for retrieval

    Args:
        poll_interval (float): 
            Time in seconds to wait between polling attempts, defaults to 1 second

        verbose (bool): 
            Output poll times and other progress messages, defaults to False
    &#34;&#34;&#34;
    url = &#34;%s/%s&#34; % (self.__aurorax_obj.api_base_url, self.__aurorax_obj.search.api.URL_SUFFIX_EPHEMERIS_REQUEST.format(self.request_id))
    self.update_status(requests_wait_for_data(self.__aurorax_obj, url, poll_interval, verbose))</code></pre>
</details>
<div class="desc"><p>Block and wait for the request to complete and data is available for retrieval</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>poll_interval</code></strong> :&ensp;<code>float</code></dt>
<dd>Time in seconds to wait between polling attempts, defaults to 1 second</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Output poll times and other progress messages, defaults to False</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.css" integrity="sha512-b+T2i3P45i1LZM7I00Ci5QquB9szqaxu+uuk5TUSGjZQ4w4n+qujQiIuvTv2BxE7WCGQCifNMksyKILDiHzsOg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.js" integrity="sha512-2B9/byNV1KKRm5nQ2RLViPFD6U4dUjDGwuW1GU+ImJh8YinPU9Zlq1GzdTMO+G2ROrB5o1qasJBy1ttYz0wCug==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyaurorax.search.ephemeris.classes" href="index.html">pyaurorax.search.ephemeris.classes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyaurorax.search.ephemeris.classes.search.EphemerisSearch" href="#pyaurorax.search.ephemeris.classes.search.EphemerisSearch">EphemerisSearch</a></code></h4>
<ul class="two-column">
<li><code><a title="pyaurorax.search.ephemeris.classes.search.EphemerisSearch.cancel" href="#pyaurorax.search.ephemeris.classes.search.EphemerisSearch.cancel">cancel</a></code></li>
<li><code><a title="pyaurorax.search.ephemeris.classes.search.EphemerisSearch.check_for_data" href="#pyaurorax.search.ephemeris.classes.search.EphemerisSearch.check_for_data">check_for_data</a></code></li>
<li><code><a title="pyaurorax.search.ephemeris.classes.search.EphemerisSearch.describe" href="#pyaurorax.search.ephemeris.classes.search.EphemerisSearch.describe">describe</a></code></li>
<li><code><a title="pyaurorax.search.ephemeris.classes.search.EphemerisSearch.execute" href="#pyaurorax.search.ephemeris.classes.search.EphemerisSearch.execute">execute</a></code></li>
<li><code><a title="pyaurorax.search.ephemeris.classes.search.EphemerisSearch.get_data" href="#pyaurorax.search.ephemeris.classes.search.EphemerisSearch.get_data">get_data</a></code></li>
<li><code><a title="pyaurorax.search.ephemeris.classes.search.EphemerisSearch.pretty_print" href="#pyaurorax.search.ephemeris.classes.search.EphemerisSearch.pretty_print">pretty_print</a></code></li>
<li><code><a title="pyaurorax.search.ephemeris.classes.search.EphemerisSearch.query" href="#pyaurorax.search.ephemeris.classes.search.EphemerisSearch.query">query</a></code></li>
<li><code><a title="pyaurorax.search.ephemeris.classes.search.EphemerisSearch.update_status" href="#pyaurorax.search.ephemeris.classes.search.EphemerisSearch.update_status">update_status</a></code></li>
<li><code><a title="pyaurorax.search.ephemeris.classes.search.EphemerisSearch.wait" href="#pyaurorax.search.ephemeris.classes.search.EphemerisSearch.wait">wait</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
