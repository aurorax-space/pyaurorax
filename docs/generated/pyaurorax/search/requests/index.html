<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>pyaurorax.search.requests API documentation</title>
<meta name="description" content="Helper methods for retrieving data from an AuroraX search engine API
request â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
<style>
@media screen and (max-width: 699px) {
#content {
padding-left: 2em;
padding-right: 2em;
padding-top: 0;
}
}
@media screen and (min-width: 700px) {
#content {
max-width: 125ch;
padding-left: 3em;
padding-right: 3em;
padding-top: 1em;
border-left: 1px solid #ddd;
}
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyaurorax.search.requests</code></h1>
</header>
<section id="section-intro">
<p>Helper methods for retrieving data from an AuroraX search engine API
request.</p>
<p>Note that all functions and classes from submodules are all imported
at this level of the requests module. They can be referenced from
here instead of digging in deeper to the submodules.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyaurorax.search.requests.RequestsManager"><code class="flex name class">
<span>class <span class="ident">RequestsManager</span></span>
<span>(</span><span>aurorax_obj)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RequestsManager:
    &#34;&#34;&#34;
    The RequestsManager object is initialized within every PyAuroraX object. It acts as a way to access 
    the submodules and carry over configuration information in the super class.
    &#34;&#34;&#34;

    __STANDARD_POLLING_SLEEP_TIME: float = 1.0  # Polling sleep time when waiting for data (after the initial sleep time), in seconds

    def __init__(self, aurorax_obj):
        self.__aurorax_obj = aurorax_obj

    def get_status(self, request_url: str) -&gt; Dict:
        &#34;&#34;&#34;
        Retrieve the status of a request

        Args:
            request_url (str): 
                The URL of the request information

        Returns:
            The status information for the request
        &#34;&#34;&#34;
        return func_get_status(self.__aurorax_obj, request_url)

    def get_data(self, data_url: str, response_format: Optional[Dict] = None, skip_serializing: bool = False) -&gt; List:
        &#34;&#34;&#34;
        Retrieve the data for a request

        Args:
            data_url (str): 
                The URL for the data of a request,
            
            response_format (Dict): 
                The response format to send as post data, defaults to None
            
            skip_serializing (bool): 
                Skip any object serializing, defaults to False

        Raises:
            pyaurorax.exceptions.AuroraXDataRetrievalError: Error retrieving data

        Returns:
            the data for this request
        &#34;&#34;&#34;
        return func_get_data(self.__aurorax_obj, data_url, response_format, skip_serializing)

    def get_logs(self, request_url: str) -&gt; List:
        &#34;&#34;&#34;
        Retrieve the logs for a request

        Args:
            request_url (str): 
                The URL of the request information

        Returns:
            The log messages for the request
        &#34;&#34;&#34;
        return func_get_logs(self.__aurorax_obj, request_url)

    def wait_for_data(self, request_url: str, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; Dict:
        &#34;&#34;&#34;
        Block and wait for the data to be made available for a request

        Args:
            request_url (str): 
                The URL of the request information
            
            poll_interval (float): 
                Seconds to wait between polling calls, defaults to 1 second
            
            verbose (bool): 
                Output poll times and other progress messages, defaults to False

        Returns:
            the status information for the request
        &#34;&#34;&#34;
        return func_wait_for_data(self.__aurorax_obj, request_url, poll_interval, verbose)

    def cancel(self, request_url: str, wait: bool = False, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; int:
        &#34;&#34;&#34;
        Cancel the request at the given URL.

        This method returns immediately by default since the API processes
        this request asynchronously. If you would prefer to wait for it
        to be completed, set the &#39;wait&#39; parameter to True. You can adjust
        the polling time using the &#39;poll_interval&#39; parameter.

        Args:
            request_url (str): 
                The URL string of the request to be canceled
            
            wait (bool): 
                Set to True to block until the cancellation request has been completed (may 
                wait for several minutes)
            
            poll_interval (float): 
                Seconds to wait between polling calls, defaults to 1 second
            
            verbose (bool): 
                If True then output poll times and other progress, defaults to False

        Returns:
            0 on success

        Raises:
            pyaurorax.exceptions.AuroraXUnauthorizedError: Invalid API key for this operation
            pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
        &#34;&#34;&#34;
        return func_cancel(self.__aurorax_obj, request_url, wait, poll_interval, verbose)

    def list(self,
             search_type: Optional[Literal[&#34;conjunction&#34;, &#34;ephemeris&#34;, &#34;data_product&#34;]] = None,
             active: Optional[bool] = None,
             start: Optional[datetime.datetime] = None,
             end: Optional[datetime.datetime] = None,
             file_size: Optional[int] = None,
             result_count: Optional[int] = None,
             query_duration: Optional[int] = None,
             error_condition: Optional[bool] = None) -&gt; List:
        &#34;&#34;&#34;
        Retrieve a list of search requests matching certain criteria.  Administrators only.

        Args:
            search_type (str): 
                The type of search request, valid values are &#39;conjunction&#39;, &#39;ephemeris&#39;, or 
                &#39;data_product&#39;. Exclusion of value will return all search requests of any 
                type, defaults to None

            active (bool): 
                Return searches that are currently active or not, exclude for both, defaults to None

            start (datetime.datetime): 
                Start timestamp for narrowing down search timeframes, defaults to None

            end (datetime.datetime): 
                End timestamp for narrowing down search timeframes, defaults to None

            file_size (int): 
                Filter by result file size, measured in KB, defaults to None

            result_count (int): 
                Filter by result count, defaults to None

            query_duration (int): 
                Filter by query duration, measured in milliseconds, defaults to None

            error_condition (bool): 
                Filter by if an error occurred or not, exclude for both, defaults to None

        Returns:
            List of matching search requests

        Raises:
            ValueError: Unsupported search type
            pyaurorax.exceptions.AuroraXUnauthorizedError: Invalid API key for this operation
        &#34;&#34;&#34;
        return func_list(self.__aurorax_obj, search_type, active, start, end, file_size, result_count, query_duration, error_condition)

    def delete(self, request_id: str) -&gt; int:  # pragma: nocover
        &#34;&#34;&#34;
        Entirely remove a search request from the AuroraX database. Administrators only.

        Args:
            request_id (str): 
                Search request UUID

        Returns:
            0 on success, raises error on failure

        Raises:
            pyaurorax.exceptions.AuroraXNotFoundError: Data source not found
        &#34;&#34;&#34;
        return func_delete(self.__aurorax_obj, request_id)</code></pre>
</details>
<div class="desc"><p>The RequestsManager object is initialized within every PyAuroraX object. It acts as a way to access
the submodules and carry over configuration information in the super class.</p></div>
<h3>Methods</h3>
<dl>
<dt id="pyaurorax.search.requests.RequestsManager.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self,<br>request_url:Â str,<br>wait:Â boolÂ =Â False,<br>poll_interval:Â floatÂ =Â 1.0,<br>verbose:Â boolÂ =Â False) â€‘>Â int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self, request_url: str, wait: bool = False, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; int:
    &#34;&#34;&#34;
    Cancel the request at the given URL.

    This method returns immediately by default since the API processes
    this request asynchronously. If you would prefer to wait for it
    to be completed, set the &#39;wait&#39; parameter to True. You can adjust
    the polling time using the &#39;poll_interval&#39; parameter.

    Args:
        request_url (str): 
            The URL string of the request to be canceled
        
        wait (bool): 
            Set to True to block until the cancellation request has been completed (may 
            wait for several minutes)
        
        poll_interval (float): 
            Seconds to wait between polling calls, defaults to 1 second
        
        verbose (bool): 
            If True then output poll times and other progress, defaults to False

    Returns:
        0 on success

    Raises:
        pyaurorax.exceptions.AuroraXUnauthorizedError: Invalid API key for this operation
        pyaurorax.exceptions.AuroraXAPIError: An API error was encountered
    &#34;&#34;&#34;
    return func_cancel(self.__aurorax_obj, request_url, wait, poll_interval, verbose)</code></pre>
</details>
<div class="desc"><p>Cancel the request at the given URL.</p>
<p>This method returns immediately by default since the API processes
this request asynchronously. If you would prefer to wait for it
to be completed, set the 'wait' parameter to True. You can adjust
the polling time using the 'poll_interval' parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request_url</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL string of the request to be canceled</dd>
<dt><strong><code>wait</code></strong> :&ensp;<code>bool</code></dt>
<dd>Set to True to block until the cancellation request has been completed (may
wait for several minutes)</dd>
<dt><strong><code>poll_interval</code></strong> :&ensp;<code>float</code></dt>
<dd>Seconds to wait between polling calls, defaults to 1 second</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True then output poll times and other progress, defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>0 on success</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnauthorizedError" href="../../exceptions.html#pyaurorax.exceptions.AuroraXUnauthorizedError">AuroraXUnauthorizedError</a></code></dt>
<dd>Invalid API key for this operation</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXAPIError" href="../../exceptions.html#pyaurorax.exceptions.AuroraXAPIError">AuroraXAPIError</a></code></dt>
<dd>An API error was encountered</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.requests.RequestsManager.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, request_id:Â str) â€‘>Â int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, request_id: str) -&gt; int:  # pragma: nocover
    &#34;&#34;&#34;
    Entirely remove a search request from the AuroraX database. Administrators only.

    Args:
        request_id (str): 
            Search request UUID

    Returns:
        0 on success, raises error on failure

    Raises:
        pyaurorax.exceptions.AuroraXNotFoundError: Data source not found
    &#34;&#34;&#34;
    return func_delete(self.__aurorax_obj, request_id)</code></pre>
</details>
<div class="desc"><p>Entirely remove a search request from the AuroraX database. Administrators only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Search request UUID</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>0 on success, raises error on failure</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXNotFoundError" href="../../exceptions.html#pyaurorax.exceptions.AuroraXNotFoundError">AuroraXNotFoundError</a></code></dt>
<dd>Data source not found</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.requests.RequestsManager.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self,<br>data_url:Â str,<br>response_format:Â DictÂ |Â NoneÂ =Â None,<br>skip_serializing:Â boolÂ =Â False) â€‘>Â List</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(self, data_url: str, response_format: Optional[Dict] = None, skip_serializing: bool = False) -&gt; List:
    &#34;&#34;&#34;
    Retrieve the data for a request

    Args:
        data_url (str): 
            The URL for the data of a request,
        
        response_format (Dict): 
            The response format to send as post data, defaults to None
        
        skip_serializing (bool): 
            Skip any object serializing, defaults to False

    Raises:
        pyaurorax.exceptions.AuroraXDataRetrievalError: Error retrieving data

    Returns:
        the data for this request
    &#34;&#34;&#34;
    return func_get_data(self.__aurorax_obj, data_url, response_format, skip_serializing)</code></pre>
</details>
<div class="desc"><p>Retrieve the data for a request</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_url</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL for the data of a request,</dd>
<dt><strong><code>response_format</code></strong> :&ensp;<code>Dict</code></dt>
<dd>The response format to send as post data, defaults to None</dd>
<dt><strong><code>skip_serializing</code></strong> :&ensp;<code>bool</code></dt>
<dd>Skip any object serializing, defaults to False</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="pyaurorax.exceptions.AuroraXDataRetrievalError" href="../../exceptions.html#pyaurorax.exceptions.AuroraXDataRetrievalError">AuroraXDataRetrievalError</a></code></dt>
<dd>Error retrieving data</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the data for this request</p></div>
</dd>
<dt id="pyaurorax.search.requests.RequestsManager.get_logs"><code class="name flex">
<span>def <span class="ident">get_logs</span></span>(<span>self, request_url:Â str) â€‘>Â List</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_logs(self, request_url: str) -&gt; List:
    &#34;&#34;&#34;
    Retrieve the logs for a request

    Args:
        request_url (str): 
            The URL of the request information

    Returns:
        The log messages for the request
    &#34;&#34;&#34;
    return func_get_logs(self.__aurorax_obj, request_url)</code></pre>
</details>
<div class="desc"><p>Retrieve the logs for a request</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request_url</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL of the request information</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The log messages for the request</p></div>
</dd>
<dt id="pyaurorax.search.requests.RequestsManager.get_status"><code class="name flex">
<span>def <span class="ident">get_status</span></span>(<span>self, request_url:Â str) â€‘>Â Dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_status(self, request_url: str) -&gt; Dict:
    &#34;&#34;&#34;
    Retrieve the status of a request

    Args:
        request_url (str): 
            The URL of the request information

    Returns:
        The status information for the request
    &#34;&#34;&#34;
    return func_get_status(self.__aurorax_obj, request_url)</code></pre>
</details>
<div class="desc"><p>Retrieve the status of a request</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request_url</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL of the request information</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The status information for the request</p></div>
</dd>
<dt id="pyaurorax.search.requests.RequestsManager.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self,<br>search_type:Â Literal['conjunction',Â 'ephemeris',Â 'data_product']Â |Â NoneÂ =Â None,<br>active:Â boolÂ |Â NoneÂ =Â None,<br>start:Â datetime.datetimeÂ |Â NoneÂ =Â None,<br>end:Â datetime.datetimeÂ |Â NoneÂ =Â None,<br>file_size:Â intÂ |Â NoneÂ =Â None,<br>result_count:Â intÂ |Â NoneÂ =Â None,<br>query_duration:Â intÂ |Â NoneÂ =Â None,<br>error_condition:Â boolÂ |Â NoneÂ =Â None) â€‘>Â List</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self,
         search_type: Optional[Literal[&#34;conjunction&#34;, &#34;ephemeris&#34;, &#34;data_product&#34;]] = None,
         active: Optional[bool] = None,
         start: Optional[datetime.datetime] = None,
         end: Optional[datetime.datetime] = None,
         file_size: Optional[int] = None,
         result_count: Optional[int] = None,
         query_duration: Optional[int] = None,
         error_condition: Optional[bool] = None) -&gt; List:
    &#34;&#34;&#34;
    Retrieve a list of search requests matching certain criteria.  Administrators only.

    Args:
        search_type (str): 
            The type of search request, valid values are &#39;conjunction&#39;, &#39;ephemeris&#39;, or 
            &#39;data_product&#39;. Exclusion of value will return all search requests of any 
            type, defaults to None

        active (bool): 
            Return searches that are currently active or not, exclude for both, defaults to None

        start (datetime.datetime): 
            Start timestamp for narrowing down search timeframes, defaults to None

        end (datetime.datetime): 
            End timestamp for narrowing down search timeframes, defaults to None

        file_size (int): 
            Filter by result file size, measured in KB, defaults to None

        result_count (int): 
            Filter by result count, defaults to None

        query_duration (int): 
            Filter by query duration, measured in milliseconds, defaults to None

        error_condition (bool): 
            Filter by if an error occurred or not, exclude for both, defaults to None

    Returns:
        List of matching search requests

    Raises:
        ValueError: Unsupported search type
        pyaurorax.exceptions.AuroraXUnauthorizedError: Invalid API key for this operation
    &#34;&#34;&#34;
    return func_list(self.__aurorax_obj, search_type, active, start, end, file_size, result_count, query_duration, error_condition)</code></pre>
</details>
<div class="desc"><p>Retrieve a list of search requests matching certain criteria.
Administrators only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>search_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of search request, valid values are 'conjunction', 'ephemeris', or
'data_product'. Exclusion of value will return all search requests of any
type, defaults to None</dd>
<dt><strong><code>active</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return searches that are currently active or not, exclude for both, defaults to None</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>Start timestamp for narrowing down search timeframes, defaults to None</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>End timestamp for narrowing down search timeframes, defaults to None</dd>
<dt><strong><code>file_size</code></strong> :&ensp;<code>int</code></dt>
<dd>Filter by result file size, measured in KB, defaults to None</dd>
<dt><strong><code>result_count</code></strong> :&ensp;<code>int</code></dt>
<dd>Filter by result count, defaults to None</dd>
<dt><strong><code>query_duration</code></strong> :&ensp;<code>int</code></dt>
<dd>Filter by query duration, measured in milliseconds, defaults to None</dd>
<dt><strong><code>error_condition</code></strong> :&ensp;<code>bool</code></dt>
<dd>Filter by if an error occurred or not, exclude for both, defaults to None</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of matching search requests</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Unsupported search type</dd>
<dt><code><a title="pyaurorax.exceptions.AuroraXUnauthorizedError" href="../../exceptions.html#pyaurorax.exceptions.AuroraXUnauthorizedError">AuroraXUnauthorizedError</a></code></dt>
<dd>Invalid API key for this operation</dd>
</dl></div>
</dd>
<dt id="pyaurorax.search.requests.RequestsManager.wait_for_data"><code class="name flex">
<span>def <span class="ident">wait_for_data</span></span>(<span>self, request_url:Â str, poll_interval:Â floatÂ =Â 1.0, verbose:Â boolÂ =Â False) â€‘>Â Dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for_data(self, request_url: str, poll_interval: float = __STANDARD_POLLING_SLEEP_TIME, verbose: bool = False) -&gt; Dict:
    &#34;&#34;&#34;
    Block and wait for the data to be made available for a request

    Args:
        request_url (str): 
            The URL of the request information
        
        poll_interval (float): 
            Seconds to wait between polling calls, defaults to 1 second
        
        verbose (bool): 
            Output poll times and other progress messages, defaults to False

    Returns:
        the status information for the request
    &#34;&#34;&#34;
    return func_wait_for_data(self.__aurorax_obj, request_url, poll_interval, verbose)</code></pre>
</details>
<div class="desc"><p>Block and wait for the data to be made available for a request</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request_url</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL of the request information</dd>
<dt><strong><code>poll_interval</code></strong> :&ensp;<code>float</code></dt>
<dd>Seconds to wait between polling calls, defaults to 1 second</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Output poll times and other progress messages, defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the status information for the request</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.css" integrity="sha512-b+T2i3P45i1LZM7I00Ci5QquB9szqaxu+uuk5TUSGjZQ4w4n+qujQiIuvTv2BxE7WCGQCifNMksyKILDiHzsOg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.js" integrity="sha512-2B9/byNV1KKRm5nQ2RLViPFD6U4dUjDGwuW1GU+ImJh8YinPU9Zlq1GzdTMO+G2ROrB5o1qasJBy1ttYz0wCug==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyaurorax.search" href="../index.html">pyaurorax.search</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyaurorax.search.requests.RequestsManager" href="#pyaurorax.search.requests.RequestsManager">RequestsManager</a></code></h4>
<ul class="two-column">
<li><code><a title="pyaurorax.search.requests.RequestsManager.cancel" href="#pyaurorax.search.requests.RequestsManager.cancel">cancel</a></code></li>
<li><code><a title="pyaurorax.search.requests.RequestsManager.delete" href="#pyaurorax.search.requests.RequestsManager.delete">delete</a></code></li>
<li><code><a title="pyaurorax.search.requests.RequestsManager.get_data" href="#pyaurorax.search.requests.RequestsManager.get_data">get_data</a></code></li>
<li><code><a title="pyaurorax.search.requests.RequestsManager.get_logs" href="#pyaurorax.search.requests.RequestsManager.get_logs">get_logs</a></code></li>
<li><code><a title="pyaurorax.search.requests.RequestsManager.get_status" href="#pyaurorax.search.requests.RequestsManager.get_status">get_status</a></code></li>
<li><code><a title="pyaurorax.search.requests.RequestsManager.list" href="#pyaurorax.search.requests.RequestsManager.list">list</a></code></li>
<li><code><a title="pyaurorax.search.requests.RequestsManager.wait_for_data" href="#pyaurorax.search.requests.RequestsManager.wait_for_data">wait_for_data</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
